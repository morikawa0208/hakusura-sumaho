<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç¸¦æŒã¡ãƒã‚¯ã‚¹ãƒ©è©¦ä½œ</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #111827;
      --accent: #34d399;
      --accent-2: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(circle at 20% 20%, rgba(52, 211, 153, 0.08), transparent 25%),
        radial-gradient(circle at 80% 10%, rgba(96, 165, 250, 0.08), transparent 22%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", "Hiragino Sans", system-ui, -apple-system, sans-serif;
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      padding: 6px;
    }

    .phone {
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      width: min(460px, 100%);
      height: calc(100vh - 12px);
      display: grid;
      grid-template-rows: auto auto 1fr auto auto auto;
      gap: 6px;
      padding: 8px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px;
    }

    .subtle {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .bars {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 22px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .bar span {
      position: absolute;
      inset: 0;
      width: 50%;
      border-radius: 999px;
    }

    .bar .label {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .bar .hp {
      background: #ef4444;
    }

    .bar .mp {
      background: #3b82f6;
    }

    .bar .exp {
      background: #facc15;
    }

    #log {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.5;
      overflow: auto;
      height: 170px;
      max-height: 280px;
      min-height: 130px;
      resize: vertical;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .log-card {
      display: flex;
      flex-direction: column;
    }

    .log-card #log {
      flex: 1;
    }

    #log .entry {
      opacity: 0.95;
      padding: 4px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
    }

    #log .entry.info {
      color: #e5e7eb;
    }

    #log .entry.player {
      color: #93c5fd;
    }

    #log .entry.enemy {
      color: #fca5a5;
    }

    #log .entry.good {
      color: #6ee7b7;
    }

    #log .entry.warning {
      color: #fcd34d;
    }

    #log .entry.danger {
      color: #fb7185;
    }

    #actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    button {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.2), rgba(96, 165, 250, 0.2));
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu {
      display: flex;
      justify-content: space-around;
      gap: 6px;
    }

    .pill {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.06);
      padding: 4px 8px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .tag {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      letter-spacing: 0.03em;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
    }

    .inline-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-top: 4px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      padding: 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      display: grid;
      gap: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .stat-value {
      font-weight: 700;
      font-size: 13px;
      text-align: right;
    }

    .stat-value .total {
      font-weight: 800;
    }

    .stat-value .base {
      color: var(--muted);
      font-weight: 600;
    }

    .stat-value .bonus {
      color: var(--accent);
      font-weight: 800;
    }

    .stat-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    details {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .enemy-list {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
      padding-bottom: 2px;
    }

    .enemy-card {
      display: grid;
      gap: 6px;
      padding: 9px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.08s ease, border-color 0.12s ease, box-shadow 0.12s ease;
      min-width: 0;
    }

    .enemy-card:active {
      transform: translateY(1px);
    }

    .enemy-card:hover {
      border-color: rgba(255, 255, 255, 0.16);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }

    .enemy-top {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .enemy-name {
      display: grid;
      gap: 2px;
      font-weight: 600;
    }

    .enemy-bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .enemy-bar .fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ef4444, #f87171);
      width: 50%;
      border-radius: 999px;
    }

    .enemy-bar .label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      line-height: 1;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 50;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      width: min(420px, 94%);
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    .help-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      font-weight: 800;
      cursor: pointer;
    }

    .help-panel {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      line-height: 1.5;
    }

    .help-panel ul {
      padding-left: 16px;
      margin: 6px 0;
    }

    .modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      border-radius: 999px;
      width: 30px;
      height: 30px;
      cursor: pointer;
    }

    details summary {
      cursor: pointer;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 8px;
    }

  </style>
</head>
<body>
  <div class="phone">
    <section class="card">
      <div id="enemies" class="enemy-list"></div>
    </section>

    <section class="card">
      <div class="subtle" style="justify-content: flex-start; gap: 10px; margin-bottom: 4px;">
        <span>LV <span id="level"></span></span>
        <span class="pill">éšå±¤ <span id="floor-inline"></span>F</span>
      </div>
      <div class="bars">
        <div class="bar">
          <span id="hp-bar" class="hp"></span>
          <span id="hp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="mp-bar" class="mp"></span>
          <span id="mp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="exp-bar" class="exp"></span>
          <span id="exp-label" class="label"></span>
        </div>
      </div>
    </section>

    <section class="card log-card">
      <div id="log"></div>
    </section>

    <section class="card">
      <div id="actions"></div>
    </section>

    <nav class="menu">
      <button id="btn-player-modal">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è©³ç´°</button>
      <button id="btn-skill-tree">ã‚¹ã‚­ãƒ«</button>
    </nav>
  </div>

  <div id="enemy-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">æ•µã®è©³ç´°</div>
          <div id="modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="modal-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>HP <span id="modal-hp"></span></div>
        <div>ATK <span id="modal-atk"></span></div>
        <div>DEF <span id="modal-def"></span></div>
        <div>SPD <span id="modal-spd"></span></div>
      </div>
      <div class="pill" id="modal-tag" style="margin-top: 10px; display: inline-flex;">BOSS</div>
    </div>
  </div>

  <div id="player-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è©³ç´°</div>
          <div style="font-weight: 700;">ä¸€æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨äºŒæ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
        </div>
        <button id="player-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
        <div class="section-title" style="margin: 8px 0 4px;">äºŒæ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
        <button class="help-icon" id="stat-help" aria-label="è¨ˆç®—å¼ãƒ¡ãƒ¢">ï¼Ÿ</button>
      </div>
      <div id="stat-help-panel" class="help-panel" style="display: none;">
        <div style="font-weight: 700; margin-bottom: 4px;">è¨ˆç®—ãƒ¡ãƒ¢</div>
        <ul>
          <li>æœ€å¤§HP = åŸºç¤HP + ä½“åŠ› Ã— 10</li>
          <li>æœ€å¤§MP = åŸºç¤MP + çŸ¥è­˜ Ã—2 + ä½“åŠ›Ã—0.5</li>
          <li>ç‰©ç†æ”»æ’ƒåŠ› = æ­¦å™¨ + åŠ› Ã— 1.2</li>
          <li>é­”æ³•æ”»æ’ƒåŠ› = é­”å™¨ + çŸ¥è­˜ Ã— 1.3</li>
          <li>ç‰©ç†é˜²å¾¡åŠ› = ä½“åŠ›Ã—0.6 + åŠ›Ã—0.2</li>
          <li>é­”æ³•é˜²å¾¡åŠ› = ä½“åŠ›Ã—0.5 + çŸ¥è­˜Ã—0.3</li>
          <li>è¡Œå‹•é€Ÿåº¦ = åŸºç¤é€Ÿåº¦ + æ•æ·</li>
          <li>å‘½ä¸­ç‡ = 70% + æ•æ·Ã—0.1%</li>
          <li>ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ / å›é¿ç‡ = (æ•æ·+é‹) ã‚’æ¸›è¡°å¼ã§</li>
        </ul>
      </div>
      <div id="secondary-stats" class="stat-grid"></div>
      <div class="inline-buttons" style="margin-top: 8px;">
        <div class="pill">èƒ½åŠ›P: <span id="stat-points"></span></div>
        <div class="pill">ã‚¹ã‚­ãƒ«P: <span id="skill-points"></span></div>
      </div>
      <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
        <div class="section-title" style="margin: 10px 0 6px;">ä¸€æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ / ã‚¹ãƒ†æŒ¯ã‚Š</div>
        <button id="reset-stats" class="help-icon" aria-label="ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ">â†º</button>
      </div>
      <div id="primary-stats" class="stat-grid"></div>
    </div>
  </div>

  <div id="skills-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ã‚¹ã‚­ãƒ« / ãƒ‘ãƒ¼ã‚¯</div>
          <div style="font-weight: 700;">ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚’æ¶ˆè²»ã—ã¦å¼·åŒ–</div>
        </div>
        <button id="skills-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div id="skills" style="margin-top: 6px;"></div>
    </div>
  </div>

  <script>
    const player = {
      name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
      level: 1,
      exp: 0,
      expToLevel: 20,
      hp: 0,
      mp: 0,
      maxHp: 0,
      maxMp: 0,
      atk: 0,
      def: 0,
      spd: 0,
      base: {
        hp: 80,
        mp: 30,
        physAtk: 10,
        magAtk: 8,
        physDef: 4,
        magDef: 4,
        speed: 4,
      },
      primary: {
        str: { label: "åŠ›", base: 8, bonus: 0 },
        int: { label: "çŸ¥è­˜", base: 4, bonus: 0 },
        vit: { label: "ä½“åŠ›", base: 10, bonus: 0 },
        agi: { label: "æ•æ·", base: 6, bonus: 0 },
        luck: { label: "é‹", base: 5, bonus: 0 },
      },
      allocations: {
        str: 0,
        int: 0,
        vit: 0,
        agi: 0,
        luck: 0,
      },
      bonus: {
        hp: 0,
        mp: 0,
        physAtk: 0,
        magAtk: 0,
        physDef: 0,
        magDef: 0,
        speed: 0,
        critRate: 0,
        evade: 0,
      },
      statPoints: 3,
      skillPoints: 0,
      buffs: { guard: 0, haste: 0, focus: 0 },
    };

    const game = {
      floor: 1,
      enemies: [],
      turnQueue: [],
      awaitingInput: false,
      defeatedBosses: 0,
    };

    const skills = {
      sharpEdge: {
        name: "é‹­åˆƒ",
        desc: "ç‰©ç†æ”»æ’ƒ+2 (æœ€å¤§3)",
        level: 0,
        max: 3,
        apply: () => (player.bonus.physAtk += 2),
      },
      quickStep: {
        name: "ç–¾é§†",
        desc: "é€Ÿåº¦+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.speed += 2),
      },
      arcaneFlow: {
        name: "é­”åŠ›å¾ªç’°",
        desc: "æœ€å¤§MP+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.mp += 2),
      },
    };

    function log(message, type = "info") {
      const logBox = document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `entry ${type}`;
      entry.textContent = message;
      logBox.appendChild(entry);
      logBox.scrollTop = logBox.scrollHeight;
    }

    const primaryOrder = ["str", "int", "vit", "agi", "luck"];
    let cachedSecondaries = null;

    const displayNumber = (num, isPercent = false) => {
      if (Number.isInteger(num)) return num;
      return Number(num.toFixed(isPercent ? 1 : 0));
    };

    const formatStatValue = (stat, unit = "") => {
      if (!stat) return "-";
      const isPercent = unit === "%";
      const total = `${displayNumber(stat.total, isPercent)}${unit}`;
      if (!stat.bonus) {
        return `<span class="total">${total}</span>`;
      }
      const bonusSign = stat.bonus > 0 ? "+" : "";
      return `<span class="total">${total}</span> (<span class="base">${displayNumber(stat.base, isPercent)}</span> <span class="bonus">${bonusSign}${displayNumber(stat.bonus, isPercent)}</span>)`;
    };

    const formatPrimaryValue = (stat) => {
      const total = stat.base + stat.bonus;
      if (!stat.bonus) return `<span class="total">${total}</span>`;
      const bonusSign = stat.bonus > 0 ? "+" : "";
      return `<span class="total">${total}</span> (<span class="base">${stat.base}</span> <span class="bonus">${bonusSign}${stat.bonus}</span>)`;
    };

    const statTotal = (key) => {
      const stat = player.primary[key];
      return stat.base + stat.bonus;
    };

    function calcSecondaryStats() {
      const str = statTotal("str");
      const int = statTotal("int");
      const vit = statTotal("vit");
      const agi = statTotal("agi");
      const luck = statTotal("luck");

      const maxHpBase = player.base.hp + vit * 10;
      const maxMpBase = player.base.mp + int * 2 + vit * 0.5;
      const physAtkBase = player.base.physAtk + str * 1.2;
      const magAtkBase = player.base.magAtk + int * 1.3;
      const physDefBase = player.base.physDef + vit * 0.6 + str * 0.2;
      const magDefBase = player.base.magDef + vit * 0.5 + int * 0.3;
      const speedBase = player.base.speed + agi;
      const critBase = Math.min(40, 5 + (agi + luck) * 0.35);
      const evadeBase = Math.min(30, 5 + (agi + luck) * 0.25);
      const accuracyBase = Math.min(95, 70 + agi * 0.1);

      return {
        maxHp: { base: maxHpBase, bonus: player.bonus.hp, total: maxHpBase + player.bonus.hp },
        maxMp: { base: maxMpBase, bonus: player.bonus.mp, total: maxMpBase + player.bonus.mp },
        physAtk: { base: physAtkBase, bonus: player.bonus.physAtk, total: physAtkBase + player.bonus.physAtk },
        magAtk: { base: magAtkBase, bonus: player.bonus.magAtk, total: magAtkBase + player.bonus.magAtk },
        physDef: { base: physDefBase, bonus: player.bonus.physDef, total: physDefBase + player.bonus.physDef },
        magDef: { base: magDefBase, bonus: player.bonus.magDef, total: magDefBase + player.bonus.magDef },
        speed: { base: speedBase, bonus: player.bonus.speed, total: speedBase + player.bonus.speed },
        critRate: { base: critBase, bonus: player.bonus.critRate, total: Math.min(70, critBase + player.bonus.critRate) },
        evade: { base: evadeBase, bonus: player.bonus.evade, total: Math.min(60, evadeBase + player.bonus.evade) },
        accuracy: { base: accuracyBase, bonus: 0, total: accuracyBase },
      };
    }

    function recalcDerivedStats() {
      const derived = calcSecondaryStats();
      const prevMaxHp = player.maxHp || derived.maxHp.total;
      const prevMaxMp = player.maxMp || derived.maxMp.total;

      if (player.maxHp === 0) {
        player.hp = derived.maxHp.total;
      } else {
        const hpDelta = derived.maxHp.total - prevMaxHp;
        if (hpDelta > 0) player.hp += hpDelta;
        if (player.hp > derived.maxHp.total) player.hp = derived.maxHp.total;
      }

      if (player.maxMp === 0) {
        player.mp = derived.maxMp.total;
      } else {
        const mpDelta = derived.maxMp.total - prevMaxMp;
        if (mpDelta > 0) player.mp += mpDelta;
        if (player.mp > derived.maxMp.total) player.mp = derived.maxMp.total;
      }

      player.maxHp = Math.round(derived.maxHp.total);
      player.maxMp = Math.round(derived.maxMp.total);
      player.atk = Math.round(derived.physAtk.total);
      player.def = Math.round(derived.physDef.total);
      player.spd = Math.round(derived.speed.total);

      cachedSecondaries = derived;
      return derived;
    }

    function createEnemy(isBoss = false) {
      const base = game.floor * 5 + (isBoss ? 20 : 0);
      const enemy = {
        id: crypto.randomUUID(),
        name: isBoss ? `éšå±¤ãƒœã‚¹ ${game.floor}F` : `é›‘é­š ${game.floor}-${Math.ceil(Math.random() * 3)}`,
        hp: base + (isBoss ? 30 : 0),
        maxHp: base + (isBoss ? 30 : 0),
        atk: 5 + game.floor * 1.5 + (isBoss ? 4 : 0),
        def: 2 + game.floor * 0.5 + (isBoss ? 2 : 0),
        spd: 4 + Math.random() * 2 + (isBoss ? 1.5 : 0),
        isBoss,
        status: {},
      };
      return enemy;
    }

    function spawnEnemies() {
      const isBossFloor = game.floor % 5 === 0;
      const count = isBossFloor ? 1 : 2 + Math.floor(Math.random() * 2);
      game.enemies = Array.from({ length: count }, () => createEnemy(isBossFloor));
      log(`${game.floor}F ä¾µå…¥ã€‚${count}ä½“ã®æ•µãŒç¾ã‚ŒãŸï¼`);
      buildTurnQueue();
      updateUI();
      if (game.turnQueue[0]?.type === "player") {
        promptPlayerTurn();
      } else {
        nextTurn();
      }
    }

    function buildTurnQueue() {
      const queue = [];
      if (player.hp > 0) {
        queue.push({ type: "player", speed: player.spd + (player.buffs.haste ? 2 : 0) + Math.random() * 2 });
      }
      game.enemies.filter(e => e.hp > 0).forEach(e => {
        queue.push({ type: "enemy", id: e.id, speed: e.spd + Math.random() * 2 });
      });
      queue.sort((a, b) => b.speed - a.speed);
      game.turnQueue = queue;
    }

    function updateBars(id, current, max, cls) {
      const bar = document.getElementById(id);
      const percent = Math.max(0, Math.min(100, (current / max) * 100));
      bar.style.width = `${percent}%`;
      bar.className = cls;
    }

    function updateUI() {
      const derived = recalcDerivedStats();
      document.getElementById("floor-inline").textContent = game.floor;
      document.getElementById("hp-label").textContent = `HP ${Math.ceil(player.hp)} / ${derived.maxHp.total}`;
      document.getElementById("mp-label").textContent = `MP ${Math.ceil(player.mp)} / ${derived.maxMp.total}`;
      document.getElementById("exp-label").textContent = `EXP ${player.exp} / ${player.expToLevel}`;
      document.getElementById("level").textContent = player.level;
      document.getElementById("stat-points").textContent = player.statPoints;
      document.getElementById("skill-points").textContent = player.skillPoints;
      updateBars("hp-bar", player.hp, derived.maxHp.total, "hp");
      updateBars("mp-bar", player.mp, derived.maxMp.total, "mp");
      updateBars("exp-bar", player.exp, player.expToLevel, "exp");

      renderEnemies();
      renderActions();
      renderSecondaryStats(derived);
      renderPrimaryStats();
      renderSkills();
    }

    function renderEnemies() {
      const wrapper = document.getElementById("enemies");
      wrapper.innerHTML = "";
      game.enemies.forEach((enemy, index) => {
        const card = document.createElement("div");
        card.className = "enemy-card";
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", `${enemy.name} ã®è©³ç´°`);
        card.onclick = () => openEnemyModal(enemy);

        const top = document.createElement("div");
        top.className = "enemy-top";

        const name = document.createElement("div");
        name.className = "enemy-name";
        name.innerHTML = `<span>${enemy.isBoss ? "ğŸ‘‘" : "ğŸ‘¾"} ${enemy.name}</span><span class="subtle" style="gap: 4px;">#${index + 1}</span>`;

        top.appendChild(name);

        const bar = document.createElement("div");
        bar.className = "enemy-bar";
        const fill = document.createElement("span");
        fill.className = "fill";
        const hpPct = Math.max(0, Math.floor((enemy.hp / enemy.maxHp) * 100));
        fill.style.width = `${hpPct}%`;
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp} (${hpPct}%)`;
        bar.appendChild(fill);
        bar.appendChild(label);

        card.appendChild(top);
        card.appendChild(bar);
        wrapper.appendChild(card);
      });
    }

    function renderActions() {
      const container = document.getElementById("actions");
      container.innerHTML = "";
      const btn = document.createElement("button");
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      if (player.hp <= 0) {
        btn.textContent = "æˆ¦é—˜ä¸èƒ½";
        btn.disabled = true;
      } else if (!enemiesAlive) {
        btn.textContent = "æ¬¡ã®éšå±¤ã¸";
        btn.onclick = nextFloor;
      } else {
        btn.textContent = "âš”ï¸ ã“ã†ã’ã";
        btn.disabled = !game.awaitingInput;
        btn.onclick = playerAttack;
      }
      container.appendChild(btn);
    }

    function renderSecondaryStats(derived) {
      const container = document.getElementById("secondary-stats");
      container.innerHTML = "";
      const rows = [
        { label: "ç‰©ç†æ”»æ’ƒåŠ›", hint: "æ­¦å™¨ + åŠ› Ã— 1.2", value: derived.physAtk },
        { label: "é­”æ³•æ”»æ’ƒåŠ›", hint: "é­”å™¨ + çŸ¥è­˜ Ã— 1.3", value: derived.magAtk },
        { label: "ç‰©ç†é˜²å¾¡åŠ›", hint: "ä½“åŠ›Ã—0.6 + åŠ›Ã—0.2", value: derived.physDef },
        { label: "é­”æ³•é˜²å¾¡åŠ›", hint: "ä½“åŠ›Ã—0.5 + çŸ¥è­˜Ã—0.3", value: derived.magDef },
        { label: "æœ€å¤§HP", hint: "åŸºç¤ + ä½“åŠ› Ã— 10", value: derived.maxHp },
        { label: "æœ€å¤§MP", hint: "åŸºç¤ + çŸ¥è­˜ Ã—2", value: derived.maxMp },
        { label: "è¡Œå‹•é€Ÿåº¦", hint: "åŸºç¤ + æ•æ·", value: derived.speed },
        { label: "å‘½ä¸­ç‡", hint: "70% + æ•æ·Ã—0.1%", value: derived.accuracy, unit: "%" },
        { label: "ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡", hint: "(æ•æ·+é‹) æ¸›è¡°", value: derived.critRate, unit: "%" },
        { label: "å›é¿ç‡", hint: "(æ•æ·+é‹) æ¸›è¡°", value: derived.evade, unit: "%" },
      ];

      rows.forEach((row) => {
        const el = document.createElement("div");
        el.className = "stat-row";
        const left = document.createElement("div");
        left.className = "stat-label";
        left.innerHTML = `<span>${row.label}</span><span>${row.hint}</span>`;
        const right = document.createElement("div");
        right.className = "stat-value";
        const rendered = formatStatValue(row.value, row.unit || "");
        right.innerHTML = rendered;
        el.appendChild(left);
        el.appendChild(right);
        container.appendChild(el);
      });
    }

    function renderPrimaryStats() {
      const container = document.getElementById("primary-stats");
      container.innerHTML = "";
      primaryOrder.forEach((key) => {
        const stat = player.primary[key];
        const el = document.createElement("div");
        el.className = "stat-row";

        const left = document.createElement("div");
        left.className = "stat-label";
        left.innerHTML = `<span>${stat.label}</span><span>åˆè¨ˆ = ãƒ™ãƒ¼ã‚¹ + åŠ ç®—</span>`;

        const actions = document.createElement("div");
        actions.className = "stat-actions";
        const value = document.createElement("div");
        value.className = "stat-value";
        value.innerHTML = formatPrimaryValue(stat);
        const btn = document.createElement("button");
        btn.textContent = "+1";
        btn.disabled = player.statPoints <= 0;
        btn.onclick = () => {
          if (player.statPoints <= 0) return;
          player.statPoints -= 1;
          stat.base += 1;
          player.allocations[key] += 1;
          log(`èƒ½åŠ›Pã‚’ä½¿ç”¨: ${stat.label} +1`, "good");
          updateUI();
        };

        actions.appendChild(value);
        actions.appendChild(btn);

        el.appendChild(left);
        el.appendChild(actions);
        container.appendChild(el);
      });
    }

    function renderSkills() {
      const container = document.getElementById("skills");
      container.innerHTML = "";
      Object.entries(skills).forEach(([key, skill]) => {
        const row = document.createElement("div");
        row.style.marginBottom = "6px";
        const btn = document.createElement("button");
        btn.textContent = `${skill.name} (${skill.level}/${skill.max})`;
        btn.disabled = player.skillPoints <= 0 || skill.level >= skill.max;
        btn.onclick = () => {
          if (player.skillPoints <= 0 || skill.level >= skill.max) return;
          player.skillPoints -= 1;
          skill.level += 1;
          skill.apply();
          log(`ã‚¹ã‚­ãƒ«ã€${skill.name}ã€ã‚’å¼·åŒ– (${skill.level}/${skill.max})`, "good");
          updateUI();
        };
        const desc = document.createElement("div");
        desc.className = "subtle";
        desc.textContent = skill.desc;
        row.appendChild(btn);
        row.appendChild(desc);
        container.appendChild(row);
      });
    }

    const enemyModal = document.getElementById("enemy-modal");
    const playerModal = document.getElementById("player-modal");
    const skillsModal = document.getElementById("skills-modal");
    const closeModalButton = document.getElementById("modal-close");
    const playerModalCloseButton = document.getElementById("player-close");
    const skillsModalCloseButton = document.getElementById("skills-close");
    const statHelpButton = document.getElementById("stat-help");
    const statHelpPanel = document.getElementById("stat-help-panel");
    const resetButton = document.getElementById("reset-stats");

    function openEnemyModal(enemy) {
      document.getElementById("modal-name").textContent = enemy.name;
      document.getElementById("modal-hp").textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp}`;
      document.getElementById("modal-atk").textContent = Math.ceil(enemy.atk);
      document.getElementById("modal-def").textContent = Math.ceil(enemy.def);
      document.getElementById("modal-spd").textContent = enemy.spd.toFixed(1);
      document.getElementById("modal-tag").style.display = enemy.isBoss ? "inline-flex" : "none";
      enemyModal.classList.remove("hidden");
    }

    function closeEnemyModal() {
      enemyModal.classList.add("hidden");
    }

    function openPlayerModal() {
      updateUI();
      playerModal.classList.remove("hidden");
    }

    function closePlayerModal() {
      playerModal.classList.add("hidden");
    }

    function openSkillsModal() {
      updateUI();
      skillsModal.classList.remove("hidden");
    }

    function closeSkillsModal() {
      skillsModal.classList.add("hidden");
    }

    function promptPlayerTurn() {
      game.awaitingInput = true;
      renderActions();
    }

    function endPlayerTurn() {
      game.awaitingInput = false;
      renderActions();
      setTimeout(() => nextTurn(), 350);
    }

    function selectTarget() {
      return game.enemies.find(e => e.hp > 0);
    }

    function calcDamage(attacker, defender) {
      const variance = 0.85 + Math.random() * 0.3;
      const raw = Math.max(1, attacker.atk * variance - defender.def);
      return Math.max(1, Math.round(raw));
    }

    function playerAttack() {
      if (!game.awaitingInput) return;
      const target = selectTarget();
      if (!target) return;
      const dmg = calcDamage(player, target);
      target.hp = Math.max(0, target.hp - dmg);
      log(`âš”ï¸ ã‚ãªãŸã®æ”»æ’ƒï¼ ${target.name} ã« ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "player");
      updateUI();
      if (target.hp <= 0) {
        log(`${target.name} ã‚’å€’ã—ãŸï¼`, "good");
        checkVictory();
      }
      endPlayerTurn();
    }

    function powerStrike() {
      if (!game.awaitingInput) return;
      if (player.mp < 5) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 5;
      const target = selectTarget();
      if (!target) return;
      const dmg = Math.round(calcDamage(player, target) * 1.6 + (player.buffs.focus ? 6 : 0));
      target.hp = Math.max(0, target.hp - dmg);
      log(`ğŸŒŒ ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯ï¼ ${target.name} ã« ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "player");
      updateUI();
      if (target.hp <= 0) {
        log(`${target.name} ã‚’ç²‰ç •ï¼`, "good");
        checkVictory();
      }
      endPlayerTurn();
    }

    function heal() {
      if (!game.awaitingInput) return;
      if (player.mp < 4) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 4;
      const amount = Math.min(player.maxHp - player.hp, 12 + player.level * 1.5);
      player.hp += amount;
      log(`âœ¨ ãƒ’ãƒ¼ãƒ«ã§ ${Math.round(amount)} å›å¾©`, "good");
      endPlayerTurn();
    }

    function guard() {
      if (!game.awaitingInput) return;
      player.buffs.guard = 1;
      log("ğŸ›¡ï¸ é˜²å¾¡ä½“å‹¢ï¼ 1ã‚¿ãƒ¼ãƒ³è¢«ãƒ€ãƒ¡è»½æ¸›", "info");
      endPlayerTurn();
    }

    function enemyAction(enemy) {
      if (enemy.hp <= 0) return;
      let action = "attack";
      if (enemy.isBoss && Math.random() < 0.35) action = "heavy";
      if (enemy.isBoss && Math.random() < 0.15) action = "debuff";
      let dmg = 0;
      if (action === "attack") {
        dmg = calcDamage(enemy, player);
        if (player.buffs.guard) dmg = Math.round(dmg * 0.5);
        player.hp = Math.max(0, player.hp - dmg);
        log(`ğŸ‘¾ ${enemy.name} ã®æ”»æ’ƒã€‚${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "enemy");
      } else if (action === "heavy") {
        dmg = Math.round(calcDamage(enemy, player) * 1.4);
        player.hp = Math.max(0, player.hp - dmg);
        log(`ğŸ’¥ ${enemy.name} ã®å¼·æ’ƒï¼ ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "enemy");
      } else {
        player.def = Math.max(0, player.def - 1);
        log(`ğŸŒ€ ${enemy.name} ãŒå¼±ä½“å‘ªã„ã€‚é˜²å¾¡ãŒä¸‹ãŒã£ãŸ`, "warning");
      }
      if (player.hp <= 0) {
        handleDefeat();
      }
    }

    function handleDefeat() {
      const previousFloor = game.floor;
      game.floor = Math.max(1, game.floor - 20);
      player.hp = 0;
      game.awaitingInput = false;
      player.exp = Math.max(0, Math.floor(player.exp * 0.95));
      player.buffs.guard = 0;
      game.turnQueue = [];
      log(`ã‚ãªãŸã¯å€’ã‚ŒãŸâ€¦ ${previousFloor}F â†’ ${game.floor}F ã«å¾Œé€€ã€‚EXP -5%`, "danger");
      updateUI();
      setTimeout(() => {
        player.hp = player.maxHp;
        player.mp = player.maxMp;
        spawnEnemies();
        updateUI();
      }, 400);
    }

    function nextTurn() {
      if (player.hp <= 0) {
        game.awaitingInput = false;
        return;
      }
      if (game.enemies.every(e => e.hp <= 0)) return;
      if (game.turnQueue.length === 0) {
        player.buffs.guard = 0;
        buildTurnQueue();
      }
      const actor = game.turnQueue.shift();
      if (!actor) return;
      if (actor.type === "player") {
        promptPlayerTurn();
        return;
      }
      const enemy = game.enemies.find(e => e.id === actor.id);
      if (!enemy) {
        nextTurn();
        return;
      }
      enemyAction(enemy);
      updateUI();
      if (player.hp <= 0) return;
      setTimeout(() => nextTurn(), 380);
    }

    function checkVictory() {
      if (game.enemies.some(e => e.hp > 0)) return;
      const gained = 10 + game.floor * 3 + (game.floor % 5 === 0 ? 10 : 0);
      player.exp += gained;
      log(`ğŸ ${gained} EXP ã¨å°‘é‡ã®MPã‚’å¾—ãŸ`, "good");
      player.mp = Math.min(player.maxMp, player.mp + 3 + skills.arcaneFlow.level * 2);
      while (player.exp >= player.expToLevel) {
        player.exp -= player.expToLevel;
        levelUp();
      }
      game.awaitingInput = false;
      game.turnQueue = [];
      updateUI();
    }

    function levelUp() {
      player.level += 1;
      player.expToLevel = Math.round(player.expToLevel * 1.18);
      const growth = { str: 2, int: 2, vit: 3, agi: 2, luck: 1 };
      Object.entries(growth).forEach(([key, amount]) => {
        player.primary[key].base += amount;
      });
      recalcDerivedStats();
      player.hp = player.maxHp;
      player.mp = player.maxMp;
      player.statPoints += 2;
      player.skillPoints += 1;
      log(`â¬†ï¸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv${player.level} èƒ½åŠ›P+2 / ã‚¹ã‚­ãƒ«P+1`, "good");
    }

    function resetAllocations() {
      const spent = Object.values(player.allocations).reduce((a, b) => a + b, 0);
      if (spent === 0) {
        log("ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãƒã‚¤ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“", "info");
        return;
      }
      if (!confirm(`ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–ã—ã¦èƒ½åŠ›P${spent}ã‚’æˆ»ã—ã¾ã™ã‹ï¼Ÿ`)) return;
      Object.entries(player.allocations).forEach(([key, amount]) => {
        if (amount > 0) {
          player.primary[key].base -= amount;
          player.allocations[key] = 0;
        }
      });
      player.statPoints += spent;
      recalcDerivedStats();
      updateUI();
      log("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ", "info");
    }

    function nextFloor() {
      if (game.enemies.some(e => e.hp > 0) && player.hp > 0) {
        log("æ•µãŒæ®‹ã£ã¦ã„ã‚‹ï¼", "warning");
        return;
      }
      game.floor += 1;
      player.buffs.guard = 0;
      game.turnQueue = [];
      spawnEnemies();
      updateUI();
    }

    document.getElementById("btn-skill-tree").addEventListener("click", openSkillsModal);
    document.getElementById("btn-player-modal").addEventListener("click", openPlayerModal);
    closeModalButton.addEventListener("click", closeEnemyModal);
    playerModalCloseButton.addEventListener("click", closePlayerModal);
    skillsModalCloseButton.addEventListener("click", closeSkillsModal);
    statHelpButton.addEventListener("click", () => {
      const isHidden = statHelpPanel.style.display === "none";
      statHelpPanel.style.display = isHidden ? "block" : "none";
    });
    resetButton.addEventListener("click", resetAllocations);
    enemyModal.addEventListener("click", (e) => {
      if (e.target === enemyModal) closeEnemyModal();
    });
    playerModal.addEventListener("click", (e) => {
      if (e.target === playerModal) closePlayerModal();
    });
    skillsModal.addEventListener("click", (e) => {
      if (e.target === skillsModal) closeSkillsModal();
    });

    recalcDerivedStats();
    log("=== æŒ‘æˆ¦é–‹å§‹ ===", "info");
    spawnEnemies();
    updateUI();
  </script>
</body>
</html>
