<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç¸¦æŒã¡ãƒã‚¯ã‚¹ãƒ©è©¦ä½œ</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #111827;
      --accent: #34d399;
      --accent-2: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(circle at 20% 20%, rgba(52, 211, 153, 0.08), transparent 25%),
        radial-gradient(circle at 80% 10%, rgba(96, 165, 250, 0.08), transparent 22%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", "Hiragino Sans", system-ui, -apple-system, sans-serif;
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      padding: 6px;
    }

    .phone {
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      width: min(460px, 100%);
      height: calc(90vh - 12px);
      display: grid;
      grid-template-rows: auto auto 1fr auto auto 1fr;
      gap: 4px;
      padding: 6px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 4px;
    }

    .subtle {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .bars {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 22px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .bar span {
      position: absolute;
      inset: 0;
      width: 50%;
      border-radius: 999px;
    }

    .bar .label {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .bar .hp {
      background: #ef4444;
    }

    .bar .mp {
      background: #3b82f6;
    }

    .bar .exp {
      background: #facc15;
    }

    #log {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.5;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      height: 40vh;                /* å›ºå®šé«˜ã•ã‚’ã‚„ã‚ã‚‹ */
      /*min-height: 1000px;           /* æœ€ä½ã“ã‚Œãã‚‰ã„ã®é«˜ã•ã¯æ¬²ã—ã„ */
      max-height: 40vh;            /* ä¼¸ã³ã¦ã‚‚ç”»é¢ã® 40% ã¾ã§ */
    }

    .log-card {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #log .entry {
      opacity: 0.95;
      padding: 4px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
    }

    #log .entry.info {
      color: #e5e7eb;
    }

    #log .entry.player {
      color: #93c5fd;
    }

    #log .entry.enemy {
      color: #fca5a5;
    }

    #log .entry.good {
      color: #6ee7b7;
    }

    #log .entry.warning {
      color: #fcd34d;
    }

    #log .entry.danger {
      color: #fb7185;
    }

    #actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    button {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.2), rgba(96, 165, 250, 0.2));
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu {
      display: flex;
      justify-content: space-around;
      gap: 6px;
    }

    .pill {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.06);
      padding: 4px 8px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .tag {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      letter-spacing: 0.03em;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
    }

    .inline-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 5px;
      margin-top: 2px;
    }

    .primary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-top: 4px;
      align-items: start;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      padding: 5px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      display: grid;
      gap: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .stat-label.secondary {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      white-space: nowrap;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .stat-value {
      font-weight: 700;
      font-size: 13px;
      text-align: right;
    }

    .stat-value .total {
      font-weight: 800;
    }

    .stat-value .base {
      color: var(--muted);
      font-weight: 600;
    }

    .stat-value .bonus {
      color: var(--accent);
      font-weight: 800;
    }

    .stat-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .primary-row {
      align-items: center;
    }

    .primary-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      min-width: 0;
    }

    .primary-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      align-items: center;
    }

    .primary-actions .mini-btn {
      padding: 6px 10px;
      font-size: 12px;
      min-width: 50px;
    }

    .stat-label.inline {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .step-button {
      min-width: 78px;
      padding: 8px 10px;
      font-size: 12px;
    }

    .enemy-list {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
      padding-bottom: 2px;
    }

    .enemy-card {
      display: grid;
      gap: 6px;
      padding: 9px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.08s ease, border-color 0.12s ease, box-shadow 0.12s ease;
      min-width: 0;
    }

    .enemy-card:active {
      transform: translateY(1px);
    }

    .enemy-card:hover {
      border-color: rgba(255, 255, 255, 0.16);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }

    .enemy-top {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .enemy-name {
      display: grid;
      gap: 2px;
      font-weight: 600;
    }
    .status-icons {
      display: inline-flex;
      gap: 4px;
      flex-wrap: wrap;
      align-items: center;
    }

    .status-icon {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 10px;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.12s ease, border-color 0.12s ease;
    }

    .status-icon:hover {
      background: rgba(96, 165, 250, 0.16);
      border-color: rgba(96, 165, 250, 0.3);
    }

    .status-popup {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 60;
    }

    .status-popup.active {
      display: grid;
    }

    .status-popup .modal-content {
      width: min(420px, 94%);
    }

    .enemy-bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .enemy-bar .fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ef4444, #f87171);
      width: 50%;
      border-radius: 999px;
    }

    .enemy-bar .label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      line-height: 1;
    }

    .help-panel ul {
      padding-left: 16px;
      margin: 6px 0;
    }

    .modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      border-radius: 999px;
      width: 30px;
      height: 30px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <div class="phone">
    <section class="card">
      <div id="enemies" class="enemy-list"></div>
    </section>

      <section class="card">
        <div class="subtle" style="justify-content: flex-start; gap: 10px; margin-bottom: 4px;">
          <span>LV <span id="level"></span></span>
          <span class="pill">éšå±¤ <span id="floor-inline"></span>F</span>
          <div id="player-status-icons" class="status-icons" aria-label="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ç•°å¸¸"></div>
        </div>
        <div class="bars">
          <div class="bar">
            <span id="hp-bar" class="hp"></span>
            <span id="hp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="mp-bar" class="mp"></span>
          <span id="mp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="exp-bar" class="exp"></span>
          <span id="exp-label" class="label"></span>
        </div>
      </div>
    </section>

    <section class="card log-card">
      <div id="log"></div>
    </section>

    <section class="card">
      <div id="actions"></div>
    </section>

    <nav class="menu">
      <button id="btn-player-modal">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è©³ç´°</button>
      <button id="btn-skill-tree">ã‚¹ã‚­ãƒ«</button>
    </nav>
  </div>
        <ul>
          <li>ç•°å¸¸æŠµæŠ— / ä½ä¸‹æŠµæŠ— / å‘ªã„æŠµæŠ— = ä½“åŠ›ï¼‹å„ç¨®ã‚¹ãƒ†ç”±æ¥ (ä¸Šé™60%)</li>
          <li>HPå†ç”Ÿ = ä½“åŠ› Ã— 0.2 / ã‚¿ãƒ¼ãƒ³</li>
          <li>HPå¸å = ä¸ãƒ€ãƒ¡ Ã— å¸å%</li>
          <li>ãƒãƒªã‚¢ = ä½“åŠ›Ã—2 + çŸ¥è­˜Ã—1</li>
          <li>ãƒ‰ãƒ­ãƒƒãƒ—ç‡UP / ãƒ¬ã‚¢ãƒªãƒ†ã‚£UP = é‹ã«ã‚ˆã‚‹æ¸›è¡°å¼ (ä¸Šé™ã‚ã‚Š)</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="reset-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ</div>
        <button id="reset-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div>æŒ¯ã‚Šåˆ†ã‘ãŸãƒã‚¤ãƒ³ãƒˆ(<span id="reset-spent"></span>P)ã‚’æˆ»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ</div>
      <div class="modal-actions">
        <button id="reset-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="reset-confirm">ãƒªã‚»ãƒƒãƒˆã™ã‚‹</button>
      </div>
    </div>
  </div>

    <div id="skills-modal" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0;">ã‚¹ã‚­ãƒ« / ãƒ‘ãƒ¼ã‚¯</div>
          <div style="font-weight: 700;">ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚’æ¶ˆè²»ã—ã¦å¼·åŒ–</div>
        </div>
        <button id="skills-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
        <div class="inline-buttons" style="margin-bottom: 6px;">
          <div class="pill">ã‚¹ã‚­ãƒ«P: <span id="skill-points-skill"></span></div>
        </div>
        <div id="skills" style="margin-top: 6px;"></div>
      </div>
    </div>

    <div id="status-popup" class="status-popup" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="section-title" style="margin: 0;">çŠ¶æ…‹ç•°å¸¸</div>
            <div id="status-popup-target" style="font-weight: 700;"></div>
          </div>
          <button id="status-popup-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
        </div>
        <div id="status-popup-body" class="help-panel"></div>
      </div>
    </div>

    <script>
    const player = {
      name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
      level: 1,
      exp: 0,
      expToLevel: 20,
      hp: 0,
      mp: 0,
      maxHp: 0,
      maxMp: 0,
      atk: 0,
      def: 0,
      spd: 0,
      base: {
        hp: 80,
        mp: 30,
        physAtk: 10,
        magAtk: 8,
        physDef: 4,
        magDef: 4,
        speed: 4,
      },
      primary: {
        str: { label: "åŠ›", base: 1, bonus: 0 },
        int: { label: "çŸ¥è­˜", base: 1, bonus: 0 },
        vit: { label: "ä½“åŠ›", base: 1, bonus: 0 },
        agi: { label: "æ•æ·", base: 1, bonus: 0 },
        luck: { label: "é‹", base: 1, bonus: 0 },
      },
      allocations: {
        str: 0,
        int: 0,
        vit: 0,
        agi: 0,
      luck: 0,
    },
    bonus: {
      hp: 0,
      mp: 0,
        physAtk: 0,
        magAtk: 0,
        physDef: 0,
        magDef: 0,
        speed: 0,
        critRate: 0,
        critDamage: 0,
        evade: 0,
        physPen: 0,
        magPen: 0,
        damageReduction: 0,
        block: 0,
        statusResist: 0,
        debuffResist: 0,
        curseResist: 0,
        cooldown: 0,
        hpRegen: 0,
        lifeSteal: 0,
        barrier: 0,
      dropRate: 0,
      rarity: 0,
    },
    statPoints: 3,
    skillPoints: 0,
    buffs: { guard: 0, haste: 0, focus: 0 },
    statuses: [],
    resistances: { control: 0, dot: 0, debuff: 0 },
  };

    const statusLibrary = {
      stun: {
        name: "ã‚¹ã‚¿ãƒ³",
        short: "St",
        category: "control",
        description: "è¡Œå‹•å®Œå…¨ä¸èƒ½ï¼ˆé€šå¸¸æ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«ä¸å¯ï¼‰",
      },
      sleep: {
        name: "ç¡çœ ",
        short: "Sl",
        category: "control",
        description: "è¡Œå‹•ä¸èƒ½ã€‚è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã§è§£é™¤ï¼ˆDoTã§ã¯è§£é™¤ã•ã‚Œãªã„ï¼‰",
        breakOnHit: true,
      },
      confusion: {
        name: "æ··ä¹±",
        short: "Cn",
        category: "control",
        description: "æ”»æ’ƒå¯¾è±¡ãŒãƒ©ãƒ³ãƒ€ãƒ åŒ–ã€‚å‘³æ–¹ã‚’æ”»æ’ƒã™ã‚‹å¯èƒ½æ€§ã‚‚",
      },
      silence: {
        name: "æ²ˆé»™",
        short: "Si",
        category: "control",
        description: "ã‚¹ã‚­ãƒ«ä½¿ç”¨ä¸å¯ï¼ˆé€šå¸¸æ”»æ’ƒã®ã¿å¯èƒ½ï¼‰",
      },
      knockdown: {
        name: "è»¢å€’",
        short: "Kd",
        category: "control",
        description: "æ¬¡ã‚¿ãƒ¼ãƒ³ã®è¡Œå‹•é †ãŒæœ€å¾Œã«ãªã‚‹ï¼ˆè¡Œå‹•é…å»¶ï¼‰",
      },
      seal: {
        name: "å°å°",
        short: "Se",
        category: "control",
        description: "ãƒ‘ãƒƒã‚·ãƒ–ã‚„å¸¸æ™‚åŠ¹æœã‚’ç„¡åŠ¹åŒ–",
      },
      bleed: {
        name: "å‡ºè¡€",
        short: "Bl",
        category: "dot",
        description: "ç‰©ç†DoTï¼ˆé˜²å¾¡ç„¡è¦–ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰",
        tick: (target) => Math.max(2, Math.round(target.maxHp * 0.05)),
      },
      poison: {
        name: "æ¯’",
        short: "Po",
        category: "dot",
        description: "æœ€å¤§HPå‰²åˆã®æŒç¶šãƒ€ãƒ¡ãƒ¼ã‚¸",
        tick: (target) => Math.max(2, Math.round(target.maxHp * 0.04)),
      },
      curse: {
        name: "å‘ªã„",
        short: "Cu",
        category: "dot",
        description: "ä¸ãƒ€ãƒ¡ä½ä¸‹ï¼‹å°DoT",
        tick: () => 3,
        damagePenalty: 0.85,
      },
      burn: {
        name: "ç«å‚·",
        short: "Bu",
        category: "dot",
        description: "é­”æ³•ç³»DoTã¨ã—ã¦æ‰±ã†",
        tick: (target) => Math.max(2, Math.round(target.maxHp * 0.03)),
      },
      physAtkDown: {
        name: "ç‰©ç†æ”»æ’ƒãƒ€ã‚¦ãƒ³",
        short: "P-",
        category: "debuff",
        description: "ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸ä¿‚æ•°ãƒ€ã‚¦ãƒ³",
        damagePenalty: 0.8,
      },
      magAtkDown: {
        name: "é­”æ³•æ”»æ’ƒãƒ€ã‚¦ãƒ³",
        short: "M-",
        category: "debuff",
        description: "é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸ä¿‚æ•°ãƒ€ã‚¦ãƒ³",
        damagePenalty: 0.8,
      },
      physDefDown: {
        name: "ç‰©ç†é˜²å¾¡ãƒ€ã‚¦ãƒ³",
        short: "PD",
        category: "debuff",
        description: "å—ã‘ã‚‹ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ",
        defensePenalty: 0.85,
      },
      magDefDown: {
        name: "é­”æ³•é˜²å¾¡ãƒ€ã‚¦ãƒ³",
        short: "MD",
        category: "debuff",
        description: "å—ã‘ã‚‹é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ",
        defensePenalty: 0.85,
      },
      accuracyDown: {
        name: "å‘½ä¸­ç‡ãƒ€ã‚¦ãƒ³",
        short: "Ac",
        category: "debuff",
        description: "æ”»æ’ƒãŒå½“ãŸã‚Šã«ãããªã‚‹",
      },
      evasionDown: {
        name: "å›é¿ç‡ãƒ€ã‚¦ãƒ³",
        short: "Ev",
        category: "debuff",
        description: "æ”»æ’ƒãŒå½“ãŸã‚Šã‚„ã™ããªã‚‹",
      },
      speedDown: {
        name: "é€Ÿåº¦ãƒ€ã‚¦ãƒ³",
        short: "Sp",
        category: "debuff",
        description: "è¡Œå‹•é †ãŒé…ããªã‚‹ï¼è¡Œå‹•é »åº¦æ¸›å°‘",
        speedPenalty: -1,
      },
    };

    const game = {
      floor: 1,
      enemies: [],
      turnQueue: [],
      awaitingInput: false,
      defeatedBosses: 0,
    };

    const skills = {
      sharpEdge: {
        name: "é‹­åˆƒ",
        desc: "ç‰©ç†æ”»æ’ƒ+2 (æœ€å¤§3)",
        level: 0,
        max: 3,
        apply: () => (player.bonus.physAtk += 2),
      },
      quickStep: {
        name: "ç–¾é§†",
        desc: "é€Ÿåº¦+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.speed += 2),
      },
      arcaneFlow: {
        name: "é­”åŠ›å¾ªç’°",
        desc: "æœ€å¤§MP+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.mp += 2),
      },
    };

    function log(message, type = "info") {
      const logBox = document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `entry ${type}`;
      entry.textContent = message;
      logBox.appendChild(entry);
      logBox.scrollTop = logBox.scrollHeight;
    }

    function getResistance(entity, category) {
      const value = entity.resistances?.[category] || 0;
      return Math.min(0.8, Math.max(0, value));
    }

    function applyStatus(target, key, duration = 2, baseChance = 1) {
      const def = statusLibrary[key];
      if (!def) return false;
      const resist = getResistance(target, def.category);
      const success = Math.random() < baseChance * (1 - resist);
      if (!success) {
        log(`${target.name} ã¯${def.name}ã‚’æŠµæŠ—ã—ãŸ`, "info");
        return false;
      }
      const existing = target.statuses.find((s) => s.key === key);
      if (existing) {
        existing.duration = Math.max(existing.duration, duration);
        return true;
      }
      target.statuses.push({ key, duration });
      return true;
    }

    function removeStatus(target, key) {
      target.statuses = target.statuses.filter((s) => s.key !== key);
    }

    function hasStatus(target, key) {
      return target.statuses.some((s) => s.key === key);
    }

    function summarizeStatuses(entity) {
      return entity.statuses.map((s) => {
        const def = statusLibrary[s.key];
        return {
          key: s.key,
          duration: s.duration,
          label: def?.short || s.key,
          name: def?.name || s.key,
          description: def?.description || "",
        };
      });
    }

    function createStatusIconsElement(owner, ownerName) {
      const wrapper = document.createElement("div");
      wrapper.className = "status-icons";
      const statuses = summarizeStatuses(owner);
      if (!statuses.length) {
        const empty = document.createElement("span");
        empty.className = "subtle";
        empty.textContent = "-";
        wrapper.appendChild(empty);
        return wrapper;
      }
      statuses.forEach((status) => {
        const badge = document.createElement("span");
        badge.className = "status-icon";
        badge.textContent = status.label;
        badge.title = `${status.name} (${status.duration}T)`;
        badge.onclick = (e) => {
          e.stopPropagation();
          handleStatusPopup(ownerName, status);
        };
        wrapper.appendChild(badge);
      });
      return wrapper;
    }

    function tickStatuses(entity, { atTurnEnd = false } = {}) {
      if (!entity.statuses.length) return;
      entity.statuses = entity.statuses
        .map((s) => ({ ...s, duration: atTurnEnd ? s.duration - 1 : s.duration }))
        .filter((s) => s.duration > 0);
    }

    function processDots(entity, actorLabel) {
      const dots = entity.statuses.filter((s) => statusLibrary[s.key]?.category === "dot");
      dots.forEach((s) => {
        const def = statusLibrary[s.key];
        if (!def?.tick) return;
        const damage = def.tick(entity);
        entity.hp = Math.max(0, entity.hp - damage);
        log(`â˜ ï¸ ${actorLabel}ã¯${def.name}ã§ ${damage} ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ (æ®‹ã‚Š${s.duration}T)`, "warning");
      });
    }

    function getDamagePenalty(attacker) {
      const modifiers = attacker.statuses
        .map((s) => statusLibrary[s.key])
        .filter((def) => def?.damagePenalty)
        .map((def) => def.damagePenalty);
      if (!modifiers.length) return 1;
      return modifiers.reduce((acc, cur) => acc * cur, 1);
    }

    function getDefensePenalty(defender) {
      const modifiers = defender.statuses
        .map((s) => statusLibrary[s.key])
        .filter((def) => def?.defensePenalty)
        .map((def) => def.defensePenalty);
      if (!modifiers.length) return 1;
      return modifiers.reduce((acc, cur) => acc * cur, 1);
    }

    function handleStatusPopup(ownerName, status) {
      const popup = document.getElementById("status-popup");
      const body = document.getElementById("status-popup-body");
      const target = document.getElementById("status-popup-target");
      target.textContent = ownerName;
      body.innerHTML = `<div style="font-weight:700;">${status.name} (${status.duration}ã‚¿ãƒ¼ãƒ³)</div><div style="margin-top:4px;">${status.description}</div>`;
      popup.classList.add("active");
    }

    const primaryOrder = ["str", "int", "vit", "agi", "luck"];
    const stepOptions = [1, 10, 100];
    let currentStepIndex = 0;
    let pendingResetSpent = 0;

    const displayNumber = (num, { isPercent = false } = {}) => {
      if (isPercent) {
        return (Math.round(num * 10) / 10).toFixed(1);
      }
      return Math.round(num);
    };

    function formatStatValue(value, unit = "") {
      const isPercent = unit === "%";
      const total = displayNumber(value, { isPercent });
      if (isPercent) {
        return `<span class="total">${total}${unit}</span>`;
      }
      return `<span class="total">${total}</span>`;
    }

    const formatPrimaryValue = (stat) => {
      const total = stat.base + stat.bonus;
      if (!stat.bonus) return `<span class="total">${total}</span>`;
      const bonusSign = stat.bonus > 0 ? "+" : "";
      const derived = calcSecondaryStats();
      const prevMaxHp = player.maxHp || derived.maxHp.total;
      const prevMaxMp = player.maxMp || derived.maxMp.total;

      if (player.maxHp === 0) {
        player.hp = derived.maxHp.total;
      } else {
        const hpDelta = derived.maxHp.total - prevMaxHp;
        if (hpDelta > 0) player.hp += hpDelta;
        if (player.hp > derived.maxHp.total) player.hp = derived.maxHp.total;
      }

      if (player.maxMp === 0) {
        player.mp = derived.maxMp.total;
      } else {
        const mpDelta = derived.maxMp.total - prevMaxMp;
        if (mpDelta > 0) player.mp += mpDelta;
        if (player.mp > derived.maxMp.total) player.mp = derived.maxMp.total;
      }

      player.maxHp = Math.round(derived.maxHp.total);
      player.maxMp = Math.round(derived.maxMp.total);
      player.atk = Math.round(derived.physAtk.total);
      player.def = Math.round(derived.physDef.total);
      player.spd = Math.round(derived.speed.total);
      player.resistances = {
        control: derived.statusResist.total / 100,
        dot: derived.curseResist.total / 100,
        debuff: derived.debuffResist.total / 100,
      };

      return derived;
    }

    function createEnemy(isBoss = false) {
      const base = game.floor * 5 + (isBoss ? 20 : 0);
        const enemy = {
          id: crypto.randomUUID(),
          name: isBoss ? `éšå±¤ãƒœã‚¹ ${game.floor}F` : `é›‘é­š ${game.floor}-${Math.ceil(Math.random() * 3)}`,
          hp: base + (isBoss ? 30 : 0),
          maxHp: base + (isBoss ? 30 : 0),
          atk: 5 + game.floor * 1.5 + (isBoss ? 4 : 0),
          def: 2 + game.floor * 0.5 + (isBoss ? 2 : 0),
          spd: 4 + Math.random() * 2 + (isBoss ? 1.5 : 0),
          isBoss,
          statuses: [],
          resistances: {
            control: Math.min(0.35, 0.08 + game.floor * 0.01 + (isBoss ? 0.1 : 0)),
            dot: Math.min(0.35, 0.06 + game.floor * 0.01),
            debuff: Math.min(0.35, 0.05 + game.floor * 0.01),
          },
        };
        return enemy;
      }

      function spawnEnemies() {
        const isBossFloor = game.floor % 5 === 0;
        const count = isBossFloor ? 1 : 2 + Math.floor(Math.random() * 2);
        game.enemies = Array.from({ length: count }, () => createEnemy(isBossFloor));
        log(`${game.floor}F ä¾µå…¥ã€‚${count}ä½“ã®æ•µãŒç¾ã‚ŒãŸï¼`);
        buildTurnQueue();
        updateUI();
        if (game.turnQueue[0]?.type === "player") {
          promptPlayerTurn();
        } else {
          nextTurn();
        }
      }

      function calcTurnSpeed(entity, isPlayer = false) {
        const speedDebuff = entity.statuses
          .map((s) => statusLibrary[s.key]?.speedPenalty || 0)
          .reduce((a, b) => a + b, 0);
        const knockdownPenalty = hasStatus(entity, "knockdown") ? -2 : 0;
        const hasteBonus = isPlayer && player.buffs.haste ? 2 : 0;
        return Math.max(1, entity.spd + hasteBonus + speedDebuff + knockdownPenalty + Math.random() * 2);
      }

      function buildTurnQueue() {
        const queue = [];
        if (player.hp > 0) {
          queue.push({ type: "player", speed: calcTurnSpeed(player, true) });
        }
        game.enemies.filter(e => e.hp > 0).forEach(e => {
          queue.push({ type: "enemy", id: e.id, speed: calcTurnSpeed(e) });
        });
        queue.sort((a, b) => b.speed - a.speed);
        game.turnQueue = queue;
      }

    function updateBars(id, current, max, cls) {
      const bar = document.getElementById(id);
      const percent = Math.max(0, Math.min(100, (current / max) * 100));
      bar.style.width = `${percent}%`;
      bar.className = cls;
    }

    function updateUI() {
      const derived = recalcDerivedStats();
      updateStepButton();
      document.getElementById("floor-inline").textContent = game.floor;
      document.getElementById("hp-label").textContent = `HP ${Math.ceil(player.hp)} / ${derived.maxHp.total}`;
        document.getElementById("mp-label").textContent = `MP ${Math.ceil(player.mp)} / ${derived.maxMp.total}`;
        document.getElementById("exp-label").textContent = `EXP ${player.exp} / ${player.expToLevel}`;
        document.getElementById("level").textContent = player.level;
        document.getElementById("stat-points").textContent = player.statPoints;
        document.getElementById("skill-points-skill").textContent = player.skillPoints;
        updateBars("hp-bar", player.hp, derived.maxHp.total, "hp");
        updateBars("mp-bar", player.mp, derived.maxMp.total, "mp");
        updateBars("exp-bar", player.exp, player.expToLevel, "exp");

        renderEnemies();
        renderPlayerStatuses();
        renderActions();
        renderSecondaryStats(derived);
        renderPrimaryStats();
        renderSkills();
      }

      function renderPlayerStatuses() {
        const container = document.getElementById("player-status-icons");
        container.innerHTML = "";
        container.appendChild(createStatusIconsElement(player, "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼"));
      }

    function renderEnemies() {
      const wrapper = document.getElementById("enemies");
      wrapper.innerHTML = "";
      game.enemies.forEach((enemy, index) => {
        const card = document.createElement("div");
        card.className = "enemy-card";
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", `${enemy.name} ã®è©³ç´°`);
        card.onclick = () => openEnemyModal(enemy);

        const top = document.createElement("div");
        top.className = "enemy-top";

          const name = document.createElement("div");
          name.className = "enemy-name";
          name.innerHTML = `<span>${enemy.isBoss ? "ğŸ‘‘" : "ğŸ‘¾"} ${enemy.name}</span><span class="subtle" style="gap: 4px;">#${index + 1}</span>`;

          top.appendChild(name);

          const right = document.createElement("div");
          right.style.display = "grid";
          right.style.gap = "4px";
          right.style.justifyItems = "end";

          const tag = document.createElement("div");
          tag.className = "pill";
          tag.style.display = enemy.isBoss ? "inline-flex" : "none";
          tag.textContent = "BOSS";
          right.appendChild(tag);

          const statusRow = createStatusIconsElement(enemy, `${enemy.name} #${index + 1}`);
          right.appendChild(statusRow);

          top.appendChild(right);

        const bar = document.createElement("div");
        bar.className = "enemy-bar";
        const fill = document.createElement("span");
        fill.className = "fill";
        const hpPct = Math.max(0, Math.floor((enemy.hp / enemy.maxHp) * 100));
        fill.style.width = `${hpPct}%`;
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp} (${hpPct}%)`;
        bar.appendChild(fill);
        bar.appendChild(label);

        card.appendChild(top);
        card.appendChild(bar);
        wrapper.appendChild(card);
      });
    }

    function renderActions() {
      const container = document.getElementById("actions");
      container.innerHTML = "";
      const btn = document.createElement("button");
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      if (player.hp <= 0) {
      enemyModal.classList.remove("hidden");
    }

    function closeEnemyModal() {
      enemyModal.classList.add("hidden");
    }

    function openPlayerModal() {
      updateUI();
      playerModal.classList.remove("hidden");
    }

    function closePlayerModal() {
      playerModal.classList.add("hidden");
    }

    function openSkillsModal() {
      updateUI();
      skillsModal.classList.remove("hidden");
    }

    function closeSkillsModal() {
      skillsModal.classList.add("hidden");
    }

      function promptPlayerTurn() {
        game.awaitingInput = true;
        renderActions();
      }

      function endPlayerTurn() {
        tickStatuses(player, { atTurnEnd: true });
        game.awaitingInput = false;
        renderActions();
        setTimeout(() => nextTurn(), 350);
      }

      function selectTarget(attacker) {
        const aliveEnemies = game.enemies.filter(e => e.hp > 0);
        if (!aliveEnemies.length) return null;
        if (attacker && hasStatus(attacker, "confusion")) {
          const attackSelf = Math.random() < 0.35;
          if (attackSelf) return attacker;
          return aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
        }
        return aliveEnemies[0];
      }

      function calcDamage(attacker, defender) {
        const variance = 0.85 + Math.random() * 0.3;
        const damagePenalty = getDamagePenalty(attacker);
        const defensePenalty = getDefensePenalty(defender);
        const raw = Math.max(1, attacker.atk * variance * damagePenalty - defender.def * defensePenalty);
        return Math.max(1, Math.round(raw));
      }

      function handleDamageTaken(target, amount) {
        if (amount <= 0) return;
        const sleepStatus = target.statuses.find((s) => statusLibrary[s.key]?.breakOnHit);
        if (sleepStatus) {
          removeStatus(target, sleepStatus.key);
          log(`${target.name} ã®${statusLibrary[sleepStatus.key].name}ãŒè§£é™¤ã•ã‚ŒãŸ`, "info");
        }
      }

      function startTurn(entity) {
        processDots(entity, entity.name);
        if (entity.hp <= 0) return false;
        if (hasStatus(entity, "stun")) {
          log(`${entity.name} ã¯ã‚¹ã‚¿ãƒ³ã—ã¦ã„ã‚‹ï¼`, "warning");
          tickStatuses(entity, { atTurnEnd: true });
          return false;
        }
        if (hasStatus(entity, "sleep")) {
          log(`${entity.name} ã¯çœ ã£ã¦ã„ã‚‹â€¦`, "warning");
          tickStatuses(entity, { atTurnEnd: true });
          return false;
        }
        return true;
      }

      function playerAttack() {
        if (!game.awaitingInput) return;
        const target = selectTarget(player);
        if (!target) return;
        const dmg = calcDamage(player, target);
        target.hp = Math.max(0, target.hp - dmg);
        handleDamageTaken(target, dmg);
        log(`âš”ï¸ ã‚ãªãŸã®æ”»æ’ƒï¼ ${target.name} ã« ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "player");
        if (target !== player && Math.random() < 0.25) {
          if (applyStatus(target, "bleed", 3, 1)) {
            log(`${target.name} ã«å‡ºè¡€ã‚’ä»˜ä¸`, "good");
          }
        }
        updateUI();
        if (target.hp <= 0) {
          log(`${target.name} ã‚’å€’ã—ãŸï¼`, "good");
          checkVictory();
        }
      endPlayerTurn();
    }

    function powerStrike() {
      if (!game.awaitingInput) return;
      if (player.mp < 5) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
        player.mp -= 5;
        const target = selectTarget(player);
        if (!target) return;
        const dmg = Math.round(calcDamage(player, target) * 1.6 + (player.buffs.focus ? 6 : 0));
        target.hp = Math.max(0, target.hp - dmg);
        handleDamageTaken(target, dmg);
        log(`ğŸŒŒ ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯ï¼ ${target.name} ã« ${dmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "player");
        if (target !== player && Math.random() < 0.35) {
          if (applyStatus(target, "stun", 1, 1)) {
            log(`${target.name} ã‚’ã‚¹ã‚¿ãƒ³ã•ã›ãŸï¼`, "good");
          }
        }
        updateUI();
        if (target.hp <= 0) {
          log(`${target.name} ã‚’ç²‰ç •ï¼`, "good");
          checkVictory();
        }
      endPlayerTurn();
    }

    function heal() {
      if (!game.awaitingInput) return;
      if (player.mp < 4) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 4;
      const healAmount = Math.max(6, Math.round(player.maxHp * 0.12 + (player.buffs.focus ? 5 : 0)));
      player.hp = Math.min(player.maxHp, player.hp + healAmount);
      log(`âœ¨ ãƒ’ãƒ¼ãƒ«ï¼ HPãŒ ${healAmount} å›å¾©`, "good");
      updateUI();
      endPlayerTurn();
    }

    function guard() {
      if (!game.awaitingInput) return;
      if (player.mp < 2) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 2;
      player.buffs.guard = 2;
      if (!game.awaitingInput) return;
      if (player.mp < 2) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 2;
      player.buffs.haste = 2;
      log("ğŸ’¨ ãƒ–ãƒ¼ã‚¹ãƒˆï¼ æ¬¡ã®2ã‚¿ãƒ¼ãƒ³è¡Œå‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—", "good");
      updateUI();
      endPlayerTurn();
    }

    function focus() {
      if (!game.awaitingInput) return;
      if (player.mp < 3) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 3;
      player.buffs.focus = 2;
      log("ğŸ¯ ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼ ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ã‚¢ãƒƒãƒ—", "good");
      updateUI();
      endPlayerTurn();
    }

      function enemyAction(enemy) {
        if (enemy.hp <= 0) return;
        const dmg = calcDamage(enemy, player);
        const isCrit = Math.random() < 0.12;
        const finalDmg = isCrit ? Math.round(dmg * 1.4) : dmg;
        player.hp = Math.max(0, player.hp - finalDmg);
        const critText = isCrit ? " (ä¼šå¿ƒï¼)" : "";
        log(`â˜ ï¸ ${enemy.name} ã®æ”»æ’ƒ${critText}ï¼ ${finalDmg} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "enemy");
        handleDamageTaken(player, finalDmg);
        if (Math.random() < 0.2) {
          if (applyStatus(player, "poison", 2, 1)) {
            log(`â˜ ï¸ ${enemy.name} ã¯æ¯’ã‚’ã°ã‚‰ã¾ã„ãŸ`, "danger");
          }
        }
      }

    function updateUIAfterEnemy() {
      updateUI();
      if (player.hp <= 0) return;
      setTimeout(() => nextTurn(), 380);
    }

      function nextTurn() {
        if (player.hp <= 0) {
          log("ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼", "danger");
          return;
        }
        if (game.turnQueue.length === 0) {
          buildTurnQueue();
        }
        const actor = game.turnQueue.shift();
        if (!actor) return;
        if (actor.type === "player") {
          if (!startTurn(player)) {
            updateUI();
            setTimeout(() => nextTurn(), 350);
            return;
          }
          promptPlayerTurn();
          return;
        }
        const enemy = game.enemies.find(e => e.id === actor.id);
        if (!enemy) {
          nextTurn();
          return;
        }
        if (!startTurn(enemy)) {
          updateUIAfterEnemy();
          return;
        }
        enemyAction(enemy);
        tickStatuses(enemy, { atTurnEnd: true });
        updateUI();
        if (player.hp <= 0) return;
        setTimeout(() => nextTurn(), 380);
      }

    function checkVictory() {
      if (game.enemies.some(e => e.hp > 0)) return;
      const gained = 10 + game.floor * 3 + (game.floor % 5 === 0 ? 10 : 0);
      player.exp += gained;
      log(`ğŸ ${gained} EXP ã¨å°‘é‡ã®MPã‚’å¾—ãŸ`, "good");
      player.mp = Math.min(player.maxMp, player.mp + 3 + skills.arcaneFlow.level * 2);
      while (player.exp >= player.expToLevel) {
        player.exp -= player.expToLevel;
        levelUp();
      }
      game.awaitingInput = false;
      game.turnQueue = [];
      updateUI();
    }

    function levelUp() {
      player.level += 1;
      player.expToLevel = Math.round(player.expToLevel * 1.18);
      const growth = { str: 2, int: 2, vit: 3, agi: 2, luck: 1 };
      Object.entries(growth).forEach(([key, amount]) => {
        player.primary[key].base += amount;
      });
      recalcDerivedStats();
      player.hp = player.maxHp;
        log("ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãƒã‚¤ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“", "info");
        return;
      }
      resetSpentLabel.textContent = pendingResetSpent;
      resetModal.classList.remove("hidden");
    };
    resetCloseButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetCancelButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetConfirmButton.addEventListener("click", () => {
      resetModal.classList.add("hidden");
      resetAllocations();
    });
    resetModal.addEventListener("click", (e) => {
      if (e.target === resetModal) resetModal.classList.add("hidden");
    });
    enemyModal.addEventListener("click", (e) => {
      if (e.target === enemyModal) closeEnemyModal();
    });
    playerModal.addEventListener("click", (e) => {
      if (e.target === playerModal) closePlayerModal();
    });
    skillsModal.addEventListener("click", (e) => {
      if (e.target === skillsModal) closeSkillsModal();
    });

    const statusPopup = document.getElementById("status-popup");
    document.getElementById("status-popup-close").addEventListener("click", () => statusPopup.classList.remove("active"));
    statusPopup.addEventListener("click", (e) => {
      if (e.target === statusPopup) statusPopup.classList.remove("active");
    });

    recalcDerivedStats();
    log("=== æŒ‘æˆ¦é–‹å§‹ ===", "info");
    spawnEnemies();
    updateUI();
  </script>
</body>
</html>
