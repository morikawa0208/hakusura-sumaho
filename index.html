<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç¸¦æŒã¡ãƒã‚¯ã‚¹ãƒ©è©¦ä½œ</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #111827;
      --accent: #34d399;
      --accent-2: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(circle at 20% 20%, rgba(52, 211, 153, 0.08), transparent 25%),
        radial-gradient(circle at 80% 10%, rgba(96, 165, 250, 0.08), transparent 22%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", "Hiragino Sans", system-ui, -apple-system, sans-serif;
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      padding: 6px;
    }

    .phone {
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      width: min(460px, 100%);
      height: calc(95vh - 12px);
      display: grid;
      grid-template-rows: auto auto 1fr auto auto auto;
      gap: 6px;
      padding: 8px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px;
    }

    .subtle {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .bars {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 22px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .bar span {
      position: absolute;
      inset: 0;
      width: 50%;
      border-radius: 999px;
    }

    .bar .label {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .bar .hp {
      background: #ef4444;
    }

    .bar .mp {
      background: #3b82f6;
    }

    .bar .exp {
      background: #facc15;
    }

    #log {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.5;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 40vh;
      max-height: 40vh;
      resize: none;
    }

    .log-card {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #log .entry {
      opacity: 0.95;
      padding: 4px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
    }

    #log .entry.info {
      color: #e5e7eb;
    }

    #log .entry.player {
      color: #93c5fd;
    }

    #log .entry.enemy {
      color: #fca5a5;
    }

    #log .entry.good {
      color: #6ee7b7;
    }

    #log .entry.warning {
      color: #fcd34d;
    }

    #log .entry.danger {
      color: #fb7185;
    }

    #actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    button {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.2), rgba(96, 165, 250, 0.2));
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu {
      display: flex;
      justify-content: space-around;
      gap: 6px;
    }

    .pill {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.06);
      padding: 4px 8px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .tag {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      letter-spacing: 0.03em;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
    }

    .inline-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 5px;
      margin-top: 2px;
    }

    .primary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-top: 4px;
      align-items: start;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      padding: 5px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      display: grid;
      gap: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .stat-label.secondary {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      white-space: nowrap;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .stat-value {
      font-weight: 700;
      font-size: 13px;
      text-align: right;
    }

    .stat-value .total {
      font-weight: 800;
    }

    .stat-value .base {
      color: var(--muted);
      font-weight: 600;
    }

    .stat-value .bonus {
      color: var(--accent);
      font-weight: 800;
    }

    .stat-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .primary-row {
      align-items: center;
    }

    .primary-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      min-width: 0;
    }

    .primary-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      align-items: center;
    }

    .primary-actions .mini-btn {
      padding: 6px 10px;
      font-size: 12px;
      min-width: 50px;
    }

    .stat-label.inline {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .step-button {
      min-width: 78px;
      padding: 8px 10px;
      font-size: 12px;
    }

    .enemy-list {
      display: grid;
      grid-template-columns: repeat(var(--enemy-columns, 3), minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
      padding-bottom: 2px;
    }

    .enemy-card {
      display: grid;
      gap: 6px;
      padding: 9px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.08s ease, border-color 0.12s ease, box-shadow 0.12s ease;
      min-width: 0;
      position: relative;
    }

    .enemy-card:active {
      transform: translateY(1px);
    }

    .enemy-card:hover {
      border-color: rgba(255, 255, 255, 0.16);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }

    .attack-badge {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(52, 211, 153, 0.18);
      border: 1px solid rgba(52, 211, 153, 0.5);
      color: #ecfdf3;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      line-height: 1.2;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .attack-badge.enemy {
      background: rgba(248, 113, 113, 0.15);
      border-color: rgba(248, 113, 113, 0.4);
      color: #fee2e2;
    }

    .action-button-wrapper {
      position: relative;
    }

    .actions-row {
      display: grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 8px;
      align-items: stretch;
    }

    .potion-panel {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      align-items: stretch;
    }

    .potion-row {
      height: 100%;
    }

    .potion-button {
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.22), rgba(96, 165, 250, 0.15));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px;
      height: 100%;
    }

    .potion-icon {
      font-size: 16px;
      width: 28px;
      height: 28px;
      display: grid;
      place-items: center;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      flex-shrink: 0;
    }

    .potion-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 8px;
      font-size: 12px;
    }

    .potion-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .potion-short {
      font-weight: 700;
      font-size: 13px;
    }

    .potion-fill {
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .potion-info-button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      padding: 0;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.08);
      flex-shrink: 0;
    }

    .enemy-top {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .enemy-name {
      display: grid;
      gap: 2px;
      font-weight: 600;
    }

    .enemy-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
      font-size: 11px;
    }

    .enemy-bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .enemy-bar .fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ef4444, #f87171);
      width: 50%;
      border-radius: 999px;
    }

    .enemy-bar .label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      line-height: 1;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 50;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      width: min(420px, 94%);
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      max-height: 88vh;
      overflow-y: auto;
    }

    .player-modal-content {
      display: flex;
      flex-direction: column;
      max-height: 88vh;
      overflow: hidden;
      gap: 6px;
    }

    .secondary-scroll {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding-right: 4px;
      margin-bottom: 4px;
    }

    .primary-fixed {
      flex-shrink: 0;
      display: grid;
      gap: 8px;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    .help-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      font-weight: 800;
      cursor: pointer;
    }

    .help-panel {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      line-height: 1.5;
    }

    .modal-body-title {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .help-panel ul {
      padding-left: 16px;
      margin: 6px 0;
    }

    .modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      border-radius: 999px;
      width: 30px;
      height: 30px;
      cursor: pointer;
    }

    .status-list {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
      min-height: 18px;
    }

    .status-pill {
      font-size: 10px;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.05);
      color: #e5e7eb;
      cursor: pointer;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    .status-pill.control {
      border-color: rgba(255, 99, 132, 0.4);
      background: rgba(248, 113, 113, 0.12);
    }

    .status-pill.dot {
      border-color: rgba(74, 222, 128, 0.35);
      background: rgba(34, 197, 94, 0.12);
    }

    .status-pill.debuff {
      border-color: rgba(96, 165, 250, 0.35);
      background: rgba(59, 130, 246, 0.12);
    }

    .status-popover {
      position: fixed;
      inset: auto 12px 20px 12px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 10px;
      color: var(--text);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      z-index: 70;
      max-width: 460px;
      margin: 0 auto;
    }

    .status-popover.hidden {
      display: none;
    }

    .status-popover .title {
      font-weight: 800;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-popover .body {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .debug-selects {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin: 6px 0 4px;
    }

    .debug-selects label {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .debug-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .debug-section {
      margin-top: 8px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .debug-section h4 {
      margin: 0 0 6px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.04em;
    }

  </style>
</head>
<body>
  <div class="phone">
    <section class="card">
      <div id="enemies" class="enemy-list"></div>
    </section>

    <section class="card">
      <div class="subtle" style="justify-content: flex-start; gap: 10px; margin-bottom: 4px;">
        <span>LV <span id="level"></span></span>
        <div id="player-status-list" class="status-list" aria-label="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹"></div>
        <span class="pill">éšå±¤ <span id="floor-inline"></span>F</span>
      </div>
      <div class="bars">
        <div class="bar">
          <span id="hp-bar" class="hp"></span>
          <span id="hp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="mp-bar" class="mp"></span>
          <span id="mp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="exp-bar" class="exp"></span>
          <span id="exp-label" class="label"></span>
        </div>
      </div>
    </section>

    <section class="card log-card">
      <div id="log"></div>
    </section>

    <section class="card">
      <div id="actions"></div>
    </section>

    <nav class="menu">
      <button id="btn-player-modal">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è©³ç´°</button>
      <button id="btn-skill-tree">ã‚¹ã‚­ãƒ«</button>
      <button id="btn-debug">ãƒ‡ãƒãƒƒã‚°</button>
    </nav>
  </div>

  <div id="enemy-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">æ•µã®è©³ç´°</div>
          <div id="modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="modal-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>HP <span id="modal-hp"></span></div>
        <div>ATK <span id="modal-atk"></span></div>
        <div>DEF <span id="modal-def"></span></div>
        <div>SPD <span id="modal-spd"></span></div>
      </div>
      <div class="pill" id="modal-tag" style="margin-top: 10px; display: inline-flex;">BOSS</div>
    </div>
  </div>

  <div id="potion-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ãƒãƒ¼ã‚·ãƒ§ãƒ³è©³ç´°</div>
          <div id="potion-modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="potion-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>ç¨®é¡ <span id="potion-modal-type"></span></div>
        <div>åŠ¹æœ <span id="potion-modal-effect"></span></div>
        <div>æ¶ˆè²» <span id="potion-modal-cost"></span></div>
        <div>æ®‹é‡ <span id="potion-modal-fill"></span></div>
      </div>
      <div class="help-panel" style="margin-top: 10px;">
        æ•µã‚’å€’ã™ã¨å°‘ã—ãšã¤è£œå……ã•ã‚Œã¾ã™ã€‚
      </div>
    </div>
  </div>

  <div id="player-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content player-modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è©³ç´°</div>
        </div>
        <button id="player-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="secondary-scroll">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
          <div class="section-title" style="margin: 8px 0 4px;">äºŒæ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
          <button class="help-icon" id="stat-help" aria-label="è¨ˆç®—å¼ãƒ¡ãƒ¢">ï¼Ÿ</button>
        </div>
        <div id="secondary-stats" class="stat-grid"></div>
      </div>
      <div class="primary-fixed">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
          <div class="section-title" style="margin: 2px 0 4px;">ä¸€æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
          <div style="display: flex; align-items: center; gap: 6px;">
              <div class="inline-buttons">
                <div class="pill">èƒ½åŠ›P: <span id="stat-points"></span></div>
              </div>
            <button id="stat-step" class="step-button" aria-label="å¢—æ¸›å¹…ã‚’åˆ‡ã‚Šæ›¿ãˆ">Â±1</button>
            <button id="reset-stats" class="help-icon" aria-label="ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ">â†º</button>
          </div>
        </div>
        <div id="primary-stats" class="primary-grid"></div>
      </div>
    </div>
  </div>

  <div id="memo-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">è¨ˆç®—ãƒ¡ãƒ¢</div>
        <button id="memo-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="modal-body-title">æ”»æ’ƒãƒ»é˜²å¾¡</div>
      <div class="help-panel">
        <ul>
          <li>ç‰©ç†æ”»æ’ƒåŠ› = æ­¦å™¨ + åŠ› Ã— 1.2</li>
          <li>é­”æ³•æ”»æ’ƒåŠ› = é­”å™¨ + çŸ¥è­˜ Ã— 1.3</li>
          <li>ç‰©ç†é˜²å¾¡åŠ› = ä½“åŠ›Ã—0.6 + åŠ›Ã—0.2</li>
          <li>é­”æ³•é˜²å¾¡åŠ› = ä½“åŠ›Ã—0.5 + çŸ¥è­˜Ã—0.3</li>
          <li>ç‰©ç†è²«é€š = åŠ›ã«ã‚ˆã‚‹è»½æ¸›ç„¡è¦– (ä¸Šé™30%)</li>
          <li>é­”æ³•è²«é€š = çŸ¥è­˜ã«ã‚ˆã‚‹è»½æ¸›ç„¡è¦– (ä¸Šé™30%)</li>
          <li>è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸› = ä½“åŠ›ç”±æ¥ã®è»½æ¸› (ä¸Šé™40%)</li>
          <li>ãƒ–ãƒ­ãƒƒã‚¯ç‡ = ä½“åŠ›ãƒ™ãƒ¼ã‚¹ (ä¸Šé™25%)</li>
        </ul>
      </div>
      <div class="modal-body-title">è¡Œå‹•ãƒ»ä¼šå¿ƒ</div>
      <div class="help-panel">
        <ul>
          <li>è¡Œå‹•é€Ÿåº¦ = åŸºç¤é€Ÿåº¦ + æ•æ·</li>
          <li>å‘½ä¸­ç‡ = 70% + æ•æ·Ã—0.1%</li>
          <li>ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ / å›é¿ç‡ = (æ•æ·+é‹) æ¸›è¡°å¼</li>
          <li>ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ€ãƒ¡ãƒ¼ã‚¸ = 150% + ã‚¯ãƒªãƒ€ãƒ¡%</li>
          <li>ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ çŸ­ç¸® = æ•æ·/çŸ¥è­˜ç”±æ¥ (ä¸Šé™20%)</li>
        </ul>
      </div>
      <div class="modal-body-title">æŠµæŠ—ãƒ»è£œåŠ©ãƒ»ãƒã‚¯ã‚¹ãƒ©</div>
      <div class="help-panel">
        <ul>
          <li>è¡Œå‹•é˜»å®³æŠµæŠ— / DoTæŠµæŠ— / å¼±ä½“åŒ–æŠµæŠ— = ä½“åŠ›ï¼‹å„ç¨®ã‚¹ãƒ†ç”±æ¥ (ä¸Šé™60%)</li>
          <li>HPå†ç”Ÿ = ä½“åŠ› Ã— 0.2 / ã‚¿ãƒ¼ãƒ³</li>
          <li>HPå¸å = ä¸ãƒ€ãƒ¡ Ã— å¸å%</li>
          <li>ãƒãƒªã‚¢ = ä½“åŠ›Ã—2 + çŸ¥è­˜Ã—1</li>
          <li>ãƒ‰ãƒ­ãƒƒãƒ—ç‡UP / ãƒ¬ã‚¢ãƒªãƒ†ã‚£UP = é‹ã«ã‚ˆã‚‹æ¸›è¡°å¼ (ä¸Šé™ã‚ã‚Š)</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="reset-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ</div>
        <button id="reset-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div>æŒ¯ã‚Šåˆ†ã‘ãŸãƒã‚¤ãƒ³ãƒˆ(<span id="reset-spent"></span>P)ã‚’æˆ»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ</div>
      <div class="modal-actions">
        <button id="reset-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="reset-confirm">ãƒªã‚»ãƒƒãƒˆã™ã‚‹</button>
      </div>
    </div>
  </div>

  <div id="skill-reset-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">ã‚¹ã‚­ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ</div>
        <button id="skill-reset-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div>ç¿’å¾—ã—ãŸãƒã‚¤ãƒ³ãƒˆ(<span id="skill-reset-spent"></span>P)ã‚’æˆ»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ</div>
      <div class="modal-actions">
        <button id="skill-reset-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="skill-reset-confirm">ãƒªã‚»ãƒƒãƒˆã™ã‚‹</button>
      </div>
    </div>
  </div>

  <div id="skills-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ã‚¹ã‚­ãƒ« / ãƒ‘ãƒ¼ã‚¯</div>
          <div style="font-weight: 700;">ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚’æ¶ˆè²»ã—ã¦å¼·åŒ–</div>
        </div>
        <button id="skills-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="inline-buttons" style="margin-bottom: 6px; align-items: center;">
        <div class="pill">ã‚¹ã‚­ãƒ«P: <span id="skill-points-skill"></span></div>
        <button id="reset-skills" class="help-icon" aria-label="ã‚¹ã‚­ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ">â†º</button>
      </div>
    <div id="skills" style="margin-top: 6px;"></div>
    </div>
  </div>

  <div id="debug-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">ãƒ‡ãƒãƒƒã‚°</div>
        <button id="debug-close" class="modal-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="debug-selects">
        <label>
          å¯¾è±¡:
          <select id="debug-target">
            <option value="enemy">æ•µ</option>
            <option value="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</option>
          </select>
        </label>
        <label>
          æ•µé¸æŠ:
          <select id="debug-enemy"></select>
        </label>
      </div>
      <div id="debug-status-buttons"></div>
      <div class="modal-actions">
        <button id="debug-clear-status">é¸æŠå¯¾è±¡ã®çŠ¶æ…‹ç•°å¸¸ã‚’å…¨è§£é™¤</button>
      </div>
    </div>
  </div>

  <div id="status-popover" class="status-popover hidden" role="status" aria-live="polite">
    <div class="title">
      <span id="status-popover-name"></span>
      <span id="status-popover-turns" class="pill" style="background: rgba(255,255,255,0.08);"></span>
    </div>
    <div id="status-popover-desc" class="body"></div>
  </div>

  <script>
    const STATUS_DEFINITIONS = {
      stun: { name: "ã‚¹ã‚¿ãƒ³", short: "STN", category: "control", description: "è¡Œå‹•å®Œå…¨ä¸èƒ½ï¼ˆé€šå¸¸æ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«ä¸å¯ï¼‰" },
      sleep: { name: "ç¡çœ ", short: "SLP", category: "control", description: "è¡Œå‹•ä¸èƒ½ã€‚è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã§è§£é™¤ (DoTé™¤ã)" },
      confusion: { name: "æ··ä¹±", short: "CNF", category: "control", description: "æ”»æ’ƒå¯¾è±¡ãŒãƒ©ãƒ³ãƒ€ãƒ åŒ–ã€‚å‘³æ–¹ã‚’æ”»æ’ƒã™ã‚‹å¯èƒ½æ€§ã‚‚" },
      silence: { name: "æ²ˆé»™", short: "SIL", category: "control", description: "ã‚¹ã‚­ãƒ«ä½¿ç”¨ä¸å¯ï¼ˆé€šå¸¸æ”»æ’ƒã®ã¿å¯èƒ½ï¼‰" },
      knockdown: { name: "è»¢å€’", short: "KD", category: "control", description: "æ¬¡ã‚¿ãƒ¼ãƒ³ã®è¡Œå‹•é †ãŒæœ€å¾Œã«ãªã‚‹ï¼ˆè¡Œå‹•é…å»¶ï¼‰" },
      seal: { name: "å°å°", short: "SEAL", category: "control", description: "ãƒ‘ãƒƒã‚·ãƒ–ã‚„å¸¸æ™‚åŠ¹æœã‚’ç„¡åŠ¹åŒ–ã™ã‚‹" },
      bleed: { name: "å‡ºè¡€", short: "BLD", category: "dot", description: "ç‰©ç†DoTï¼ˆæ”»æ’ƒåŠ›ã«ä¾å­˜ï¼‰" },
      poison: { name: "æ¯’", short: "PSN", category: "dot", description: "å›ºå®šå€¤ or æœ€å¤§HPå‰²åˆã®DoT" },
      curse: { name: "å‘ªã„", short: "CUR", category: "dot", description: "ä¸ãƒ€ãƒ¡ä½ä¸‹ï¼‹å°DoTï¼ˆè¤‡åˆãƒ‡ãƒãƒ•ã§ã‚‚å¯ï¼‰" },
      burn: { name: "ç«å‚·", short: "BRN", category: "dot", description: "é­”æ³•ç³»DoTã¨ã—ã¦æ‰±ã†" },
      physAttackDown: { name: "ç‰©ç†æ”»æ’ƒãƒ€ã‚¦ãƒ³", short: "PATKâ†“", category: "debuff", description: "ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸ä¿‚æ•°ãƒ€ã‚¦ãƒ³", potency: 0.2 },
      magAttackDown: { name: "é­”æ³•æ”»æ’ƒãƒ€ã‚¦ãƒ³", short: "MATKâ†“", category: "debuff", description: "é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸ä¿‚æ•°ãƒ€ã‚¦ãƒ³", potency: 0.2 },
      physDefenseDown: { name: "ç‰©ç†é˜²å¾¡ãƒ€ã‚¦ãƒ³", short: "PDEFâ†“", category: "debuff", description: "å—ã‘ã‚‹ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ", potency: 0.2 },
      magDefenseDown: { name: "é­”æ³•é˜²å¾¡ãƒ€ã‚¦ãƒ³", short: "MDEFâ†“", category: "debuff", description: "å—ã‘ã‚‹é­”æ³•ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ ", potency: 0.2 },
      accuracyDown: { name: "å‘½ä¸­ç‡ãƒ€ã‚¦ãƒ³", short: "ACCâ†“", category: "debuff", description: "æ”»æ’ƒãŒå½“ãŸã‚Šã«ãããªã‚‹", potency: 0.15 },
      evasionDown: { name: "å›é¿ç‡ãƒ€ã‚¦ãƒ³", short: "EVAâ†“", category: "debuff", description: "æ”»æ’ƒãŒå½“ãŸã‚Šã‚„ã™ããªã‚‹", potency: 0.15 },
      speedDown: { name: "é€Ÿåº¦ãƒ€ã‚¦ãƒ³", short: "SPDâ†“", category: "debuff", description: "è¡Œå‹•é †ãŒé…ããªã‚‹ï¼è¡Œå‹•é »åº¦æ¸›å°‘", potency: 0.25 },
    };

    const STATUS_CATEGORIES = {
      control: "control",
      dot: "dot",
      debuff: "debuff",
    };

    const POTION_REFILL_ON_KILL = 12;

    const player = {
      name: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼",
      level: 1,
      exp: 0,
      expToLevel: 20,
      hp: 0,
      mp: 0,
      maxHp: 0,
      maxMp: 0,
      atk: 0,
      def: 0,
      spd: 0,
      accuracy: 0,
      evade: 0,
      attackCount: 1,
      attacksRemaining: 1,
      base: {
        hp: 80,
        mp: 30,
        physAtk: 10,
        magAtk: 8,
        physDef: 4,
        magDef: 4,
        speed: 4,
      },
      primary: {
        str: { label: "åŠ›", base: 1, bonus: 0 },
        int: { label: "çŸ¥è­˜", base: 1, bonus: 0 },
        vit: { label: "ä½“åŠ›", base: 1, bonus: 0 },
        agi: { label: "æ•æ·", base: 1, bonus: 0 },
        luck: { label: "é‹", base: 1, bonus: 0 },
      },
      allocations: {
        str: 0,
        int: 0,
        vit: 0,
        agi: 0,
        luck: 0,
      },
      bonus: {
        hp: 0,
        mp: 0,
        physAtk: 0,
        magAtk: 0,
        physDef: 0,
        magDef: 0,
        speed: 0,
        critRate: 0,
        critDamage: 0,
        evade: 0,
        physPen: 0,
        magPen: 0,
        damageReduction: 0,
        block: 0,
        controlResist: 0,
        dotResist: 0,
        debuffResist: 0,
        cooldown: 0,
        hpRegen: 0,
        lifeSteal: 0,
        barrier: 0,
        dropRate: 0,
        rarity: 0,
      },
      statPoints: 0,
      skillPoints: 0,
      buffs: { guard: 0, haste: 0, focus: 0 },
      resist: { control: 0, dot: 0, debuff: 0 },
      statuses: [],
      potions: [
        {
          id: "potion-hp-small",
          name: "ã—ã‚‡ã¼ã„HPãƒãƒ¼ã‚·ãƒ§ãƒ³",
          short: "HP",
          type: "hp",
          amount: 24,
          useCost: 35,
          fullness: 100,
          maxFullness: 100,
          icon: "ğŸ§ª",
        },
        {
          id: "potion-mp-small",
          name: "ã—ã‚‡ã¼ã„MPãƒãƒ¼ã‚·ãƒ§ãƒ³",
          short: "MP",
          type: "mp",
          amount: 12,
          useCost: 30,
          fullness: 100,
          maxFullness: 100,
          icon: "ğŸ”®",
        },
      ],
    };

    const game = {
      floor: 1,
      enemies: [],
      turnQueue: [],
      awaitingInput: false,
      defeatedBosses: 0,
    };

    const skills = {
      sharpEdge: {
        name: "é‹­åˆƒ",
        desc: "ç‰©ç†æ”»æ’ƒ+2 (æœ€å¤§3)",
        level: 0,
        max: 3,
        apply: () => (player.bonus.physAtk += 2),
      },
      quickStep: {
        name: "ç–¾é§†",
        desc: "é€Ÿåº¦+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.speed += 2),
      },
      arcaneFlow: {
        name: "é­”åŠ›å¾ªç’°",
        desc: "æœ€å¤§MP+2 (æœ€å¤§2)",
        level: 0,
        max: 2,
        apply: () => (player.bonus.mp += 2),
      },
    };

    function log(message, type = "info") {
      const logBox = document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `entry ${type}`;
      entry.textContent = message;
      logBox.appendChild(entry);
      logBox.scrollTop = logBox.scrollHeight;
    }

    const statusPopover = document.getElementById("status-popover");
    const statusPopoverName = document.getElementById("status-popover-name");
    const statusPopoverTurns = document.getElementById("status-popover-turns");
    const statusPopoverDesc = document.getElementById("status-popover-desc");
    let statusPopoverTimer = null;

    const getStatus = (entity, key) => (entity.statuses || []).find((s) => s.key === key);
    const hasStatus = (entity, key) => Boolean(getStatus(entity, key));

    function removeStatus(entity, key) {
      entity.statuses = (entity.statuses || []).filter((s) => s.key !== key);
    }

    function getResist(entity, category) {
      if (!entity.resist) return 0;
      return Math.max(0, Math.min(100, entity.resist[category] || 0));
    }

    function describeStatus(status) {
      const def = STATUS_DEFINITIONS[status.key];
      if (!def) return "";
      return `${def.description} / æ®‹ã‚Š${status.remaining}T`;
    }

    function showStatusPopover(def, status) {
      if (!def || !status) return;
      statusPopoverName.textContent = `${def.name} (${def.short})`;
      statusPopoverTurns.textContent = `æ®‹ã‚Š ${status.remaining}T`;
      statusPopoverDesc.textContent = def.description;
      statusPopover.classList.remove("hidden");
      if (statusPopoverTimer) clearTimeout(statusPopoverTimer);
      statusPopoverTimer = setTimeout(() => statusPopover.classList.add("hidden"), 2300);
    }

    statusPopover.addEventListener("click", () => statusPopover.classList.add("hidden"));

    const primaryOrder = ["str", "int", "vit", "agi", "luck"];
    const stepOptions = [1, 10, 100];
    let currentStepIndex = 0;
    let pendingResetSpent = 0;

    const displayNumber = (num, { isPercent = false } = {}) => {
      if (isPercent) {
        return (Math.round(num * 10) / 10).toFixed(1);
      }
      return Math.round(num);
    };

    function formatStatValue(value, unit = "") {
      const isPercent = unit === "%";
      const total = displayNumber(value, { isPercent });
      if (isPercent) {
        return `<span class="total">${total}${unit}</span>`;
      }
      return `<span class="total">${total}</span>`;
    }

    const formatPrimaryValue = (stat) => {
      const total = stat.base + stat.bonus;
      if (!stat.bonus) return `<span class="total">${total}</span>`;
      const bonusSign = stat.bonus > 0 ? "+" : "";
      return `<span class="total">${total}</span> (<span class="base">${stat.base}</span> <span class="bonus">${bonusSign}${stat.bonus}</span>)`;
    };

    const statTotal = (key) => {
      const stat = player.primary[key];
      return stat.base + stat.bonus;
    };

    function calcSecondaryStats() {
      const str = statTotal("str");
      const int = statTotal("int");
      const vit = statTotal("vit");
      const agi = statTotal("agi");
      const luck = statTotal("luck");

      const maxHpBase = player.base.hp + vit * 8;
      const maxMpBase = player.base.mp + int * 3;
      const physAtkBase = player.base.physAtk + str * 1.2;
      const magAtkBase = player.base.magAtk + int * 1.3;
      const physDefBase = player.base.physDef + vit * 0.6 + str * 0.2;
      const magDefBase = player.base.magDef + vit * 0.5 + int * 0.3;
      const speedBase = player.base.speed + agi;
      const critBase = Math.min(70, (agi + luck) * 0.6);
      const evadeBase = Math.min(60, (agi + luck) * 0.4);
      const accuracyBase = Math.min(100, 70 + agi * 0.1);
      const physPenBase = Math.min(30, str * 0.2);
      const magPenBase = Math.min(30, int * 0.2);
      const critDmgBase = Math.min(50, luck * 0.6);
      const damageReductionBase = Math.min(40, vit * 0.4);
      const blockBase = Math.min(25, 5 + vit * 0.3);
      const controlResistBase = Math.min(60, (vit + luck) * 0.35);
      const dotResistBase = Math.min(60, vit * 0.45 + luck * 0.1);
      const debuffResistBase = Math.min(60, (vit + int) * 0.35 + luck * 0.1);
      const cooldownBase = Math.min(20, (agi + int) * 0.15);
      const hpRegenBase = vit * 0.2;
      const lifeStealBase = Math.min(10, Math.max(str, luck) * 0.1);
      const barrierBase = vit * 2 + int;
      const dropRateBase = Math.min(50, Math.sqrt(luck) * 4 + luck * 0.2);
      const rarityBase = Math.min(30, Math.sqrt(luck) * 2 + luck * 0.1);

      return {
        maxHp: { base: maxHpBase, bonus: player.bonus.hp, total: maxHpBase + player.bonus.hp },
        maxMp: { base: maxMpBase, bonus: player.bonus.mp, total: maxMpBase + player.bonus.mp },
        physAtk: { base: physAtkBase, bonus: player.bonus.physAtk, total: physAtkBase + player.bonus.physAtk },
        magAtk: { base: magAtkBase, bonus: player.bonus.magAtk, total: magAtkBase + player.bonus.magAtk },
        physDef: { base: physDefBase, bonus: player.bonus.physDef, total: physDefBase + player.bonus.physDef },
        magDef: { base: magDefBase, bonus: player.bonus.magDef, total: magDefBase + player.bonus.magDef },
        speed: { base: speedBase, bonus: player.bonus.speed, total: speedBase + player.bonus.speed },
        critRate: { base: critBase, bonus: player.bonus.critRate, total: Math.min(70, critBase + player.bonus.critRate) },
        evade: { base: evadeBase, bonus: player.bonus.evade, total: Math.min(60, evadeBase + player.bonus.evade) },
        accuracy: { base: accuracyBase, bonus: 0, total: accuracyBase },
        physPen: { base: physPenBase, bonus: player.bonus.physPen, total: Math.min(30, physPenBase + player.bonus.physPen) },
        magPen: { base: magPenBase, bonus: player.bonus.magPen, total: Math.min(30, magPenBase + player.bonus.magPen) },
        critDamage: { base: critDmgBase, bonus: player.bonus.critDamage, total: Math.min(50, critDmgBase + player.bonus.critDamage) },
        damageReduction: { base: damageReductionBase, bonus: player.bonus.damageReduction, total: Math.min(40, damageReductionBase + player.bonus.damageReduction) },
        block: { base: blockBase, bonus: player.bonus.block, total: Math.min(25, blockBase + player.bonus.block) },
        controlResist: { base: controlResistBase, bonus: player.bonus.controlResist, total: Math.min(60, controlResistBase + player.bonus.controlResist) },
        dotResist: { base: dotResistBase, bonus: player.bonus.dotResist, total: Math.min(60, dotResistBase + player.bonus.dotResist) },
        debuffResist: { base: debuffResistBase, bonus: player.bonus.debuffResist, total: Math.min(60, debuffResistBase + player.bonus.debuffResist) },
        cooldown: { base: cooldownBase, bonus: player.bonus.cooldown, total: Math.min(20, cooldownBase + player.bonus.cooldown) },
        hpRegen: { base: hpRegenBase, bonus: player.bonus.hpRegen, total: hpRegenBase + player.bonus.hpRegen },
        lifeSteal: { base: lifeStealBase, bonus: player.bonus.lifeSteal, total: Math.min(10, lifeStealBase + player.bonus.lifeSteal) },
        barrier: { base: barrierBase, bonus: player.bonus.barrier, total: barrierBase + player.bonus.barrier },
        dropRate: { base: dropRateBase, bonus: player.bonus.dropRate, total: Math.min(50, dropRateBase + player.bonus.dropRate) },
        rarity: { base: rarityBase, bonus: player.bonus.rarity, total: Math.min(30, rarityBase + player.bonus.rarity) },
      };
    }

    function recalcDerivedStats() {
      const derived = calcSecondaryStats();
      const prevMaxHp = player.maxHp || derived.maxHp.total;
      const prevMaxMp = player.maxMp || derived.maxMp.total;

      if (player.maxHp === 0) {
        player.hp = derived.maxHp.total;
      } else {
        const hpDelta = derived.maxHp.total - prevMaxHp;
        if (hpDelta > 0) player.hp += hpDelta;
        if (player.hp > derived.maxHp.total) player.hp = derived.maxHp.total;
      }

      if (player.maxMp === 0) {
        player.mp = derived.maxMp.total;
      } else {
        const mpDelta = derived.maxMp.total - prevMaxMp;
        if (mpDelta > 0) player.mp += mpDelta;
        if (player.mp > derived.maxMp.total) player.mp = derived.maxMp.total;
      }

      player.maxHp = Math.round(derived.maxHp.total);
      player.maxMp = Math.round(derived.maxMp.total);
      player.atk = Math.round(derived.physAtk.total);
      player.def = Math.round(derived.physDef.total);
      player.spd = Math.round(derived.speed.total);
      player.accuracy = Math.round(derived.accuracy.total);
      player.evade = Math.round(derived.evade.total);
      player.resist.control = derived.controlResist.total;
      player.resist.dot = derived.dotResist.total;
      player.resist.debuff = derived.debuffResist.total;

      return derived;
    }

    function createEnemy(isBoss = false) {
      const base = game.floor * 5 + (isBoss ? 20 : 0);
      const enemy = {
        id: crypto.randomUUID(),
        name: isBoss ? `éšå±¤ãƒœã‚¹ ${game.floor}F` : `é›‘é­š ${game.floor}-${Math.ceil(Math.random() * 3)}`,
        hp: base + (isBoss ? 30 : 0),
        maxHp: base + (isBoss ? 30 : 0),
        atk: 5 + game.floor * 1.5 + (isBoss ? 4 : 0),
        def: 2 + game.floor * 0.5 + (isBoss ? 2 : 0),
        spd: 4 + Math.random() * 2 + (isBoss ? 1.5 : 0),
        accuracy: 82 + game.floor * 0.6,
        evade: Math.min(25, 8 + game.floor * 0.4 + (isBoss ? 5 : 0)),
        attackCount: 1,
        attacksRemaining: 1,
        resist: {
          control: Math.min(50, 10 + game.floor * 0.8 + (isBoss ? 8 : 0)),
          dot: Math.min(50, 8 + game.floor * 0.7 + (isBoss ? 6 : 0)),
          debuff: Math.min(50, 8 + game.floor * 0.6 + (isBoss ? 6 : 0)),
        },
        isBoss,
        statuses: [],
      };
      return enemy;
    }

    function spawnEnemies() {
      const isBossFloor = game.floor % 5 === 0;
      const count = isBossFloor ? 1 : 2 + Math.floor(Math.random() * 2);
      game.enemies = Array.from({ length: count }, () => createEnemy(isBossFloor));
      log(`${game.floor}F ä¾µå…¥ã€‚${count}ä½“ã®æ•µãŒç¾ã‚ŒãŸï¼`);
      buildTurnQueue();
      game.awaitingInput = true;
      updateUI();
      promptPlayerTurn();
    }

    function getEffectiveSpeed(entity, type) {
      let speed = entity.spd || 0;
      if (type === "player" && player.buffs.haste > 0 && !hasStatus(entity, "seal")) {
        speed += 2;
      }
      const speedDown = getStatus(entity, "speedDown");
      if (speedDown) {
        speed *= 1 - (speedDown.potency ?? STATUS_DEFINITIONS.speedDown.potency ?? 0.25);
      }
      if (hasStatus(entity, "knockdown")) {
        speed = Math.max(0.2, speed * 0.1);
      }
      return speed + Math.random() * 2;
    }

    function decayStatuses(entity) {
      entity.statuses = (entity.statuses || [])
        .map((s) => ({ ...s, remaining: s.remaining - 1 }))
        .filter((s) => s.remaining > 0);
    }

    function tickBuffs(entity) {
      if (!entity.buffs) return;
      Object.keys(entity.buffs).forEach((key) => {
        if (entity.buffs[key] > 0) entity.buffs[key] -= 1;
      });
    }

    function buildTurnQueue() {
      const queue = [];
      if (player.hp > 0) {
        queue.push({ type: "player", speed: getEffectiveSpeed(player, "player") });
      }
      game.enemies.filter(e => e.hp > 0).forEach(e => {
        queue.push({ type: "enemy", id: e.id, speed: getEffectiveSpeed(e, "enemy") });
      });
      queue.sort((a, b) => b.speed - a.speed);
      game.turnQueue = queue;
    }

    function applyStatus(target, key, { duration = 2, chance = 100, potency, payload, ignoreResist = false } = {}) {
      const def = STATUS_DEFINITIONS[key];
      if (!def) return false;
      const resist = ignoreResist ? 0 : getResist(target, def.category);
      const effectiveChance = Math.max(0, Math.min(100, chance - resist));
      if (effectiveChance <= 0) return false;
      const roll = Math.random() * 100;
      if (roll > effectiveChance) return false;
      const existing = getStatus(target, key);
      if (existing) {
        existing.remaining = Math.max(existing.remaining, duration);
        if (potency !== undefined) existing.potency = potency;
        if (payload !== undefined) existing.payload = payload;
      } else {
        target.statuses = target.statuses || [];
        target.statuses.push({ key, remaining: duration, potency: potency ?? def.potency ?? 0, payload });
      }
      if (key === "seal" && target.buffs) {
        Object.keys(target.buffs).forEach((buff) => (target.buffs[buff] = 0));
      }
      return true;
    }

    function calculateDotDamage(target, status) {
      switch (status.key) {
        case "bleed":
          return Math.max(1, Math.round(((status.payload?.attack || target.maxHp * 0.05) * 0.4)));
        case "poison":
          return Math.max(1, Math.round(target.maxHp * 0.06 + 2));
        case "curse":
          return Math.max(1, Math.round(target.maxHp * 0.04 + 1));
        case "burn":
          return Math.max(1, Math.round(target.maxHp * 0.05 + 3));
        default:
          return 0;
      }
    }

    function applyDotEffects(entity) {
      (entity.statuses || []).forEach((status) => {
        const def = STATUS_DEFINITIONS[status.key];
        if (!def || def.category !== STATUS_CATEGORIES.dot) return;
        const dotDmg = calculateDotDamage(entity, status);
        if (dotDmg <= 0) return;
        const dealt = applyDamage(entity, dotDmg, { type: "dot", source: status.key, isDot: true });
        if (dealt > 0) {
          log(`ğŸ©¸ ${entity.name} ã¯${def.name}ã§ ${dealt} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "danger");
        }
      });
    }

    function processTurnStart(entity) {
      const baseAttacks = Math.max(0, Math.floor(entity.attackCount || 0));
      entity.attacksRemaining = baseAttacks;
      applyDotEffects(entity);
      if (entity.hp <= 0) return { defeated: true, skipTurn: true };
      const skipTurn = hasStatus(entity, "stun") || hasStatus(entity, "sleep");
      if (skipTurn) {
        log(`${entity.name} ã¯è¡Œå‹•ä¸èƒ½â€¦`, "warning");
      }
      return { skipTurn, defeated: false };
    }

    function finalizeTurn(entity) {
      decayStatuses(entity);
      tickBuffs(entity);
    }

    function updateBars(id, current, max, cls) {
      const bar = document.getElementById(id);
      const percent = Math.max(0, Math.min(100, (current / max) * 100));
      bar.style.width = `${percent}%`;
      bar.className = cls;
    }

    function updateUI() {
      const derived = recalcDerivedStats();
      updateStepButton();
      document.getElementById("floor-inline").textContent = game.floor;
      document.getElementById("hp-label").textContent = `HP ${Math.ceil(player.hp)} / ${derived.maxHp.total}`;
      document.getElementById("mp-label").textContent = `MP ${Math.ceil(player.mp)} / ${derived.maxMp.total}`;
      document.getElementById("exp-label").textContent = `EXP ${player.exp} / ${player.expToLevel}`;
      document.getElementById("level").textContent = player.level;
      document.getElementById("stat-points").textContent = player.statPoints;
      document.getElementById("skill-points-skill").textContent = player.skillPoints;
      updateBars("hp-bar", player.hp, derived.maxHp.total, "hp");
      updateBars("mp-bar", player.mp, derived.maxMp.total, "mp");
      updateBars("exp-bar", player.exp, player.expToLevel, "exp");

      renderEnemies();
      renderActions();
      renderSecondaryStats(derived);
      renderPrimaryStats();
      renderSkills();
      renderStatusList(document.getElementById("player-status-list"), player);
    }

    function renderStatusList(container, entity) {
      if (!container) return;
      container.innerHTML = "";
      (entity.statuses || []).forEach((status) => {
        const def = STATUS_DEFINITIONS[status.key];
        if (!def) return;
        const pill = document.createElement("div");
        pill.className = `status-pill ${def.category}`;
        pill.textContent = def.short;
        pill.title = describeStatus(status);
        pill.onclick = (e) => {
          e.stopPropagation();
          showStatusPopover(def, status);
        };
        container.appendChild(pill);
      });
    }

    function renderDebugStatusButtons() {
      const container = document.getElementById("debug-status-buttons");
      if (!container) return;
      container.innerHTML = "";
      const groups = { control: [], dot: [], debuff: [] };
      Object.entries(STATUS_DEFINITIONS).forEach(([key, def]) => {
        if (!groups[def.category]) return;
        groups[def.category].push({ key, def });
      });

      Object.entries(groups).forEach(([category, items]) => {
        const section = document.createElement("div");
        section.className = "debug-section";
        const title = document.createElement("h4");
        const label =
          category === STATUS_CATEGORIES.control
            ? "è¡Œå‹•é˜»å®³"
            : category === STATUS_CATEGORIES.dot
              ? "DoT"
              : "å¼±ä½“åŒ–";
        title.textContent = `${label} (${items.length})`;
        section.appendChild(title);

        const row = document.createElement("div");
        row.className = "debug-buttons";
        items.forEach(({ key, def }) => {
          const btn = document.createElement("button");
          btn.textContent = `${def.short} ${def.name}`;
          btn.onclick = () => {
            const target = getDebugTarget();
            if (!target) {
              log("å¯¾è±¡ãŒå­˜åœ¨ã—ã¾ã›ã‚“", "warning");
              return;
            }
            const applied = applyStatus(target, key, { duration: 3, chance: 100, potency: def.potency, ignoreResist: true });
            if (applied) {
              log(`ğŸ ãƒ‡ãƒãƒƒã‚°: ${target.name} ã«${def.name}ã‚’ä»˜ä¸`, "info");
              updateUI();
            } else {
              log("ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸ", "warning");
            }
          };
          row.appendChild(btn);
        });
        section.appendChild(row);
        container.appendChild(section);
      });
    }

    function populateDebugEnemySelect() {
      const select = document.getElementById("debug-enemy");
      if (!select) return;
      select.innerHTML = "";
      if (!game.enemies.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "æ•µãªã—";
        select.appendChild(opt);
        return;
      }
      game.enemies.forEach((enemy, index) => {
        const opt = document.createElement("option");
        opt.value = String(enemy.id);
        opt.textContent = `#${index + 1} ${enemy.name}${enemy.hp <= 0 ? " (æ’ƒç ´)" : ""}`;
        select.appendChild(opt);
      });
    }

    function updateDebugTargetState() {
      const targetSelect = document.getElementById("debug-target");
      const enemySelect = document.getElementById("debug-enemy");
      if (!targetSelect || !enemySelect) return;
      const isPlayer = targetSelect.value === "player";
      enemySelect.disabled = isPlayer;
      if (!isPlayer && enemySelect.options.length > 0 && !enemySelect.value) {
        enemySelect.value = enemySelect.options[0].value;
      }
    }

    function getDebugTarget() {
      const targetSelect = document.getElementById("debug-target");
      const enemySelect = document.getElementById("debug-enemy");
      if (!targetSelect) return null;
      if (targetSelect.value === "player") return player;
      const enemyId = enemySelect?.value;
      if (!enemyId) return game.enemies[0] || null;
      return (
        game.enemies.find((e) => String(e.id) === enemyId && e.hp > 0) ||
        game.enemies.find((e) => String(e.id) === enemyId) ||
        game.enemies[0] ||
        null
      );
    }

    function openDebugModal() {
      populateDebugEnemySelect();
      renderDebugStatusButtons();
      updateDebugTargetState();
      debugModal?.classList.remove("hidden");
    }

    function closeDebugModal() {
      debugModal?.classList.add("hidden");
    }

    function renderEnemies() {
      const wrapper = document.getElementById("enemies");
      wrapper.innerHTML = "";
      const enemyColumns = Math.max(1, Math.min(3, game.enemies.length || 1));
      wrapper.style.setProperty("--enemy-columns", enemyColumns);
      game.enemies.forEach((enemy, index) => {
        const card = document.createElement("div");
        card.className = "enemy-card";
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", `${enemy.name} ã®è©³ç´°`);
        card.onclick = () => openEnemyModal(enemy);

        const top = document.createElement("div");
        top.className = "enemy-top";

        const name = document.createElement("div");
        name.className = "enemy-name";
        const titleLabel = document.createElement("span");
        titleLabel.textContent = `${enemy.isBoss ? "ğŸ‘‘" : "ğŸ‘¾"} ${enemy.name}`;

        const meta = document.createElement("div");
        meta.className = "enemy-meta";
        const order = document.createElement("span");
        order.textContent = `#${index + 1}`;
        const statusList = document.createElement("div");
        statusList.className = "status-list";
        renderStatusList(statusList, enemy);
        meta.appendChild(order);
        meta.appendChild(statusList);

        name.appendChild(titleLabel);
        name.appendChild(meta);
        top.appendChild(name);

        const tag = document.createElement("div");
        tag.className = "pill";
        tag.style.display = enemy.isBoss ? "inline-flex" : "none";
        tag.textContent = "BOSS";
        top.appendChild(tag);

        const bar = document.createElement("div");
        bar.className = "enemy-bar";
        const fill = document.createElement("span");
        fill.className = "fill";
        const hpPct = Math.max(0, Math.floor((enemy.hp / enemy.maxHp) * 100));
        fill.style.width = `${hpPct}%`;
        const hpLabel = document.createElement("span");
        hpLabel.className = "label";
        hpLabel.textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp} (${hpPct}%)`;
        bar.appendChild(fill);
        bar.appendChild(hpLabel);

        const attackBadge = document.createElement("div");
        attackBadge.className = "attack-badge enemy";
        const enemyAttacks = Math.max(0, enemy.attacksRemaining ?? enemy.attackCount ?? 0);
        attackBadge.textContent = `x${enemyAttacks}`;
        attackBadge.title = "1ã‚¿ãƒ¼ãƒ³ã‚ãŸã‚Šã®æ”»æ’ƒå›æ•°";

        card.appendChild(top);
        card.appendChild(bar);
        card.appendChild(attackBadge);
        wrapper.appendChild(card);
      });
    }

    function renderActions() {
      const container = document.getElementById("actions");
      container.innerHTML = "";
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      const canAct = game.awaitingInput && enemiesAlive && player.hp > 0;

      const row = document.createElement("div");
      row.className = "actions-row";

      const potionPanel = document.createElement("div");
      potionPanel.className = "potion-panel";
      (player.potions || []).forEach((potion, index) => {
        const potionRow = document.createElement("div");
        potionRow.className = "potion-row";

        const potionBtn = document.createElement("button");
        potionBtn.className = "potion-button";
        potionBtn.onclick = () => usePotion(index);
        const useCost = potion.useCost ?? 25;
        const maxFullness = potion.maxFullness ?? 100;
        potion.fullness = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
        const resourceFull = potion.type === "hp" ? player.hp >= player.maxHp : player.mp >= player.maxMp;
        const icon = document.createElement("div");
        icon.className = "potion-icon";
        icon.textContent = potion.icon || "ğŸ§ª";

        const meta = document.createElement("div");
        meta.className = "potion-meta";
        const textWrap = document.createElement("div");
        textWrap.className = "potion-text";
        const shortLabel = document.createElement("div");
        shortLabel.className = "potion-short";
        shortLabel.textContent = potion.short || (potion.type === "hp" ? "HP" : "MP");
        const fill = document.createElement("div");
        fill.className = "potion-fill";
        fill.textContent = `${Math.round(potion.fullness)}%`;
        textWrap.appendChild(shortLabel);
        textWrap.appendChild(fill);

        const infoBtn = document.createElement("div");
        infoBtn.className = "potion-info-button";
        infoBtn.textContent = "i";
        infoBtn.title = "ãƒãƒ¼ã‚·ãƒ§ãƒ³è©³ç´°";
        infoBtn.tabIndex = 0;
        infoBtn.setAttribute("role", "button");
        infoBtn.onclick = (event) => {
          event.stopPropagation();
          openPotionModal(potion);
        };
        infoBtn.onkeydown = (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            event.stopPropagation();
            openPotionModal(potion);
          }
        };

        meta.appendChild(textWrap);
        meta.appendChild(infoBtn);

        potionBtn.appendChild(icon);
        potionBtn.appendChild(meta);

        potionBtn.title = `${potion.short || potion.name} (${useCost}%æ¶ˆè²»)`;
        potionBtn.disabled = !canAct || potion.fullness < useCost || resourceFull;
        potionRow.appendChild(potionBtn);
        potionPanel.appendChild(potionRow);
      });

      const wrapper = document.createElement("div");
      wrapper.className = "action-button-wrapper";
      const btn = document.createElement("button");
      if (player.hp <= 0) {
        btn.textContent = "æˆ¦é—˜ä¸èƒ½";
        btn.disabled = true;
      } else if (!enemiesAlive) {
        btn.textContent = "æ¬¡ã®éšå±¤ã¸";
        btn.onclick = nextFloor;
      } else {
        btn.textContent = "âš”ï¸ ã“ã†ã’ã";
        btn.disabled = !canAct;
        btn.onclick = playerAttack;
      }
      wrapper.appendChild(btn);
      if (player.hp > 0 && enemiesAlive) {
        const attackBadge = document.createElement("div");
        attackBadge.className = "attack-badge";
        const playerAttacks = Math.max(0, player.attacksRemaining ?? player.attackCount ?? 0);
        attackBadge.textContent = `x${playerAttacks}`;
        attackBadge.title = "1ã‚¿ãƒ¼ãƒ³ã‚ãŸã‚Šã®æ”»æ’ƒå›æ•°";
        wrapper.appendChild(attackBadge);
      }
      row.appendChild(potionPanel);
      row.appendChild(wrapper);
      container.appendChild(row);
    }

    function renderSecondaryStats(derived) {
      const container = document.getElementById("secondary-stats");
      container.innerHTML = "";
      const rows = [
        { label: "ç‰©ç†æ”»æ’ƒåŠ›", value: derived.physAtk.total },
        { label: "é­”æ³•æ”»æ’ƒåŠ›", value: derived.magAtk.total },
        { label: "ç‰©ç†è²«é€š", value: derived.physPen.total, unit: "%" },
        { label: "é­”æ³•è²«é€š", value: derived.magPen.total, unit: "%" },
        { label: "ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡", value: derived.critRate.total, unit: "%" },
        { label: "ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ€ãƒ¡ãƒ¼ã‚¸", value: derived.critDamage.total, unit: "%" },
        { label: "å‘½ä¸­ç‡", value: derived.accuracy.total, unit: "%" },
        { label: "å›é¿ç‡", value: derived.evade.total, unit: "%" },
        { label: "æœ€å¤§HP", value: derived.maxHp.total },
        { label: "æœ€å¤§MP", value: derived.maxMp.total },
        { label: "ç‰©ç†é˜²å¾¡åŠ›", value: derived.physDef.total },
        { label: "é­”æ³•é˜²å¾¡åŠ›", value: derived.magDef.total },
        { label: "è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›", value: derived.damageReduction.total, unit: "%" },
        { label: "ãƒ–ãƒ­ãƒƒã‚¯ç‡", value: derived.block.total, unit: "%" },
        { label: "è¡Œå‹•é€Ÿåº¦", value: derived.speed.total },
        { label: "ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ çŸ­ç¸®", value: derived.cooldown.total, unit: "%" },
        { label: "è¡Œå‹•é˜»å®³æŠµæŠ—", value: derived.controlResist.total, unit: "%" },
        { label: "DoTæŠµæŠ—", value: derived.dotResist.total, unit: "%" },
        { label: "å¼±ä½“åŒ–æŠµæŠ—", value: derived.debuffResist.total, unit: "%" },
        { label: "HPå†ç”Ÿ", value: derived.hpRegen.total },
        { label: "HPå¸å", value: derived.lifeSteal.total, unit: "%" },
        { label: "ãƒãƒªã‚¢", value: derived.barrier.total },
        { label: "ãƒ‰ãƒ­ãƒƒãƒ—ç‡UP", value: derived.dropRate.total, unit: "%" },
        { label: "ãƒ¬ã‚¢ãƒªãƒ†ã‚£UP", value: derived.rarity.total, unit: "%" },
      ];

      rows.forEach((row) => {
        const el = document.createElement("div");
        el.className = "stat-row";
        const left = document.createElement("div");
        left.className = "stat-label secondary";
        left.innerHTML = `<span>${row.label}</span>`;
        const right = document.createElement("div");
        right.className = "stat-value";
        const rendered = formatStatValue(row.value, row.unit || "");
        right.innerHTML = rendered;
        el.appendChild(left);
        el.appendChild(right);
        container.appendChild(el);
      });
    }

    function adjustPrimary(key, delta) {
      if (delta === 0) return;
      if (delta > 0) {
        const use = Math.min(delta, player.statPoints);
        if (use <= 0) return;
        player.statPoints -= use;
        player.primary[key].base += use;
        player.allocations[key] += use;
        log(`èƒ½åŠ›Pã‚’ä½¿ç”¨: ${player.primary[key].label} +${use}`, "good");
      } else {
        const refundable = player.allocations[key];
        const giveBack = Math.min(refundable, Math.abs(delta));
        if (giveBack <= 0) return;
        player.primary[key].base -= giveBack;
        player.allocations[key] -= giveBack;
        player.statPoints += giveBack;
        log(`èƒ½åŠ›Pã‚’è¿”å´: ${player.primary[key].label} -${giveBack}`, "info");
      }
      updateUI();
    }

    function getAdjustStep() {
      return stepOptions[currentStepIndex];
    }

    function updateStepButton() {
      if (!statStepButton) return;
      const step = getAdjustStep();
      statStepButton.textContent = `Â±${step}`;
      statStepButton.title = `å¢—æ¸›å¹… ${step}`;
    }

    function renderPrimaryStats() {
      const container = document.getElementById("primary-stats");
      container.innerHTML = "";
      const step = getAdjustStep();

      primaryOrder.forEach((key) => {
        const stat = player.primary[key];
        const row = document.createElement("div");
        row.className = "stat-row primary-row";

        const info = document.createElement("div");
        info.className = "primary-info";

        const label = document.createElement("div");
        label.className = "stat-label inline";
        label.textContent = stat.label;

        const value = document.createElement("div");
        value.className = "stat-value";
        value.innerHTML = formatPrimaryValue(stat);

        info.appendChild(label);
        info.appendChild(value);

        const actions = document.createElement("div");
        actions.className = "primary-actions";

        const inc = document.createElement("button");
        inc.textContent = `+${step}`;
        inc.classList.add("mini-btn");
        inc.disabled = player.statPoints <= 0;
        inc.title = `${step}ãƒã‚¤ãƒ³ãƒˆå¢—åŠ `;
        inc.onclick = () => adjustPrimary(key, step);

        const dec = document.createElement("button");
        dec.textContent = `-${step}`;
        dec.classList.add("mini-btn");
        dec.disabled = player.allocations[key] <= 0;
        dec.title = `${step}ãƒã‚¤ãƒ³ãƒˆæ¸›å°‘`;
        dec.onclick = () => adjustPrimary(key, -step);

        actions.appendChild(inc);
        actions.appendChild(dec);

        row.appendChild(info);
        row.appendChild(actions);
        container.appendChild(row);
      });
    }

    function renderSkills() {
      const container = document.getElementById("skills");
      container.innerHTML = "";
      Object.entries(skills).forEach(([key, skill]) => {
        const row = document.createElement("div");
        row.style.marginBottom = "6px";
        const btn = document.createElement("button");
        btn.textContent = `${skill.name} (${skill.level}/${skill.max})`;
        btn.disabled = player.skillPoints <= 0 || skill.level >= skill.max;
        btn.onclick = () => {
          if (player.skillPoints <= 0 || skill.level >= skill.max) return;
          player.skillPoints -= 1;
          skill.level += 1;
          skill.apply();
          log(`ã‚¹ã‚­ãƒ«ã€${skill.name}ã€ã‚’å¼·åŒ– (${skill.level}/${skill.max})`, "good");
          updateUI();
        };
        const desc = document.createElement("div");
        desc.className = "subtle";
        desc.textContent = skill.desc;
        row.appendChild(btn);
        row.appendChild(desc);
        container.appendChild(row);
      });
    }

    const enemyModal = document.getElementById("enemy-modal");
    const potionModal = document.getElementById("potion-modal");
    const playerModal = document.getElementById("player-modal");
    const skillsModal = document.getElementById("skills-modal");
    const closeModalButton = document.getElementById("modal-close");
    const potionModalCloseButton = document.getElementById("potion-close");
    const playerModalCloseButton = document.getElementById("player-close");
    const skillsModalCloseButton = document.getElementById("skills-close");
    const statHelpButton = document.getElementById("stat-help");
    const potionModalName = document.getElementById("potion-modal-name");
    const potionModalType = document.getElementById("potion-modal-type");
    const potionModalEffect = document.getElementById("potion-modal-effect");
    const potionModalCost = document.getElementById("potion-modal-cost");
    const potionModalFill = document.getElementById("potion-modal-fill");
    const memoModal = document.getElementById("memo-modal");
    const memoCloseButton = document.getElementById("memo-close");
    const resetModal = document.getElementById("reset-modal");
    const resetCloseButton = document.getElementById("reset-close");
    const resetCancelButton = document.getElementById("reset-cancel");
    const resetConfirmButton = document.getElementById("reset-confirm");
    const resetSpentLabel = document.getElementById("reset-spent");
    const resetButton = document.getElementById("reset-stats");
    const statStepButton = document.getElementById("stat-step");
    const resetSkillsButton = document.getElementById("reset-skills");
    const skillResetModal = document.getElementById("skill-reset-modal");
    const skillResetCloseButton = document.getElementById("skill-reset-close");
    const skillResetCancelButton = document.getElementById("skill-reset-cancel");
    const skillResetConfirmButton = document.getElementById("skill-reset-confirm");
    const skillResetSpentLabel = document.getElementById("skill-reset-spent");
    const debugModal = document.getElementById("debug-modal");
    const debugOpenButton = document.getElementById("btn-debug");
    const debugCloseButton = document.getElementById("debug-close");
    const debugTargetSelect = document.getElementById("debug-target");
    const debugEnemySelect = document.getElementById("debug-enemy");
    const debugClearButton = document.getElementById("debug-clear-status");

    function openEnemyModal(enemy) {
      document.getElementById("modal-name").textContent = enemy.name;
      document.getElementById("modal-hp").textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp}`;
      document.getElementById("modal-atk").textContent = Math.ceil(enemy.atk);
      document.getElementById("modal-def").textContent = Math.ceil(enemy.def);
      document.getElementById("modal-spd").textContent = enemy.spd.toFixed(1);
      document.getElementById("modal-tag").style.display = enemy.isBoss ? "inline-flex" : "none";
      enemyModal.classList.remove("hidden");
    }

    function closeEnemyModal() {
      enemyModal.classList.add("hidden");
    }

    function openPotionModal(potion) {
      if (!potion) return;
      const useCost = potion.useCost ?? 25;
      const maxFullness = potion.maxFullness ?? 100;
      const currentFill = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
      potionModalName.textContent = potion.name;
      potionModalType.textContent = potion.type === "hp" ? "HPå›å¾©" : "MPå›å¾©";
      potionModalEffect.textContent = potion.type === "hp" ? `HPã‚’${potion.amount}å›å¾©` : `MPã‚’${potion.amount}å›å¾©`;
      potionModalCost.textContent = `1å› ${useCost}% æ¶ˆè²»`;
      potionModalFill.textContent = `${Math.round(currentFill)}% / ${maxFullness}%`;
      potionModal.classList.remove("hidden");
    }

    function closePotionModal() {
      potionModal.classList.add("hidden");
    }

    function resetSkillBonuses() {
      Object.keys(player.bonus).forEach((key) => {
        player.bonus[key] = 0;
      });
      Object.values(skills).forEach((skill) => {
        for (let i = 0; i < skill.level; i += 1) {
          skill.apply();
        }
      });
    }

    function resetSkills() {
      const spent = Object.values(skills).reduce((sum, skill) => sum + skill.level, 0);
      if (spent === 0) {
        log("ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã‚¹ã‚­ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“", "info");
        return;
      }
      Object.values(skills).forEach((skill) => {
        skill.level = 0;
      });
      resetSkillBonuses();
      player.skillPoints += spent;
      updateUI();
      log("ã‚¹ã‚­ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ", "info");
    }

    function openPlayerModal() {
      updateUI();
      playerModal.classList.remove("hidden");
    }

    function closePlayerModal() {
      playerModal.classList.add("hidden");
    }

    function openSkillsModal() {
      updateUI();
      skillsModal.classList.remove("hidden");
    }

    function closeSkillsModal() {
      skillsModal.classList.add("hidden");
    }

    function promptPlayerTurn() {
      game.awaitingInput = true;
      renderActions();
    }

    function endPlayerTurn() {
      game.awaitingInput = false;
      finalizeTurn(player);
      renderActions();
      setTimeout(() => nextTurn(), 350);
    }

    function chooseTargetForPlayer() {
      const aliveEnemies = game.enemies.filter(e => e.hp > 0);
      if (aliveEnemies.length === 0) return null;
      if (hasStatus(player, "confusion")) {
        const pool = [...aliveEnemies, player];
        return pool[Math.floor(Math.random() * pool.length)];
      }
      return aliveEnemies[0];
    }

    function chooseTargetForEnemy(enemy) {
      const allies = game.enemies.filter(e => e.hp > 0 && e.id !== enemy.id);
      if (hasStatus(enemy, "confusion") && (allies.length > 0 || player.hp > 0)) {
        const pool = [player, ...allies, enemy];
        return pool[Math.floor(Math.random() * pool.length)];
      }
      return player;
    }

    function getAccuracyWithStatus(entity) {
      const debuff = getStatus(entity, "accuracyDown");
      let acc = entity.accuracy || 90;
      if (debuff) {
        acc *= 1 - (debuff.potency ?? STATUS_DEFINITIONS.accuracyDown.potency ?? 0.15);
      }
      return Math.max(30, acc);
    }

    function getEvasionWithStatus(entity) {
      const debuff = getStatus(entity, "evasionDown");
      let eva = entity.evade || 0;
      if (debuff) {
        eva *= 1 - (debuff.potency ?? STATUS_DEFINITIONS.evasionDown.potency ?? 0.15);
      }
      return Math.max(0, eva);
    }

    function attemptHit(attacker, defender) {
      const acc = getAccuracyWithStatus(attacker);
      const eva = getEvasionWithStatus(defender);
      const hitChance = Math.max(20, Math.min(98, 90 + (acc - eva) * 0.4));
      return Math.random() * 100 < hitChance;
    }

    function calcDamage(attacker, defender, { type = "physical" } = {}) {
      const variance = 0.85 + Math.random() * 0.3;
      const attackDebuff = type === "physical" ? getStatus(attacker, "physAttackDown") : getStatus(attacker, "magAttackDown");
      const baseAttack = type === "physical" ? attacker.atk : attacker.magAtk || attacker.atk;
      let attackPower = baseAttack * (attackDebuff ? 1 - (attackDebuff.potency ?? 0.2) : 1);
      if (hasStatus(attacker, "curse")) {
        attackPower *= 0.9;
      }
      let defense = type === "physical" ? defender.def : defender.magDef || defender.def;
      const defenseDown = type === "physical" ? getStatus(defender, "physDefenseDown") : getStatus(defender, "magDefenseDown");
      if (defenseDown) {
        defense *= 1 - (defenseDown.potency ?? 0.2);
      }
      const raw = Math.max(1, attackPower * variance - defense);
      return Math.max(1, Math.round(raw));
    }

    function applyDamage(target, amount, { type = "physical", source = "", isDot = false } = {}) {
      let final = amount;
      if (target === player && player.buffs.guard > 0 && !hasStatus(player, "seal")) {
        final = Math.round(final * 0.7);
      }
      final = Math.max(0, Math.round(final));
      target.hp = Math.max(0, target.hp - final);
      if (!isDot && final > 0 && hasStatus(target, "sleep")) {
        removeStatus(target, "sleep");
        log(`${target.name} ã¯æ”»æ’ƒã‚’å—ã‘ã¦ç›®ã‚’è¦šã¾ã—ãŸ`, "info");
      }
      return final;
    }

    function usePotion(index) {
      if (!game.awaitingInput) return;
      if (!player.potions || !player.potions[index]) return;
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      if (!enemiesAlive) {
        log("ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯æˆ¦é—˜ä¸­ã®ã¿ä½¿ç”¨ã§ãã¾ã™", "warning");
        return;
      }
      const potion = player.potions[index];
      const useCost = potion.useCost ?? 25;
      const maxFullness = potion.maxFullness ?? 100;
      potion.fullness = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
      if (potion.fullness < useCost) {
        log("ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®æ®‹é‡ãŒè¶³ã‚Šãªã„â€¦", "warning");
        return;
      }

      const derived = recalcDerivedStats();
      if (potion.type === "hp") {
        if (player.hp >= derived.maxHp.total) {
          log("HPã¯ååˆ†ã«æ®‹ã£ã¦ã„ã‚‹", "info");
          return;
        }
        const heal = Math.min(potion.amount, derived.maxHp.total - player.hp);
        player.hp = Math.min(derived.maxHp.total, player.hp + heal);
        log(`${potion.icon || "ğŸ§ª"} ${potion.name}ã‚’é£²ã‚“ã§HPã‚’${heal}å›å¾©`, "good");
      } else if (potion.type === "mp") {
        if (player.mp >= derived.maxMp.total) {
          log("MPã¯ååˆ†ã«æ®‹ã£ã¦ã„ã‚‹", "info");
          return;
        }
        const restored = Math.min(potion.amount, derived.maxMp.total - player.mp);
        player.mp = Math.min(derived.maxMp.total, player.mp + restored);
        log(`${potion.icon || "ğŸ”®"} ${potion.name}ã‚’é£²ã‚“ã§MPã‚’${restored}å›å¾©`, "good");
      }

      potion.fullness = Math.max(0, potion.fullness - useCost);
      updateUI();
      endPlayerTurn();
    }

    function refillPotionsOnKill() {
      if (!player.potions?.length) return false;
      let restored = false;
      player.potions.forEach((potion) => {
        const maxFullness = potion.maxFullness ?? 100;
        const current = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
        const next = Math.min(maxFullness, current + POTION_REFILL_ON_KILL);
        if (next > current) {
          potion.fullness = next;
          restored = true;
        } else {
          potion.fullness = current;
        }
      });
      if (restored) {
        log("ğŸ’§ ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®æ®‹é‡ãŒå°‘ã—å›å¾©ã—ãŸ", "info");
      }
      return restored;
    }

    function playerAttack() {
      if (!game.awaitingInput) return;
      const attacks = Math.max(0, Math.floor(player.attacksRemaining ?? player.attackCount ?? 0));
      if (attacks <= 0) {
        log("æ”»æ’ƒå›æ•°ãŒæ®‹ã£ã¦ã„ãªã„â€¦", "warning");
        return;
      }
      player.attacksRemaining = attacks;
      let acted = false;
      for (let i = 0; i < attacks; i += 1) {
        const target = chooseTargetForPlayer();
        if (!target) break;
        acted = true;
        const hit = attemptHit(player, target);
        if (!hit) {
          log(`âš”ï¸ ã‚ãªãŸã®æ”»æ’ƒ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}ã¯å¤–ã‚ŒãŸâ€¦`, "warning");
          continue;
        }
        const dmg = calcDamage(player, target);
        const dealt = applyDamage(target, dmg, { source: "player" });
        const targetName = target === player ? "è‡ªåˆ†" : target.name;
        log(`âš”ï¸ ã‚ãªãŸã®æ”»æ’ƒ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}ï¼ ${targetName} ã« ${dealt} ãƒ€ãƒ¡ãƒ¼ã‚¸`, target === player ? "warning" : "player");
        if (target !== player && target.hp <= 0) {
          log(`${target.name} ã‚’å€’ã—ãŸï¼`, "good");
          refillPotionsOnKill();
          checkVictory();
          if (!game.enemies.some(e => e.hp > 0)) break;
        }
        player.attacksRemaining = Math.max(0, attacks - i - 1);
      }
      if (!acted) return;
      updateUI();
      endPlayerTurn();
    }

    function powerStrike() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("æ²ˆé»™ä¸­ã§ã‚¹ã‚­ãƒ«ãŒä½¿ãˆãªã„ï¼", "warning");
        return;
      }
      if (player.mp < 5) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 5;
      const target = chooseTargetForPlayer();
      if (!target) return;
      const hit = attemptHit(player, target);
      if (!hit) {
        log("ğŸŒŒ ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯ã¯ç©ºæŒ¯ã‚Šï¼", "warning");
        updateUI();
        endPlayerTurn();
        return;
      }
      const dmg = Math.round(calcDamage(player, target) * 1.6 + (player.buffs.focus ? 6 : 0));
      const dealt = applyDamage(target, dmg, { source: "player" });
      log(`ğŸŒŒ ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯ï¼ ${target.name} ã« ${dealt} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "player");
      if (target.hp <= 0) {
        log(`${target.name} ã‚’ç²‰ç •ï¼`, "good");
        checkVictory();
      } else {
        const knocked = applyStatus(target, "knockdown", { duration: 1, chance: 70 });
        if (knocked) log(`${target.name} ã‚’è»¢å€’ã•ã›ãŸï¼`, "good");
      }
      updateUI();
      endPlayerTurn();
    }

    function heal() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("æ²ˆé»™ä¸­ã§ã‚¹ã‚­ãƒ«ãŒä½¿ãˆãªã„ï¼", "warning");
        return;
      }
      if (player.mp < 4) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 4;
      const healAmount = Math.max(6, Math.round(player.maxHp * 0.12 + (player.buffs.focus ? 5 : 0)));
      player.hp = Math.min(player.maxHp, player.hp + healAmount);
      log(`âœ¨ ãƒ’ãƒ¼ãƒ«ï¼ HPãŒ ${healAmount} å›å¾©`, "good");
      updateUI();
      endPlayerTurn();
    }

    function guard() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("æ²ˆé»™ä¸­ã§ã‚¹ã‚­ãƒ«ãŒä½¿ãˆãªã„ï¼", "warning");
        return;
      }
      if (player.mp < 2) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 2;
      player.buffs.guard = 2;
      log("ğŸ›¡ï¸ å®ˆã‚Šã‚’å›ºã‚ãŸï¼ æ¬¡ã®2ã‚¿ãƒ¼ãƒ³è¢«ãƒ€ãƒ¡è»½æ¸›", "good");
      updateUI();
      endPlayerTurn();
    }

    function boost() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("æ²ˆé»™ä¸­ã§ã‚¹ã‚­ãƒ«ãŒä½¿ãˆãªã„ï¼", "warning");
        return;
      }
      if (player.mp < 2) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 2;
      player.buffs.haste = 2;
      log("ğŸ’¨ ãƒ–ãƒ¼ã‚¹ãƒˆï¼ æ¬¡ã®2ã‚¿ãƒ¼ãƒ³è¡Œå‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—", "good");
      updateUI();
      endPlayerTurn();
    }

    function focus() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("æ²ˆé»™ä¸­ã§ã‚¹ã‚­ãƒ«ãŒä½¿ãˆãªã„ï¼", "warning");
        return;
      }
      if (player.mp < 3) {
        log("MPãŒè¶³ã‚Šãªã„ï¼", "warning");
        return;
      }
      player.mp -= 3;
      player.buffs.focus = 2;
      log("ğŸ¯ ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼ ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ã‚¢ãƒƒãƒ—", "good");
      updateUI();
      endPlayerTurn();
    }

    function enemyAction(enemy) {
      if (enemy.hp <= 0) return;
      const attacks = Math.max(0, Math.floor(enemy.attacksRemaining ?? enemy.attackCount ?? 0));
      if (attacks <= 0) return;
      enemy.attacksRemaining = attacks;
      for (let i = 0; i < attacks; i += 1) {
        const target = chooseTargetForEnemy(enemy);
        if (!target) return;
        const hit = attemptHit(enemy, target);
        const targetLabel = target === player ? "ã‚ãªãŸ" : target.name;
        if (!hit) {
          log(`â˜ ï¸ ${enemy.name} ã®æ”»æ’ƒ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}ã¯ ${targetLabel} ã«å½“ãŸã‚‰ãªã‹ã£ãŸ`, "info");
          continue;
        }
        const dmg = calcDamage(enemy, target);
        const isCrit = Math.random() < 0.12;
        const finalDmg = isCrit ? Math.round(dmg * 1.4) : dmg;
        const dealt = applyDamage(target, finalDmg, { source: enemy.name });
        const critText = isCrit ? " (ä¼šå¿ƒï¼)" : "";
        log(`â˜ ï¸ ${enemy.name} ã®æ”»æ’ƒ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}${critText}ï¼ ${targetLabel}ã« ${dealt} ãƒ€ãƒ¡ãƒ¼ã‚¸`, "enemy");
        if (player.hp <= 0) return;
        enemy.attacksRemaining = Math.max(0, attacks - i - 1);
      }
    }

    function nextTurn() {
      if (player.hp <= 0) {
        log("ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼", "danger");
        return;
      }
      if (game.turnQueue.length === 0) {
        buildTurnQueue();
      }
      const actor = game.turnQueue.shift();
      if (!actor) return;
      const entity = actor.type === "player" ? player : game.enemies.find(e => e.id === actor.id);
      if (!entity) {
        nextTurn();
        return;
      }

      const turnState = processTurnStart(entity);
      updateUI();

      if (entity.hp <= 0) {
        if (actor.type === "enemy") {
          log(`${entity.name} ã¯å€’ã‚ŒãŸ`, "good");
          checkVictory();
        } else {
          log("ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼", "danger");
        }
        setTimeout(() => nextTurn(), 380);
        return;
      }

      if (turnState.skipTurn) {
        finalizeTurn(entity);
        setTimeout(() => nextTurn(), 380);
        return;
      }

      if (actor.type === "player") {
        promptPlayerTurn();
        return;
      }
      enemyAction(entity);
      finalizeTurn(entity);
      updateUI();
      if (player.hp <= 0) return;
      setTimeout(() => nextTurn(), 380);
    }

    function checkVictory() {
      if (game.enemies.some(e => e.hp > 0)) return;
      const gained = 10 + game.floor * 3 + (game.floor % 5 === 0 ? 10 : 0);
      player.exp += gained;
      log(`ğŸ ${gained} EXP ã¨å°‘é‡ã®MPã‚’å¾—ãŸ`, "good");
      player.mp = Math.min(player.maxMp, player.mp + 3 + skills.arcaneFlow.level * 2);
      while (player.exp >= player.expToLevel) {
        player.exp -= player.expToLevel;
        levelUp();
      }
      game.awaitingInput = false;
      game.turnQueue = [];
      updateUI();
    }

    function levelUp() {
      player.level += 1;
      player.expToLevel = Math.round(player.expToLevel * 1.18);
      recalcDerivedStats();
      player.hp = player.maxHp;
      player.mp = player.maxMp;
      player.statPoints += 5;
      player.skillPoints += 1;
      log(`â¬†ï¸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv${player.level} èƒ½åŠ›P+5 / ã‚¹ã‚­ãƒ«P+1`, "good");
    }

    function resetAllocations() {
      const spent = pendingResetSpent;
      Object.entries(player.allocations).forEach(([key, amount]) => {
        if (amount > 0) {
          player.primary[key].base -= amount;
          player.allocations[key] = 0;
        }
      });
      player.statPoints += spent;
      recalcDerivedStats();
      updateUI();
      log("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ", "info");
      pendingResetSpent = 0;
    }

    function nextFloor() {
      if (game.enemies.some(e => e.hp > 0) && player.hp > 0) {
        log("æ•µãŒæ®‹ã£ã¦ã„ã‚‹ï¼", "warning");
        return;
      }
      game.floor += 1;
      player.buffs.guard = 0;
      game.turnQueue = [];
      spawnEnemies();
      updateUI();
    }

    document.getElementById("btn-skill-tree").addEventListener("click", openSkillsModal);
    document.getElementById("btn-player-modal").addEventListener("click", openPlayerModal);
    debugOpenButton?.addEventListener("click", openDebugModal);
    debugCloseButton?.addEventListener("click", closeDebugModal);
    closeModalButton.addEventListener("click", closeEnemyModal);
    potionModalCloseButton.addEventListener("click", closePotionModal);
    playerModalCloseButton.addEventListener("click", closePlayerModal);
    skillsModalCloseButton.addEventListener("click", closeSkillsModal);
    debugTargetSelect?.addEventListener("change", updateDebugTargetState);
    debugClearButton?.addEventListener("click", () => {
      const target = getDebugTarget();
      if (!target) {
        log("å¯¾è±¡ãŒå­˜åœ¨ã—ã¾ã›ã‚“", "warning");
        return;
      }
      target.statuses = [];
      log(`ğŸ ãƒ‡ãƒãƒƒã‚°: ${target.name} ã®çŠ¶æ…‹ç•°å¸¸ã‚’å…¨è§£é™¤`, "info");
      updateUI();
    });
    statHelpButton.addEventListener("click", () => {
      memoModal.classList.remove("hidden");
    });
    memoCloseButton.addEventListener("click", () => memoModal.classList.add("hidden"));
    memoModal.addEventListener("click", (e) => {
      if (e.target === memoModal) memoModal.classList.add("hidden");
    });

    statStepButton.addEventListener("click", () => {
      currentStepIndex = (currentStepIndex + 1) % stepOptions.length;
      updateStepButton();
      renderPrimaryStats();
    });

    resetButton.addEventListener("click", () => {
      pendingResetSpent = Object.values(player.allocations).reduce((a, b) => a + b, 0);
      if (pendingResetSpent === 0) {
        log("ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãƒã‚¤ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“", "info");
        return;
      }
      resetSpentLabel.textContent = pendingResetSpent;
      resetModal.classList.remove("hidden");
    });
    resetCloseButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetCancelButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetConfirmButton.addEventListener("click", () => {
      resetModal.classList.add("hidden");
      resetAllocations();
    });
    resetModal.addEventListener("click", (e) => {
      if (e.target === resetModal) resetModal.classList.add("hidden");
    });
    potionModal.addEventListener("click", (e) => {
      if (e.target === potionModal) closePotionModal();
    });
    resetSkillsButton.addEventListener("click", () => {
      const spent = Object.values(skills).reduce((sum, skill) => sum + skill.level, 0);
      if (spent === 0) {
        log("ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã‚¹ã‚­ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“", "info");
        return;
      }
      skillResetSpentLabel.textContent = spent;
      skillResetModal.classList.remove("hidden");
    });
    skillResetCloseButton.addEventListener("click", () => skillResetModal.classList.add("hidden"));
    skillResetCancelButton.addEventListener("click", () => skillResetModal.classList.add("hidden"));
    skillResetConfirmButton.addEventListener("click", () => {
      skillResetModal.classList.add("hidden");
      resetSkills();
    });
    skillResetModal.addEventListener("click", (e) => {
      if (e.target === skillResetModal) skillResetModal.classList.add("hidden");
    });
    enemyModal.addEventListener("click", (e) => {
      if (e.target === enemyModal) closeEnemyModal();
    });
    playerModal.addEventListener("click", (e) => {
      if (e.target === playerModal) closePlayerModal();
    });
    skillsModal.addEventListener("click", (e) => {
      if (e.target === skillsModal) closeSkillsModal();
    });
    debugModal?.addEventListener("click", (e) => {
      if (e.target === debugModal) closeDebugModal();
    });

    const initialDerived = recalcDerivedStats();
    renderSecondaryStats(initialDerived);
    log("=== æŒ‘æˆ¦é–‹å§‹ ===", "info");
    spawnEnemies();
    updateUI();
  </script>
</body>
</html>
