<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Á∏¶ÊåÅ„Å°„Éè„ÇØ„Çπ„É©Ë©¶‰Ωú</title>
  <link
    rel="icon"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%23111827'/%3E%3Ctext x='50%25' y='58%25' text-anchor='middle' font-size='44'%3E‚öîÔ∏è%3C/text%3E%3C/svg%3E"
  />
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #111827;
      --accent: #34d399;
      --accent-2: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: radial-gradient(circle at 20% 20%, rgba(52, 211, 153, 0.08), transparent 25%),
        radial-gradient(circle at 80% 10%, rgba(96, 165, 250, 0.08), transparent 22%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", "Hiragino Sans", system-ui, -apple-system, sans-serif;
      margin: 0;
      display: flex;
      justify-content: center;
      min-height: 100dvh;
      padding: 6px;
      overscroll-behavior-y: contain;
      overflow: hidden;
    }

    .phone {
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      width: min(460px, 100%);
      height: min(860px, calc(100dvh - 12px));
      max-height: calc(100dvh - 12px);
      display: grid;
      grid-template-rows: auto auto auto auto 1fr;
      gap: 6px;
      padding: 8px;
      padding-bottom: 12px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: relative;
    }

    .level-up-toast {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translate(-50%, -10px);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      border-radius: 12px;
      background: linear-gradient(120deg, rgba(52, 211, 153, 0.14), rgba(96, 165, 250, 0.12));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(52, 211, 153, 0.08);
      color: var(--text);
      pointer-events: none;
      opacity: 0;
      gap: 8px;
      z-index: 10;
    }

    .level-up-toast.show {
      animation: levelUpToast 1.9s ease-out forwards;
    }

    .level-up-toast .toast-glow {
      width: 8px;
      height: 40px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(52, 211, 153, 0.8), rgba(96, 165, 250, 0.7));
      filter: blur(1px) drop-shadow(0 0 8px rgba(52, 211, 153, 0.65));
      opacity: 0.9;
      animation: toastGlow 1.6s ease-in-out infinite;
    }

    .level-up-toast .toast-body {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .level-up-toast .toast-icon {
      font-size: 18px;
      filter: drop-shadow(0 2px 6px rgba(52, 211, 153, 0.6));
    }

    .level-up-toast .toast-text {
      display: grid;
      gap: 2px;
      line-height: 1.25;
    }

    .level-up-toast .toast-label {
      font-weight: 800;
      letter-spacing: 0.06em;
      font-size: 11px;
      color: #a5f3fc;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
    }

    .level-up-toast .toast-level {
      font-weight: 700;
      font-size: 14px;
      color: #fef3c7;
      text-shadow: 0 1px 6px rgba(0, 0, 0, 0.45);
    }

    .level-up-toast .toast-trail {
      position: absolute;
      inset: 4px;
      border-radius: 12px;
      background: radial-gradient(circle at 20% 50%, rgba(52, 211, 153, 0.35), transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(96, 165, 250, 0.35), transparent 50%);
      filter: blur(22px);
      opacity: 0;
      animation: toastTrail 1.4s ease-out forwards;
      pointer-events: none;
    }

    @keyframes levelUpToast {
      0% {
        opacity: 0;
        transform: translate(-50%, -6px) scale(0.96);
      }
      12% {
        opacity: 1;
        transform: translate(-50%, -2px) scale(1.04);
      }
      70% {
        opacity: 0.98;
        transform: translate(-50%, -8px) scale(1.02);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -22px) scale(1.02);
      }
    }

    @keyframes toastGlow {
      0%,
      100% {
        opacity: 0.75;
        transform: translateY(0);
      }
      50% {
        opacity: 1;
        transform: translateY(-4px);
      }
    }

    @keyframes toastTrail {
      0% {
        opacity: 0.6;
        transform: scale(0.9);
      }
      60% {
        opacity: 0.85;
        transform: scale(1.02);
      }
      100% {
        opacity: 0;
        transform: scale(1.08);
      }
    }

    .drop-toast {
      --drop-primary: #7c3aed;
      --drop-secondary: #22d3ee;
      --drop-highlight: #c084fc;
      --drop-primary-rgb: 124, 58, 237;
      --drop-secondary-rgb: 34, 211, 238;
      --drop-highlight-rgb: 192, 132, 252;
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translate(-50%, -10px) scale(0.96);
      display: grid;
      place-items: center;
      pointer-events: none;
      z-index: 30;
      opacity: 0;
      min-width: 320px;
    }

    .drop-toast.rare {
      --drop-primary: #7c3aed;
      --drop-secondary: #22d3ee;
      --drop-highlight: #c084fc;
      --drop-primary-rgb: 124, 58, 237;
      --drop-secondary-rgb: 34, 211, 238;
      --drop-highlight-rgb: 192, 132, 252;
    }

    .drop-toast.legendary {
      --drop-primary: #f59e0b;
      --drop-secondary: #f472b6;
      --drop-highlight: #fef08a;
      --drop-primary-rgb: 245, 158, 11;
      --drop-secondary-rgb: 244, 114, 182;
      --drop-highlight-rgb: 254, 240, 138;
    }

    .drop-toast.show {
      animation: dropToastEntrance 2.6s ease-out forwards;
    }

    .drop-toast .drop-toast-core {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px 12px 14px;
      border-radius: 16px;
      background: linear-gradient(
          120deg,
          rgba(var(--drop-primary-rgb), 0.28),
          rgba(var(--drop-secondary-rgb), 0.28)
        ),
        linear-gradient(145deg, rgba(11, 14, 20, 0.96), rgba(17, 24, 39, 0.9));
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45), 0 0 38px rgba(var(--drop-highlight-rgb), 0.35);
      overflow: hidden;
      isolation: isolate;
    }

    .drop-toast .drop-toast-core::before {
      content: "";
      position: absolute;
      inset: -50% -30%;
      background: conic-gradient(
        from 160deg,
        rgba(var(--drop-highlight-rgb), 0.08),
        rgba(var(--drop-highlight-rgb), 0.36),
        rgba(var(--drop-highlight-rgb), 0.08)
      );
      filter: blur(18px);
      animation: dropToastRays 2.8s linear infinite;
      z-index: 0;
    }

    .drop-toast .drop-toast-core::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(110deg, rgba(var(--drop-highlight-rgb), 0.14), transparent 58%);
      opacity: 0;
      animation: dropToastSweep 2s ease-out forwards;
      z-index: 1;
    }

    .drop-toast .drop-toast-glow {
      position: absolute;
      inset: -10px;
      background: radial-gradient(circle at 20% 20%, rgba(var(--drop-primary-rgb), 0.3), transparent 40%),
        radial-gradient(circle at 80% 70%, rgba(var(--drop-secondary-rgb), 0.3), transparent 42%),
        radial-gradient(circle at 50% 40%, rgba(var(--drop-highlight-rgb), 0.32), transparent 38%);
      filter: blur(16px);
      opacity: 0;
      animation: dropToastGlow 2.4s ease-out forwards;
      z-index: 0;
    }

    .drop-toast .drop-toast-body {
      position: relative;
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 12px;
      z-index: 2;
    }

    .drop-toast .drop-toast-icon {
      width: 42px;
      height: 42px;
      display: grid;
      place-items: center;
      border-radius: 12px;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.35), rgba(var(--drop-highlight-rgb), 0.2)),
        linear-gradient(135deg, var(--drop-primary), var(--drop-secondary));
      color: #0b0e14;
      font-size: 22px;
      box-shadow: 0 0 18px rgba(var(--drop-highlight-rgb), 0.55), 0 12px 28px rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.25);
      transform: scale(0.94);
      animation: dropToastPop 1.4s ease-out forwards;
    }

    .drop-toast .drop-text {
      display: grid;
      gap: 6px;
      line-height: 1.25;
    }

    .drop-toast .drop-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: linear-gradient(120deg, var(--drop-primary), var(--drop-secondary));
      color: #0b0e14;
      font-weight: 900;
      letter-spacing: 0.08em;
      font-size: 12px;
      text-transform: uppercase;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35), 0 0 18px rgba(var(--drop-highlight-rgb), 0.55);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .drop-toast .drop-item-name {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0.03em;
      color: var(--drop-highlight);
      background: linear-gradient(145deg, rgba(var(--drop-primary-rgb), 0.18), rgba(var(--drop-secondary-rgb), 0.22));
      border: 1px solid rgba(var(--drop-highlight-rgb), 0.55);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35), inset 0 0 22px rgba(var(--drop-highlight-rgb), 0.3);
      text-shadow: 0 3px 12px rgba(0, 0, 0, 0.4), 0 0 12px rgba(var(--drop-highlight-rgb), 0.7);
    }

    .drop-toast .drop-sparkles {
      position: absolute;
      inset: -12px;
      background: radial-gradient(circle at 30% 20%, rgba(var(--drop-primary-rgb), 0.35), transparent 36%),
        radial-gradient(circle at 70% 30%, rgba(var(--drop-secondary-rgb), 0.32), transparent 36%),
        radial-gradient(circle at 50% 70%, rgba(var(--drop-highlight-rgb), 0.38), transparent 40%);
      mix-blend-mode: screen;
      opacity: 0;
      animation: dropToastSparkle 2.6s ease-out forwards;
      z-index: 1;
    }

    .drop-toast .drop-ribbon {
      position: absolute;
      inset: -30%;
      background: conic-gradient(
        from 90deg,
        rgba(var(--drop-primary-rgb), 0.4),
        rgba(var(--drop-secondary-rgb), 0.08),
        rgba(var(--drop-highlight-rgb), 0.35),
        rgba(var(--drop-primary-rgb), 0.12)
      );
      filter: blur(22px);
      opacity: 0.85;
      transform: rotate(12deg);
      animation: dropToastRibbon 3s ease-in-out infinite;
      z-index: 0;
    }

    @keyframes dropToastEntrance {
      0% {
        opacity: 0;
        transform: translate(-50%, -6px) scale(0.9);
      }
      18% {
        opacity: 1;
        transform: translate(-50%, -1px) scale(1.04);
      }
      60% {
        opacity: 1;
        transform: translate(-50%, -6px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -18px) scale(1);
      }
    }

    @keyframes dropToastGlow {
      0% {
        opacity: 0.4;
        transform: scale(0.92);
      }
      30% {
        opacity: 0.9;
        transform: scale(1.03);
      }
      70% {
        opacity: 0.85;
        transform: scale(1.02);
      }
      100% {
        opacity: 0;
        transform: scale(1.08);
      }
    }

    @keyframes dropToastRays {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(1turn);
      }
    }

    @keyframes dropToastSweep {
      0% {
        opacity: 0;
        transform: translateX(-28%);
      }
      35% {
        opacity: 0.6;
        transform: translateX(6%);
      }
      100% {
        opacity: 0;
        transform: translateX(26%);
      }
    }

    @keyframes dropToastPop {
      0% {
        opacity: 0;
        transform: scale(0.6) rotate(-10deg);
      }
      35% {
        opacity: 1;
        transform: scale(1.08) rotate(4deg);
      }
      70% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: scale(1) translateY(-6px);
      }
    }

    @keyframes dropToastSparkle {
      0% {
        opacity: 0;
        filter: blur(14px);
      }
      25% {
        opacity: 0.9;
        filter: blur(10px);
      }
      60% {
        opacity: 0.6;
        filter: blur(12px);
      }
      100% {
        opacity: 0;
        filter: blur(16px);
      }
    }

    @keyframes dropToastRibbon {
      0%,
      100% {
        transform: rotate(12deg) scale(0.96);
        opacity: 0.9;
      }
      50% {
        transform: rotate(0deg) scale(1.02);
        opacity: 0.75;
      }
    }

.phone.player-down::after {
  content: "Êà¶Èóò‰∏çËÉΩ";
  top:15px;
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  font-weight: 900;
  font-size: 32px;
  color: rgba(248, 113, 113, 0.8);
  background: radial-gradient(circle, rgba(15, 23, 42, 0.55), rgba(15, 23, 42, 0.92));
  text-shadow: 0 3px 16px rgba(0, 0, 0, 0.6);
  pointer-events: none;

  /* ‚òÖ„Åì„Åì„Å†„ÅëÂ§âÊõ¥ÔºöÁü≠„ÇÅ„ÅÆ„Éï„Çß„Éº„Éâ„Ç§„É≥ */
  animation: playerDownOverlay 0.9s ease-out forwards;
}
@keyframes playerDownOverlay {
  0% {
    opacity: 0;
    transform: scale(1.04);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}


    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px;
    }

    .subtle {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .bars {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 22px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    @keyframes barPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(252, 165, 165, 0.6);
      }
      100% {
        box-shadow: 0 0 0 12px rgba(252, 165, 165, 0);
      }
    }

    .gold-pill {
      margin-left: auto;
      background: rgba(234, 179, 8, 0.14);
      border: 1px solid rgba(234, 179, 8, 0.28);
      color: #fef3c7;
      font-weight: 800;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .bar span {
      position: absolute;
      inset: 0;
      width: 50%;
      border-radius: 999px;
      transition: width 0.28s ease;
    }

    .bar.flash {
      animation: barPulse 0.5s ease;
    }

    .bar .label {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .bar .hp {
      background: #ef4444;
    }

    .bar .mp {
      background: #3b82f6;
    }

    .bar .exp {
      background: #facc15;
    }

    #log {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.5;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: clamp(180px, 40vh, 320px);
      max-height: clamp(180px, 40vh, 320px);
      resize: none;
    }

    .log-card {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    #log .entry {
      opacity: 0.95;
      padding: 4px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
      animation: logEnter 0.26s ease;
    }

    #log .entry.info {
      color: #e5e7eb;
    }

    #log .entry.player {
      color: #93c5fd;
    }

    #log .entry.enemy {
      color: #fca5a5;
    }

    #log .entry.good {
      color: #6ee7b7;
    }

    #log .entry.warning {
      color: #fcd34d;
    }

    #log .entry.danger {
      color: #fb7185;
    }

    @keyframes logEnter {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    button {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.2), rgba(96, 165, 250, 0.2));
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu {
      display: flex;
      justify-content: space-around;
      gap: 6px;
      padding: 8px;
      background: rgba(17, 24, 39, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      margin-top: 4px;
    }

    .pill {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.06);
      padding: 4px 8px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .tag {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      letter-spacing: 0.03em;
    }

    .tag.clickable {
      cursor: pointer;
      border: 1px solid rgba(96, 165, 250, 0.5);
      background: rgba(96, 165, 250, 0.12);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
    }

    #inventory-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 60vh;
      overflow-y: auto;
      padding-right: 4px;
    }

    .inventory-filter-grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 6px;
      margin-top: 8px;
    }

    .inventory-filter-button {
      font-size: 12px;
      padding: 8px 6px;
      line-height: 1.1;
    }

    .inventory-filter-button.active {
      border-color: rgba(52, 211, 153, 0.7);
      box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.35);
    }

    .inventory-row {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      transition: background 0.1s ease;
      text-align: left;
    }

    .inventory-row:hover {
      background: rgba(255, 255, 255, 0.07);
    }

    .inventory-row:active {
      transform: translateY(1px);
    }

    .inventory-row .name {
      font-weight: 700;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .equip-badge {
      color: var(--accent);
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .favorite-badge {
      color: #fcd34d;
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
    }

    .inline-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .rarity-normal {
      color: #e5e7eb;
    }

    .rarity-magic {
      color: #60a5fa;
    }

    .rarity-rare {
      color: #fcd34d;
    }

    .rarity-legendary {
      color: #b45309;
    }

    .stat-diff-list {
      display: grid;
      gap: 4px;
      margin-top: 4px;
    }

    .stat-diff {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      padding: 6px 8px;
      font-weight: 700;
    }

    .stat-diff.positive {
      color: #34d399;
    }

    .stat-diff.negative {
      color: #f87171;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 5px;
      margin-top: 2px;
    }

    .primary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-top: 4px;
      align-items: start;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      padding: 5px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-label {
      display: grid;
      gap: 2px;
      font-size: 12px;
      color: var(--muted);
    }

    .stat-label.secondary {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      white-space: nowrap;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .stat-value {
      font-weight: 700;
      font-size: 13px;
      text-align: right;
    }

    .stat-value .total {
      font-weight: 800;
    }

    .stat-value .base {
      color: var(--muted);
      font-weight: 600;
    }

    .stat-value .bonus {
      color: var(--accent);
      font-weight: 800;
    }

    .stat-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .primary-row {
      align-items: center;
    }

    .primary-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      min-width: 0;
    }

    .primary-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      align-items: center;
    }

    .primary-actions .mini-btn {
      padding: 6px 10px;
      font-size: 12px;
      min-width: 50px;
    }

    .stat-label.inline {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .step-button {
      min-width: 78px;
      padding: 8px 10px;
      font-size: 12px;
    }

    .enemy-list {
      display: grid;
      grid-template-columns: repeat(var(--enemy-columns, 3), minmax(0, 1fr));
      gap: 6px;
      font-size: 13px;
      padding-bottom: 2px;
    }

    .enemy-card {
      display: grid;
      gap: 6px;
      padding: 9px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.08s ease, border-color 0.12s ease, box-shadow 0.12s ease;
      min-width: 0;
      position: relative;
      overflow: hidden;
    }

    .enemy-card:active {
      transform: translateY(1px);
    }

    .enemy-card:hover {
      border-color: rgba(255, 255, 255, 0.16);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }

    .attack-badge {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(52, 211, 153, 0.18);
      border: 1px solid rgba(52, 211, 153, 0.5);
      color: #ecfdf3;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      line-height: 1.2;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .enemy-bar.pulse {
      animation: barPulse 0.5s ease;
    }

    .attack-badge.enemy {
      background: rgba(248, 113, 113, 0.15);
      border-color: rgba(248, 113, 113, 0.4);
      color: #fee2e2;
    }

    .damage-popup {
      position: absolute;
      left: 50%;
      top: 8px;
      transform: translate(-50%, 0);
      font-weight: 800;
      font-size: 14px;
      letter-spacing: 0.01em;
      pointer-events: none;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.45);
      opacity: 0;
      animation: damageFloat 0.8s ease forwards;
      z-index: 5;
    }

    .damage-popup.player {
      color: #fecdd3;
    }

    .damage-popup.enemy {
      color: #bbf7d0;
    }

    .damage-popup.mp {
      color: #bfdbfe;
    }

    @keyframes damageFloat {
      0% {
        opacity: 0;
        transform: translate(-50%, 6px) scale(0.95);
      }
      25% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -16px) scale(1.04);
      }
    }

    /*
    @keyframes enemyDefeated {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      to {
        opacity: 0.45;
        transform: translateY(4px) scale(0.97);
      }
    }
    */

    .enemy-card.defeated {
      filter: grayscale(0.75);
      position: relative;
      animation: enemyDefeated 0.5s ease forwards;
    }

    .enemy-card.defeated::after {
      content: "‚úñ";
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 48px;
      color: rgba(248, 113, 113, 0.6);
      pointer-events: none;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .cooldown-badge {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(96, 165, 250, 0.18);
      border: 1px solid rgba(96, 165, 250, 0.5);
      color: #dbeafe;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      line-height: 1.2;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .action-button-wrapper {
      position: relative;
    }

    .action-button-wrapper button {
      width: 100%;
      height: 100%;
    }

    .actions-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      align-items: stretch;
    }

    .potion-row {
      height: 100%;
    }

    .potion-button {
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.22), rgba(96, 165, 250, 0.15));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px;
      height: 100%;
    }

    .potion-icon {
      font-size: 16px;
      width: 28px;
      height: 28px;
      display: grid;
      place-items: center;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      flex-shrink: 0;
    }

    .potion-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 8px;
      font-size: 12px;
    }

    .potion-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .potion-short {
      font-weight: 700;
      font-size: 13px;
    }

    .potion-fill {
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .potion-info-button {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      padding: 0;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.08);
      flex-shrink: 0;
    }

    .skill-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px;
      text-align: left;
    }

    .skill-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .skill-name {
      font-weight: 700;
      font-size: 13px;
    }

    .enemy-top {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .enemy-name {
      display: grid;
      gap: 2px;
      font-weight: 600;
    }

    .enemy-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
      font-size: 11px;
    }

    .enemy-bar {
      position: relative;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      height: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .enemy-bar .fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ef4444, #f87171);
      width: 50%;
      border-radius: 999px;
      transition: width 0.28s ease;
    }

    .enemy-bar .label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      line-height: 1;
      color: #f8fafc;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      pointer-events: none;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 50;
    }

    #reset-modal,
    #skill-reset-modal {
      z-index: 60;
    }

    .hidden {
      display: none !important;
    }

    .modal.hidden {
      display: none;
    }

    .debug-tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }

    .tab-button {
      flex: 1;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.06);
      color: #e2e8f0;
      border-radius: 8px;
      font-weight: 700;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .tab-button.active {
      background: rgba(52, 211, 153, 0.15);
      border-color: rgba(52, 211, 153, 0.45);
      color: #f8fafc;
      box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.35);
    }

    .debug-tab-button {
      flex: 1;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 8px;
      font-weight: 700;
    }

    .debug-tab-button.active {
      border-color: rgba(52, 211, 153, 0.6);
      box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.3);
    }

    .debug-tab-panel.hidden {
      display: none;
    }

    .save-slot-list {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }

    .save-slot-card {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      padding: 10px;
      display: grid;
      gap: 6px;
    }

    .save-slot-card.active {
      border-color: rgba(52, 211, 153, 0.6);
      box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.24);
    }

    .save-slot-header {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: baseline;
    }

    .save-slot-title {
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    .save-slot-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .save-slot-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .save-slot-actions button {
      flex: 1;
      min-width: 120px;
      font-size: 12px;
      padding: 8px;
    }

    .save-slot-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
    }

    .equipment-option-list {
      display: grid;
      gap: 4px;
      margin-top: 6px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      padding: 8px;
    }

    .equipment-option-list .option-label {
      font-size: 12px;
      color: var(--muted);
    }

    .equipment-option-list .option-value {
      font-weight: 700;
    }

    .modal-content {
      width: min(420px, 94%);
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
      max-height: 88vh;
      overflow-y: auto;
    }

    .inventory-modal-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .player-modal-content {
      display: flex;
      flex-direction: column;
      max-height: 88vh;
      overflow: hidden;
      gap: 6px;
    }

    .secondary-scroll {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding-right: 4px;
      margin-bottom: 4px;
    }

    .primary-fixed {
      flex-shrink: 0;
      display: grid;
      gap: 8px;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    .help-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      font-weight: 800;
      cursor: pointer;
    }

    .help-panel {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      line-height: 1.5;
    }

    .modal-body-title {
      font-weight: 700;
      margin-bottom: 6px;
    }

    .help-panel ul {
      padding-left: 16px;
      margin: 6px 0;
    }

    .modal-close {
      border: none;
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      border-radius: 999px;
      width: 30px;
      height: 30px;
      cursor: pointer;
    }

    .status-list {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
      min-height: 18px;
    }

    .status-pill {
      font-size: 10px;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.05);
      color: #e5e7eb;
      cursor: pointer;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    .status-pill.control {
      border-color: rgba(255, 99, 132, 0.4);
      background: rgba(248, 113, 113, 0.12);
    }

    .status-pill.dot {
      border-color: rgba(74, 222, 128, 0.35);
      background: rgba(34, 197, 94, 0.12);
    }

    .status-pill.debuff {
      border-color: rgba(96, 165, 250, 0.35);
      background: rgba(59, 130, 246, 0.12);
    }

    .status-popover {
      position: fixed;
      inset: auto 12px 20px 12px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 10px;
      color: var(--text);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      z-index: 70;
      max-width: 460px;
      margin: 0 auto;
    }

    .status-popover.hidden {
      display: none;
    }

    .status-popover .title {
      font-weight: 800;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-popover .body {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .debug-selects {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin: 6px 0 4px;
    }

    .debug-selects label {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .debug-selects input {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      padding: 6px;
      color: var(--text);
      width: 96px;
    }

    .debug-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .debug-section {
      margin-top: 8px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .debug-section h4 {
      margin: 0 0 6px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.04em;
    }

  </style>
</head>
<body>
  <div class="phone">
    <section class="card log-card">
      <div id="log"></div>
    </section>

    <section class="card">
      <div id="enemies" class="enemy-list"></div>
    </section>

    <section class="card">
      <div class="subtle" style="justify-content: flex-start; gap: 10px; margin-bottom: 4px;">
        <span>LV <span id="level"></span></span>
        <div id="player-status-list" class="status-list" aria-label="„Éó„É¨„Ç§„É§„ÉºÁä∂ÊÖã"></div>
        <span class="pill">ÈöéÂ±§ <span id="floor-inline"></span>F</span>
        <span class="pill gold-pill">üí∞ <span id="gold"></span>G</span>
      </div>
      <div class="bars">
        <div class="bar">
          <span id="hp-bar" class="hp"></span>
          <span id="hp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="mp-bar" class="mp"></span>
          <span id="mp-label" class="label"></span>
        </div>
        <div class="bar">
          <span id="exp-bar" class="exp"></span>
          <span id="exp-label" class="label"></span>
        </div>
      </div>
    </section>

    <section class="card">
      <div id="actions"></div>
    </section>

    <nav class="menu">
      <button id="btn-player-modal">„Éó„É¨„Ç§„É§„ÉºË©≥Á¥∞</button>
      <button id="btn-skill-tree">„Çπ„Ç≠„É´</button>
      <button id="btn-inventory">„Ç¢„Ç§„ÉÜ„É†</button>
      <button id="btn-debug">„Éá„Éê„ÉÉ„Ç∞</button>
    </nav>

    <div id="level-up-toast" class="level-up-toast" aria-hidden="true">
      <div class="toast-glow"></div>
      <div class="toast-body">
        <span class="toast-icon" aria-hidden="true">‚ú®</span>
        <div class="toast-text">
          <div class="toast-label">LEVEL UP</div>
          <div class="toast-level">Lv <span id="level-up-value"></span> „Å´Âà∞ÈÅî</div>
        </div>
      </div>
      <div class="toast-trail"></div>
    </div>

    <div id="drop-celebration" class="drop-toast" aria-hidden="true">
      <div class="drop-toast-core">
        <div class="drop-toast-glow"></div>
        <div class="drop-toast-body">
          <div class="drop-toast-icon" aria-hidden="true">üíé</div>
          <div class="drop-text">
            <div id="drop-pill" class="drop-pill">RARE DROP</div>
            <div id="drop-item-name" class="drop-item-name"></div>
          </div>
        </div>
        <div class="drop-sparkles"></div>
        <div class="drop-ribbon"></div>
      </div>
    </div>
  </div>

  <div id="enemy-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">Êïµ„ÅÆË©≥Á¥∞</div>
          <div id="modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="modal-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>HP <span id="modal-hp"></span></div>
        <div>ATK <span id="modal-atk"></span></div>
        <div>DEF <span id="modal-def"></span></div>
        <div>SPD <span id="modal-spd"></span></div>
      </div>
      <div class="pill" id="modal-tag" style="margin-top: 10px; display: inline-flex;">BOSS</div>
    </div>
  </div>

  <div id="archetype-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Ç¢„Éº„Ç≠„Çø„Ç§„ÉóË©≥Á¥∞</div>
          <div id="archetype-modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="archetype-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="help-panel" id="archetype-modal-desc" style="margin-top: 10px;"></div>
      <div class="option-label" style="margin-top: 10px;">‰ªò‰∏éËÉΩÂäõ</div>
      <div id="archetype-modal-abilities" class="option-value"></div>
    </div>
  </div>

  <div id="potion-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Éù„Éº„Ç∑„Éß„É≥Ë©≥Á¥∞</div>
          <div id="potion-modal-name" style="font-weight: 700;"></div>
        </div>
        <button id="potion-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>Á®ÆÈ°û <span id="potion-modal-type"></span></div>
        <div>ÂäπÊûú <span id="potion-modal-effect"></span></div>
        <div>Ê∂àË≤ª <span id="potion-modal-cost"></span></div>
        <div>ÊÆãÈáè <span id="potion-modal-fill"></span></div>
      </div>
      <div class="help-panel" style="margin-top: 10px;">
        Êïµ„ÇíÂÄí„Åô„Å®Â∞ë„Åó„Åö„Å§Ë£úÂÖÖ„Åï„Çå„Åæ„Åô„ÄÇ
      </div>
    </div>
  </div>

  <div id="skill-info-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Çπ„Ç≠„É´Ë©≥Á¥∞</div>
          <div id="skill-info-name" style="font-weight: 700;"></div>
        </div>
        <button id="skill-info-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="stats" style="margin-top: 10px;">
        <div>Á®ÆÈ°û <span id="skill-info-type"></span></div>
        <div>CT <span id="skill-info-cooldown"></span></div>
        <div>ÁøíÂæóÁä∂Ê≥Å <span id="skill-info-level"></span></div>
        <div>ÂäπÊûú <span id="skill-info-effect"></span></div>
      </div>
      <div class="help-panel" id="skill-info-note" style="margin-top: 10px;"></div>
    </div>
  </div>

  <div id="player-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content player-modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Éó„É¨„Ç§„É§„ÉºË©≥Á¥∞</div>
        </div>
        <button id="player-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="secondary-scroll">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
          <div class="section-title" style="margin: 8px 0 4px;">‰∫åÊ¨°„Çπ„ÉÜ„Éº„Çø„Çπ</div>
          <button class="help-icon" id="stat-help" aria-label="Ë®àÁÆóÂºè„É°„É¢">Ôºü</button>
        </div>
        <div id="secondary-stats" class="stat-grid"></div>
      </div>
      <div class="primary-fixed">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
          <div class="section-title" style="margin: 2px 0 4px;">‰∏ÄÊ¨°„Çπ„ÉÜ„Éº„Çø„Çπ</div>
          <div style="display: flex; align-items: center; gap: 6px;">
              <div class="inline-buttons">
                <div class="pill">ËÉΩÂäõP: <span id="stat-points"></span></div>
              </div>
            <button id="stat-step" class="step-button" aria-label="Â¢óÊ∏õÂπÖ„ÇíÂàá„ÇäÊõø„Åà">¬±1</button>
            <button id="reset-stats" class="help-icon" aria-label="„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„É™„Çª„ÉÉ„Éà">‚Ü∫</button>
          </div>
        </div>
        <div id="primary-stats" class="primary-grid"></div>
      </div>
    </div>
  </div>

  <div id="memo-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">Ë®àÁÆó„É°„É¢</div>
        <button id="memo-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="modal-body-title">ÊîªÊíÉ„ÉªÈò≤Âæ°</div>
      <div class="help-panel">
        <ul>
          <li>Áâ©ÁêÜÊîªÊíÉÂäõ = Ê≠¶Âô® + Âäõ √ó 1.2</li>
          <li>È≠îÊ≥ïÊîªÊíÉÂäõ = È≠îÂô® + Áü•Ë≠ò √ó 1.3</li>
          <li>Áâ©ÁêÜÈò≤Âæ°Âäõ = ‰ΩìÂäõ√ó0.6 + Âäõ√ó0.2</li>
          <li>È≠îÊ≥ïÈò≤Âæ°Âäõ = ‰ΩìÂäõ√ó0.5 + Áü•Ë≠ò√ó0.3</li>
          <li>Áâ©ÁêÜË≤´ÈÄö = Âäõ„Å´„Çà„ÇãËªΩÊ∏õÁÑ°Ë¶ñ (‰∏äÈôê30%)</li>
          <li>È≠îÊ≥ïË≤´ÈÄö = Áü•Ë≠ò„Å´„Çà„ÇãËªΩÊ∏õÁÑ°Ë¶ñ (‰∏äÈôê30%)</li>
          <li>Ë¢´„ÉÄ„É°„Éº„Ç∏ËªΩÊ∏õ = ‰ΩìÂäõÁî±Êù•„ÅÆËªΩÊ∏õ (‰∏äÈôê40%)</li>
          <li>„Éñ„É≠„ÉÉ„ÇØÁéá = ‰ΩìÂäõ„Éô„Éº„Çπ (‰∏äÈôê25%)</li>
        </ul>
      </div>
      <div class="modal-body-title">Ë°åÂãï„Éª‰ºöÂøÉ</div>
      <div class="help-panel">
        <ul>
          <li>Ë°åÂãïÈÄüÂ∫¶ = Âü∫Á§éÈÄüÂ∫¶ + ÊïèÊç∑</li>
          <li>ÂëΩ‰∏≠Áéá = 70% + ÊïèÊç∑√ó0.1%</li>
          <li>„ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá / ÂõûÈÅøÁéá = (ÊïèÊç∑+ÈÅã) Ê∏õË°∞Âºè</li>
          <li>„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„ÉÄ„É°„Éº„Ç∏ = 150% + „ÇØ„É™„ÉÄ„É°%</li>
          <li>„ÇØ„Éº„É´„Çø„Ç§„É†Áü≠Á∏Æ = ÊïèÊç∑/Áü•Ë≠òÁî±Êù• (‰∏äÈôê20%)</li>
        </ul>
      </div>
      <div class="modal-body-title">ÊäµÊäó„ÉªË£úÂä©„Éª„Éè„ÇØ„Çπ„É©</div>
      <div class="help-panel">
        <ul>
          <li>Ë°åÂãïÈòªÂÆ≥ÊäµÊäó / DoTÊäµÊäó / Âº±‰ΩìÂåñÊäµÊäó = ‰ΩìÂäõÔºãÂêÑÁ®Æ„Çπ„ÉÜÁî±Êù• (‰∏äÈôê60%)</li>
          <li>HPÂÜçÁîü = ‰ΩìÂäõ √ó 0.2 / „Çø„Éº„É≥</li>
          <li>HPÂê∏Âèé = ‰∏é„ÉÄ„É° √ó Âê∏Âèé%</li>
          <li>„Éê„É™„Ç¢ = ‰ΩìÂäõ√ó2 + Áü•Ë≠ò√ó1</li>
          <li>„Éâ„É≠„ÉÉ„ÉóÁéáUP / „É¨„Ç¢„É™„ÉÜ„Ç£UP = ÈÅã„Å´„Çà„ÇãÊ∏õË°∞Âºè (‰∏äÈôê„ÅÇ„Çä)</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="reset-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„É™„Çª„ÉÉ„Éà</div>
        <button id="reset-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div>ÊåØ„ÇäÂàÜ„Åë„Åü„Éù„Ç§„É≥„Éà(<span id="reset-spent"></span>P)„ÇíÊàª„Åó„Åæ„Åô„ÄÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü</div>
      <div class="modal-actions">
        <button id="reset-cancel">„Ç≠„É£„É≥„Çª„É´</button>
        <button id="reset-confirm">„É™„Çª„ÉÉ„Éà„Åô„Çã</button>
      </div>
    </div>
  </div>

  <div id="skill-reset-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">„Çπ„Ç≠„É´„Çí„É™„Çª„ÉÉ„Éà</div>
        <button id="skill-reset-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div>ÁøíÂæó„Åó„Åü„Éù„Ç§„É≥„Éà(<span id="skill-reset-spent"></span>P)„ÇíÊàª„Åó„Åæ„Åô„ÄÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü</div>
      <div class="modal-actions">
        <button id="skill-reset-cancel">„Ç≠„É£„É≥„Çª„É´</button>
        <button id="skill-reset-confirm">„É™„Çª„ÉÉ„Éà„Åô„Çã</button>
      </div>
    </div>
  </div>

  <div id="skills-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Çπ„Ç≠„É´ / „Éë„Éº„ÇØ</div>
          <div style="font-weight: 700;">„Çπ„Ç≠„É´„Éù„Ç§„É≥„Éà„ÇíÊ∂àË≤ª„Åó„Å¶Âº∑Âåñ</div>
        </div>
        <button id="skills-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="inline-buttons" style="margin-bottom: 6px; align-items: center;">
        <div class="pill">„Çπ„Ç≠„É´P: <span id="skill-points-skill"></span></div>
        <button id="skill-step" class="step-button" aria-label="„Çπ„Ç≠„É´Â¢óÊ∏õÂπÖ„ÇíÂàá„ÇäÊõø„Åà">¬±1</button>
        <button id="reset-skills" class="help-icon" aria-label="„Çπ„Ç≠„É´„Çí„É™„Çª„ÉÉ„Éà">‚Ü∫</button>
      </div>
      <div class="inline-buttons" style="margin-bottom: 6px; align-items: center;">
        <button id="skill-summary-toggle" class="mini-btn" aria-pressed="false">ÂÖ®ËÅ∑Ê•≠‰∏ÄË¶ß„ÇíË°®Á§∫</button>
      </div>
      <div class="inline-buttons" id="skill-category-tabs" style="margin-bottom: 4px;"></div>
      <div class="inline-buttons" id="skill-type-tabs" style="margin-bottom: 6px;"></div>
      <div id="skill-detail-view">
        <div id="active-skill-loadout" class="help-panel" style="margin-bottom: 6px;"></div>
        <div id="skills" style="margin-top: 6px;"></div>
      </div>
    </div>
  </div>

  <div id="skill-summary-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">ÂÖ®ËÅ∑Ê•≠„Çπ„Ç≠„É´‰∏ÄË¶ß</div>
          <div style="font-weight: 700;">ÂèñÂæó„É¨„Éô„É´„Å®ÁøíÂæóÁä∂Ê≥Å„Çí„Åæ„Å®„ÇÅ„Å¶Á¢∫Ë™ç</div>
        </div>
        <button id="skill-summary-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div id="skill-summary-body">
        <div id="skills-summary" style="margin-top: 6px;"></div>
      </div>
    </div>
  </div>

  <div id="inventory-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content inventory-modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Ç§„É≥„Éô„É≥„Éà„É™</div>
          <div style="font-weight: 700;">ÊâÄÊåÅ„Ç¢„Ç§„ÉÜ„É†„ÅÆÁ¢∫Ë™ç</div>
        </div>
        <button id="inventory-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div id="inventory-list" class="stats"></div>
      <div id="inventory-filters" class="inventory-filter-grid"></div>
    </div>
  </div>

  <div id="inventory-item-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div class="section-title" style="margin: 0;">„Ç¢„Ç§„ÉÜ„É†Ë©≥Á¥∞</div>
          <div id="inventory-item-name" style="font-weight: 700;"></div>
        </div>
        <button id="inventory-item-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
        <div id="inventory-item-desc" class="body" style="margin-top: 6px;"></div>
        <div id="inventory-item-meta" class="subtle" style="margin: 8px 0 4px;"></div>
        <div
          id="inventory-item-detail"
          class="stats"
          style="grid-template-columns: repeat(2, minmax(0, 1fr)); margin-top: 6px;"
        ></div>
        <div id="inventory-compare-result" class="equipment-option-list" style="margin-top: 8px; display: none;"></div>
        <div id="inventory-item-actions" class="inline-buttons" style="margin-top: 10px;"></div>
    </div>
  </div>

  <div id="debug-modal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="section-title" style="margin: 0;">„Éá„Éê„ÉÉ„Ç∞</div>
        <button id="debug-close" class="modal-close" aria-label="Èñâ„Åò„Çã">√ó</button>
      </div>
      <div class="debug-tabs">
        <button class="debug-tab-button active" data-tab="status">Áä∂ÊÖãÁï∞Â∏∏</button>
        <button class="debug-tab-button" data-tab="equipment">Ë£ÖÂÇôÁîüÊàê</button>
        <button class="debug-tab-button" data-tab="adjust">Êï∞ÂÄ§</button>
        <button class="debug-tab-button" data-tab="save">„Çª„Éº„Éñ</button>
      </div>
      <div id="debug-tab-status" class="debug-tab-panel">
        <div class="debug-selects">
          <label>
            ÂØæË±°:
            <select id="debug-target">
              <option value="enemy">Êïµ</option>
              <option value="player">„Éó„É¨„Ç§„É§„Éº</option>
            </select>
          </label>
          <label>
            ÊïµÈÅ∏Êäû:
            <select id="debug-enemy"></select>
          </label>
        </div>
        <div id="debug-status-buttons"></div>
        <div class="modal-actions">
          <button id="debug-clear-status">ÈÅ∏ÊäûÂØæË±°„ÅÆÁä∂ÊÖãÁï∞Â∏∏„ÇíÂÖ®Ëß£Èô§</button>
        </div>
      </div>
      <div id="debug-tab-equipment" class="debug-tab-panel hidden">
        <div class="debug-selects">
          <label>
            ÈÉ®‰Ωç:
            <select id="debug-gear-slot"></select>
          </label>
          <label>
            „É¨„Ç¢Â∫¶:
            <select id="debug-gear-rarity"></select>
          </label>
        </div>
        <div id="debug-legendary-wrapper" class="debug-selects hidden">
          <label>
            „É¨„Ç∏„Çß„É≥„ÉâË£ÖÂÇô:
            <select id="debug-legendary-template"></select>
          </label>
        </div>
        <div id="debug-gear-preview" class="equipment-option-list">
          <div class="option-label">„Éó„É¨„Éì„É•„Éº„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô</div>
        </div>
        <div class="modal-actions">
          <button id="debug-generate-gear">Ë£ÖÂÇôÂìÅ„Çí‰ΩúÊàê„Åó„Å¶ËøΩÂä†</button>
          <button id="debug-generate-gear-random">„É©„É≥„ÉÄ„É†‰ΩúÊàê</button>
        </div>
      </div>
      <div id="debug-tab-adjust" class="debug-tab-panel hidden">
        <div class="debug-section">
          <h4>„Éó„É¨„Ç§„É§„ÉºË™øÊï¥</h4>
          <div class="debug-selects">
            <label>
              „É¨„Éô„É´:
              <input id="debug-level-input" type="number" min="1" step="1" inputmode="numeric" />
            </label>
            <button id="debug-apply-level">ÂèçÊò†</button>
          </div>
          <div class="debug-selects">
            <label>
              HP:
              <input id="debug-hp-input" type="number" min="0" step="1" inputmode="numeric" />
            </label>
            <button id="debug-apply-hp">ÂèçÊò†</button>
          </div>
        </div>
        <div class="debug-section">
          <h4>ÈöéÂ±§Ë™øÊï¥</h4>
          <div class="debug-selects">
            <label>
              ÈöéÂ±§:
              <input id="debug-floor-input" type="number" min="1" step="1" inputmode="numeric" />
            </label>
            <button id="debug-apply-floor">ÁßªÂãï</button>
          </div>
        </div>
        <div class="modal-actions">
          <button id="debug-new-run">Êñ∞„Åó„ÅèÂßã„ÇÅ„Çã</button>
        </div>
      </div>
      <div id="debug-tab-save" class="debug-tab-panel hidden">
        <div class="help-panel">
          <div class="option-label">ÂÜóÈï∑„Çª„Éº„Éñ („É≠„Éº„Ç´„É´‰øùÂ≠ò + Ëá™Âãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó)</div>
          <div class="option-value">ÂêÑ„Çπ„É≠„ÉÉ„Éà„ÅØ‰øùÂ≠ò„Åî„Å®„Å´ÊúÄÊñ∞„Éá„Éº„Çø„Å®„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Çí2Èáç„ÅßË®òÈå≤„Åó„Åæ„Åô„ÄÇ</div>
        </div>
        <div id="save-slot-list" class="save-slot-list"></div>
        <div class="subtle">
          <span>„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅØ‰øùÂ≠òÊôÇ„Å´Ëá™ÂãïÊõ¥Êñ∞</span>
          <span>JSON„Ç≥„Éî„Éº„ÅßÊâãÂãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÇÇÂèØËÉΩ</span>
        </div>
      </div>
    </div>
  </div>

  <div id="status-popover" class="status-popover hidden" role="status" aria-live="polite">
    <div class="title">
      <span id="status-popover-name"></span>
      <span id="status-popover-turns" class="pill" style="background: rgba(255,255,255,0.08);"></span>
    </div>
    <div id="status-popover-desc" class="body"></div>
  </div>

  <script>
    (() => {
      if (window.__HAKUSURA_BOOTED__) return;
      window.__HAKUSURA_BOOTED__ = true;

    const STATUS_DEFINITIONS = {
        stun: { name: "„Çπ„Çø„É≥", short: "STN", category: "control", description: "Ë°åÂãïÂÆåÂÖ®‰∏çËÉΩÔºàÈÄöÂ∏∏ÊîªÊíÉ„Éª„Çπ„Ç≠„É´‰∏çÂèØÔºâ" },
        sleep: { name: "Áù°Áú†", short: "SLP", category: "control", description: "Ë°åÂãï‰∏çËÉΩ„ÄÇË¢´„ÉÄ„É°„Éº„Ç∏„ÅßËß£Èô§ (DoTÈô§„Åè)" },
        confusion: { name: "Ê∑∑‰π±", short: "CNF", category: "control", description: "ÊîªÊíÉÂØæË±°„Åå„É©„É≥„ÉÄ„É†Âåñ„ÄÇÂë≥Êñπ„ÇíÊîªÊíÉ„Åô„ÇãÂèØËÉΩÊÄß„ÇÇ" },
      silence: { name: "Ê≤àÈªô", short: "SIL", category: "control", description: "„Çπ„Ç≠„É´‰ΩøÁî®‰∏çÂèØÔºàÈÄöÂ∏∏ÊîªÊíÉ„ÅÆ„ÅøÂèØËÉΩÔºâ" },
      knockdown: { name: "Ëª¢ÂÄí", short: "KD", category: "control", description: "Ê¨°„Çø„Éº„É≥„ÅÆË°åÂãïÈ†Ü„ÅåÊúÄÂæå„Å´„Å™„ÇãÔºàË°åÂãïÈÅÖÂª∂Ôºâ" },
      seal: { name: "Â∞ÅÂç∞", short: "SEAL", category: "control", description: "„Éë„ÉÉ„Ç∑„Éñ„ÇÑÂ∏∏ÊôÇÂäπÊûú„ÇíÁÑ°ÂäπÂåñ„Åô„Çã" },
      bleed: { name: "Âá∫Ë°Ä", short: "BLD", category: "dot", description: "Áâ©ÁêÜDoTÔºàÊîªÊíÉÂäõ„Å´‰æùÂ≠òÔºâ" },
      poison: { name: "ÊØí", short: "PSN", category: "dot", description: "Âõ∫ÂÆöÂÄ§ or ÊúÄÂ§ßHPÂâ≤Âêà„ÅÆDoT" },
      curse: { name: "Âë™„ÅÑ", short: "CUR", category: "dot", description: "‰∏é„ÉÄ„É°‰Ωé‰∏ãÔºãÂ∞èDoTÔºàË§áÂêà„Éá„Éê„Éï„Åß„ÇÇÂèØÔºâ" },
      burn: { name: "ÁÅ´ÂÇ∑", short: "BRN", category: "dot", description: "È≠îÊ≥ïÁ≥ªDoT„Å®„Åó„Å¶Êâ±„ÅÜ" },
      physAttackDown: { name: "Áâ©ÁêÜÊîªÊíÉ„ÉÄ„Ç¶„É≥", short: "PATK‚Üì", category: "debuff", description: "Áâ©ÁêÜ„ÉÄ„É°„Éº„Ç∏‰øÇÊï∞„ÉÄ„Ç¶„É≥", potency: 0.2 },
      magAttackDown: { name: "È≠îÊ≥ïÊîªÊíÉ„ÉÄ„Ç¶„É≥", short: "MATK‚Üì", category: "debuff", description: "È≠îÊ≥ï„ÉÄ„É°„Éº„Ç∏‰øÇÊï∞„ÉÄ„Ç¶„É≥", potency: 0.2 },
      physDefenseDown: { name: "Áâ©ÁêÜÈò≤Âæ°„ÉÄ„Ç¶„É≥", short: "PDEF‚Üì", category: "debuff", description: "Âèó„Åë„ÇãÁâ©ÁêÜ„ÉÄ„É°„Éº„Ç∏Â¢óÂä†", potency: 0.2 },
      magDefenseDown: { name: "È≠îÊ≥ïÈò≤Âæ°„ÉÄ„Ç¶„É≥", short: "MDEF‚Üì", category: "debuff", description: "Âèó„Åë„ÇãÈ≠îÊ≥ï„ÉÄ„É°„Éº„Ç∏Â¢óÂä†", potency: 0.2 },
      accuracyDown: { name: "ÂëΩ‰∏≠Áéá„ÉÄ„Ç¶„É≥", short: "ACC‚Üì", category: "debuff", description: "ÊîªÊíÉ„ÅåÂΩì„Åü„Çä„Å´„Åè„Åè„Å™„Çã", potency: 0.15 },
      evasionDown: { name: "ÂõûÈÅøÁéá„ÉÄ„Ç¶„É≥", short: "EVA‚Üì", category: "debuff", description: "ÊîªÊíÉ„ÅåÂΩì„Åü„Çä„ÇÑ„Åô„Åè„Å™„Çã", potency: 0.15 },
      speedDown: { name: "ÈÄüÂ∫¶„ÉÄ„Ç¶„É≥", short: "SPD‚Üì", category: "debuff", description: "Ë°åÂãïÈ†Ü„ÅåÈÅÖ„Åè„Å™„ÇãÔºèË°åÂãïÈ†ªÂ∫¶Ê∏õÂ∞ë", potency: 0.25 },
    };

    const STATUS_CATEGORIES = {
      control: "control",
      dot: "dot",
      debuff: "debuff",
    };

function generateId(prefix = "id") {
  let uuid;

  // crypto.randomUUID „Åå‰Ωø„Åà„ÇãÁí∞Â¢É„Å™„Çâ„Åù„ÅÆ„Åæ„ÅæÂëº„Å≥Âá∫„Åô
  if (
    typeof globalThis !== "undefined" &&
    globalThis.crypto &&
    typeof globalThis.crypto.randomUUID === "function"
  ) {
    uuid = globalThis.crypto.randomUUID();
  } else {
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºàÁ∞°ÊòìIDÔºâ
    uuid = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }

  return prefix ? `${prefix}-${uuid}` : uuid;
}


    const POTION_REFILL_ON_KILL = 12;
    const INVENTORY_FILTER_OPTIONS = [
      { key: "all", label: "„Åô„Åπ„Å¶" },
      { key: "weapon", label: "„É°„Ç§„É≥(Ê≠¶Âô®)" },
      { key: "subWeapon", label: "„Çµ„Éñ(Ê≠¶Âô®)" },
      { key: "head", label: "È†≠" },
      { key: "body", label: "ËÉ¥" },
      { key: "hands", label: "Êâã" },
      { key: "feet", label: "Ë∂≥" },
      { key: "accessory", label: "Ë£ÖÈ£æÂìÅ" },
      { key: "items", label: "„Ç¢„Ç§„ÉÜ„É†" },
      { key: "sort", label: "‰∏¶„Å≥Êõø„Åà" },
    ];
    const INVENTORY_SORT_LABEL = {
      acquire: "ÂÖ•ÊâãÈ†Ü",
      rarity: "„É¨„Ç¢Â∫¶È†Ü",
    };
    let inventoryFilter = "all";
    let inventorySortMode = "acquire";
    let inventoryAcquireSequence = 0;

    const EQUIPMENT_SLOTS = {
      weapon: { label: "„É°„Ç§„É≥(Ê≠¶Âô®)" },
      subWeapon: { label: "„Çµ„Éñ(Ê≠¶Âô®)" },
      head: { label: "È†≠" },
      body: { label: "ËÉ¥" },
      hands: { label: "Êâã" },
      feet: { label: "Ë∂≥" },
      accessory: { label: "Ë£ÖÈ£æÂìÅ" },
    };

    const PLAYER_EQUIPMENT_SLOTS = {
      weapon: { label: "„É°„Ç§„É≥(Ê≠¶Âô®)" },
      subWeapon: { label: "„Çµ„Éñ(Ê≠¶Âô®)" },
      head: { label: "È†≠" },
      body: { label: "ËÉ¥" },
      hands: { label: "Êâã" },
      feet: { label: "Ë∂≥" },
      accessory1: { label: "Ë£ÖÈ£æÂìÅ1" },
      accessory2: { label: "Ë£ÖÈ£æÂìÅ2" },
    };

    const EQUIPMENT_RARITIES = {
      normal: { key: "normal", label: "„Éé„Éº„Éû„É´", color: "#e5e7eb", rank: 0, baseOptions: 3, randomOptions: 0 },
      magic: { key: "magic", label: "„Éû„Ç∏„ÉÉ„ÇØ", color: "#60a5fa", rank: 1, baseOptions: 3, randomOptions: 2 },
      rare: { key: "rare", label: "„É¨„Ç¢", color: "#fcd34d", rank: 2, baseOptions: 3, randomOptions: 3 },
      legendary: { key: "legendary", label: "„É¨„Ç∏„Çß„É≥„Éâ", color: "#b45309", rank: 3, baseOptions: 5, randomOptions: 5 },
    };

    const SELL_VALUE_BY_RARITY = {
      normal: 1,
      magic: 10,
      rare: 100,
      legendary: 10000,
    };

    const DEBUG_RARITY_OPTIONS = [
      { key: "legendary", label: "„É¨„Ç∏„Çß„É≥„Éâ" },
      { key: "random", label: "„É©„É≥„ÉÄ„É†Ôºà„Éé„Éº„Éû„É´„Äú„É¨„Ç¢Ôºâ" },
    ];

    const NON_LEGENDARY_RARITIES = ["normal", "magic", "rare"];

    const BASE_DROP_CHANCE = 32;
    const BOSS_DROP_BONUS = 18;
    const DROP_RARITY_WEIGHTS = [
      { key: "normal", weight: 55 },
      { key: "magic", weight: 32 },
      { key: "rare", weight: 13 },
    ];
    const BOSS_DROP_RARITY_WEIGHTS = [
      { key: "normal", weight: 38 },
      { key: "magic", weight: 40 },
      { key: "rare", weight: 22 },
    ];
    const BOSS_FLOORS = [10, 50, 100, 200, 500, 700, 1000];
    const BOSS_DEFINITIONS = {
      10: {
        name: "ÁÅ∞Áøº„ÅÆÊñ•ÂÄô„Ç¢„Ç®„É≠„Éº", // ÊïèÊç∑ÁâπÂåñ„ÅÆ„Çπ„Ç´„Ç¶„Éà„Çø„Ç§„Éó
        flavor: "ÁÅ∞Ëâ≤„ÅÆÁøº„ÅßËàû„ÅÑ„ÄÅÊØíÁÖô„ÇíÊíí„ÅèÁ¥†Êó©„ÅÑÂÅµÂØüËÄÖ„ÄÇ",
        modifiers: { spd: 1.1, evade: 1.15, accuracy: 1.05, resist: { control: 1.05 } },
        legendaryKey: "stormrunnerClaws",
      },
      50: {
        name: "ÂÆùÂÆàÁ´ú„Ç∞„É©„É≥„Éï„Ç©„Çπ", // Èò≤Âæ°„Å®„Ç∑„Éº„É´„Éâ
        flavor: "ÈáëË≤®„ÇíÊä±„Åà„ÅüÂ∑®Á´ú„ÄÇË∫´„ÇíË¶Ü„ÅÜÁµêÁïå„ÅßÁ≤ò„ÇäÂº∑„ÅèÂÆà„Çã„ÄÇ",
        modifiers: { hp: 1.3, def: 1.15, resist: { debuff: 1.2, dot: 1.15 } },
        legendaryKey: "aegisCarapace",
      },
      100: {
        name: "ÁáºÊªÖÁéã„Ç§„Ç∞„Éã„Ç∑„Ç™", // ÁÅ´ÁÇéÁâπÂåñ
        flavor: "ÁáÉ„ÅàÁõõ„ÇãÁéãÂÜ†„ÇíÊà¥„ÅèÁÑî„ÅÆÊö¥Âêõ„ÄÇÊîªÊíÉ„ÅÆ„Åü„Å≥ÁÑ¶ÁÜ±„ÇíÊÆã„Åô„ÄÇ",
        modifiers: { atk: 1.25, hp: 1.15, accuracy: 1.1, resist: { control: 1.1 } },
        legendaryKey: "cinderScepter",
      },
      200: {
        name: "Ê∑±Ê∏¶„ÅÆÂ•èËÄÖ„É™„É¥„Ç°„É≥", // È≠îÂäõÊ≥¢
        flavor: "Ê∞¥Êü±„ÇíÊìç„ÇãÁ´ú‰∫∫„ÅÆÊ•ΩÂ∏´„ÄÇ„É™„Ç∫„É†„Å´Âêà„Çè„Åõ„Å¶È≠îÂäõ„ÅåÈ´òÈ≥¥„Çã„ÄÇ",
        modifiers: { atk: 1.2, spd: 1.05, evade: 1.05, resist: { control: 1.15, dot: 1.05 } },
        legendaryKey: "tidebinderChord",
      },
      500: {
        name: "ËôöÊòü„ÅÆÂØ©ÂïèÂÆò„Ç™„É´„Éâ", // Èóá„Éª„Éá„Éê„Éï
        flavor: "Êòü„ÇíÂñ∞„Çâ„ÅÜÂØ©ÂïèÂÆò„ÄÇÈ≠îÁúº„ÅßÂº±ÁÇπ„ÇíÊö¥„Åç„ÄÅÂëΩ„ÇíÂâä„Çã„ÄÇ",
        modifiers: { atk: 1.28, accuracy: 1.15, resist: { debuff: 1.25, control: 1.2 } },
        legendaryKey: "voidgazerCrown",
      },
      700: {
        name: "Èõ∑Á§´„ÅÆÊà¶Á•û„Ç¨„É≠„É´„Éâ", // ÈÄ£ÊíÉ„Å®ÈÄüÂ∫¶
        flavor: "Èõ∑Èéö„ÇíÊåØ„Çã„ÅÜÊà¶Á•û„ÄÇÂ§ßÂú∞„ÇíÁ†ï„Åç„Å™„Åå„ÇâÈÄ£ÊíÉ„ÇíÂè©„ÅçËæº„ÇÄ„ÄÇ",
        modifiers: { atk: 1.35, spd: 1.15, hp: 1.12, resist: { dot: 1.1 } },
        legendaryKey: "stormreaverGreaves",
      },
      1000: {
        name: "ÈªéÊòéÁ´ú„Éï„Çß„É≥„É©„Éá„Ç£„Ç¢", // ÊúÄÁµÇ„Éú„Çπ
        flavor: "Â§úÊòé„Åë„ÅÆÂÖâ„ÇíÁ∫è„ÅÜÂè§Á´ú„ÄÇ„Åô„Åπ„Å¶„ÅÆÂ±ûÊÄß„ÇíÊìç„Çä„ÄÅÁµÇÁÑâ„ÇíÂëä„Åí„Çã„ÄÇ",
        modifiers: { atk: 1.4, hp: 1.35, def: 1.2, accuracy: 1.2, resist: { control: 1.25, dot: 1.2 } },
        legendaryKey: "dawnbringerAegis",
      },
    };

    const ENEMY_BASE_PROFILES = [
      { key: "balanced", label: "Ê®ôÊ∫ñ", weight: 4, modifiers: {} },
      { key: "ironhide", label: "Á°¨Ë≥™", weight: 2, modifiers: { hp: 1.06, def: 1.12, spd: 0.96 } },
      { key: "feral", label: "Áç∞Áåõ", weight: 2, modifiers: { atk: 1.08, spd: 1.04, evade: 1.06, def: 0.94 } },
      { key: "stalker", label: "Áã°Áåæ", weight: 1, modifiers: { accuracy: 1.08, evade: 1.08, hp: 0.96, def: 0.95 } },
      { key: "warded", label: "Âë™Á∫è", weight: 1, modifiers: { atk: 1.04, resist: { control: 1.08, debuff: 1.08, dot: 1.06 } } },
    ];

    const ARCHETYPE_RANK_WEIGHTS = [
      { rank: 1, weight: 55 },
      { rank: 2, weight: 30 },
      { rank: 3, weight: 15 },
    ];

    const ENEMY_VARIANTS = [
      {
        key: "brute",
        label: "ÂâõËÖï",
        rankLabels: ["ÂâõËÖï„ÅÆÂæí", "ÂâõËÖï„ÅÆË±™ÂÇë", "ÂâõËÖï„ÅÆË¶áÈéö"],
        description: "ÂçòÁ¥î„Å†„ÅåÁóõ„ÅÑ‰∏ÄÊíÉ„ÇíÊåØ„Çä‰∏ã„Çç„Åô„ÄÇ",
        weight: 3,
        minFloor: 1,
        baseModifiers: { atk: 1.18, hp: 1.05, def: 0.98 },
        abilities: [
          { label: "Á≤âÁ†ïÊâì„Å°", modifiers: { atk: 1.12, accuracy: 1.05 } },
          { label: "ÊøÄÊòÇ", modifiers: { attackCountBonus: 1, hp: 1.05 } },
          { label: "Âº∑Â•™", modifiers: { dropChanceBonus: 6, rarityBonus: 4 } },
        ],
      },
      {
        key: "bulwark",
        label: "ÈáçÁî≤",
        rankLabels: ["ÈáçÁî≤„ÅÆÂÆà„ÇäÊâã", "ÈáçÁî≤„ÅÆÂüéÂ£Å", "ÈáçÁî≤„ÅÆË¶ÅÂ°û"],
        description: "Á°¨„ÅÑÂ§ñÊÆª„ÅßÊîªÊíÉ„Çí„ÅÑ„Å™„Åó„ÄÅ„Åò„Çè„Åò„ÇèËø´„Çã„ÄÇ",
        weight: 2,
        minFloor: 5,
        baseModifiers: { def: 1.4, hp: 1.18, spd: 0.9 },
        abilities: [
          { label: "ÈâÑÂ£Å", modifiers: { def: 1.15, hp: 1.08 } },
          { label: "È†ëÂÅ•", modifiers: { resist: { debuff: 1.12, dot: 1.12 }, def: 1.08 } },
          { label: "ÂÆùÊÆª", modifiers: { dropChanceBonus: 7, rarityBonus: 5 } },
        ],
      },
      {
        key: "skirmisher",
        label: "ÁñæËµ∞",
        rankLabels: ["ÁñæËµ∞„ÅÆÊñ•ÂÄô", "ÁñæËµ∞„ÅÆÂΩ±ÂàÉ", "ÁñæËµ∞„ÅÆËøÖÈõ∑"],
        description: "Á¥†Êó©„ÅèÈñìÂêà„ÅÑ„ÇíË©∞„ÇÅ„ÄÅ„Éí„ÉÉ„ÉàÔºÜ„Ç¢„Ç¶„Çß„Ç§„ÇíÁãô„ÅÜ„ÄÇ",
        weight: 2,
        minFloor: 15,
        baseModifiers: { spd: 1.32, evade: 1.14, def: 0.9 },
        abilities: [
          { label: "Ë∏è„ÅøËæº„Åø", modifiers: { accuracy: 1.08, atk: 1.08 } },
          { label: "‰∫åÈÄ£Êñ¨", modifiers: { attackCountBonus: 1 } },
          { label: "Â•áË•≤ËÄÖ", modifiers: { dropChanceBonus: 5, rarityBonus: 6 } },
        ],
      },
      {
        key: "hexer",
        label: "Âë™Ë©†",
        rankLabels: ["Âë™Ë©†„ÅÆÂæí", "Âë™Ë©†„ÅÆÂÖ∏Á§ºÂ∏´", "Âë™Ë©†„ÅÆÂ§ßÂ∞éÂ∏´"],
        description: "Âë™Ê∞ó„Çí„Åæ„Å®„ÅÑ„ÄÅÁï∞Â∏∏ËÄêÊÄß„Åå„ÇÑ„ÇÑÈ´ò„ÅÑ„ÄÇ",
        weight: 1,
        minFloor: 30,
        baseModifiers: { atk: 1.12, def: 0.96, resist: { control: 1.12, dot: 1.12, debuff: 1.12 } },
        abilities: [
          { label: "Á©¢„Çå„ÅÆÁ¥ã", modifiers: { hp: 1.06, atk: 1.08 } },
          { label: "Âë™ÊñáÈÄ£Èéñ", modifiers: { attackCountBonus: 1, spd: 1.05 } },
          { label: "È≠îÊüì„ÅÆË¥à„ÇäÁâ©", modifiers: { dropChanceBonus: 8, rarityBonus: 6 } },
        ],
      },
      {
        key: "berserker",
        label: "ÁãÇÊà¶",
        rankLabels: ["ÁãÇÊà¶„ÅÆÈ¨®", "ÁãÇÊà¶„ÅÆÁåõËÄÖ", "ÁãÇÊà¶„ÅÆÊö¥Â∏ù"],
        description: "ÊâãÊï∞„ÅßÊäº„ÅôËçí„Å∂„ÇãÊïµ„ÄÇÈò≤Âæ°„ÅØ„ÇÑ„ÇÑËñÑ„ÅÑ„ÄÇ",
        weight: 1,
        minFloor: 50,
        baseModifiers: { atk: 1.22, def: 0.88, hp: 0.94, attackCountBonus: 1 },
        abilities: [
          { label: "Ë°ÄÁÖô", modifiers: { atk: 1.12, spd: 1.08 } },
          { label: "‰π±ÊíÉ", modifiers: { attackCountBonus: 1, accuracy: 1.04 } },
          { label: "Ë°ÄÊüì„ÇÅ„ÅÆÊà¶Âà©ÂìÅ", modifiers: { dropChanceBonus: 6, rarityBonus: 5 } },
        ],
      },
    ];

    const ENEMY_NAME_POOLS = [
      {
        min: 1,
        max: 200,
        names: ["Ê¥ûÁ™ü„Ç™„Ç™„Ç≥„Ç¶„É¢„É™", "ÊúΩ„Å°„ÅüÊßçÂÖµ", "ÂéüÈáé„ÅÆÁãº", "Áü≥ÂÆà„ÅÆ„Çπ„É©„Ç§„É†", "Â∑°Âõû„Åô„ÇãÈéß"],
      },
      {
        min: 201,
        max: 600,
        names: ["Ê∑±Â±§„Éà„Ç´„Ç≤", "Èâ±ËÑà„ÅÆ„Ç¥„Éº„É¨„É†", "ÈóáËµ∞„Çä„ÅÆÁõóË≥ä", "Â§úÁõÆ„ÅÆÁã©‰∫∫", "ÁµêÊô∂„ÇØ„É©„Éñ"],
      },
      {
        min: 601,
        max: 1000,
        names: ["Èõ∑Â∞æ„Çπ„Ç≥„Éº„Éî„Ç™„É≥", "ÈúßÊ≠©„Åç„ÅÆÂΩ±Áç£", "Ëôö„Çç„ÅÆÈ≠îÈ®éÂÖµ", "ÁÅ∞Ááº„ÅÆÁç£Áéã", "Á©∫Èöô„ÉØ„Éº„É†"],
      },
    ];
    const FLOOR_DROP_TABLE = [
      { min: 1, max: 4, slots: ["weapon", "head", "body", "hands"] },
      { min: 5, max: 9, slots: ["weapon", "subWeapon", "body", "hands", "feet"] },
      { min: 10, max: 14, slots: ["weapon", "subWeapon", "hands", "feet", "body"] },
      { min: 15, max: 19, slots: ["weapon", "subWeapon", "hands", "feet", "body", "accessory"] },
      { min: 20, max: 1000, slots: Object.keys(EQUIPMENT_SLOTS) },
    ];
    const BOSS_LEGENDARY_DROPS = {
      10: { slot: "hands", legendaryKey: "stormrunnerClaws" },
      50: { slot: "body", legendaryKey: "aegisCarapace" },
      100: { slot: "subWeapon", legendaryKey: "cinderScepter" },
      200: { slot: "accessory", legendaryKey: "tidebinderChord" },
      500: { slot: "head", legendaryKey: "voidgazerCrown" },
      700: { slot: "feet", legendaryKey: "stormreaverGreaves" },
      1000: { slot: "weapon", legendaryKey: "dawnbringerAegis" },
    };

    const EQUIPMENT_TIER_BOUNDARIES = [
      { maxFloor: 300, key: "early" },
      { maxFloor: 600, key: "mid" },
      { maxFloor: 1000, key: "late" },
    ];

    const TITLE_BASE_CHANCE = { prefix: 55, suffix: 45 };
    const TITLE_RANK_WEIGHTS = [
      { rank: 1, weight: 60 },
      { rank: 2, weight: 30 },
      { rank: 3, weight: 10 },
    ];

    const EQUIPMENT_STAT_POOL = [
      { key: "str", label: "Âäõ", type: "primary", range: [1, 4] },
      { key: "int", label: "Áü•Ë≠ò", type: "primary", range: [1, 4] },
      { key: "vit", label: "‰ΩìÂäõ", type: "primary", range: [1, 4] },
      { key: "agi", label: "ÊïèÊç∑", type: "primary", range: [1, 4] },
      { key: "luck", label: "ÈÅã", type: "primary", range: [1, 4] },
      { key: "hp", label: "ÊúÄÂ§ßHP", type: "secondary", range: [12, 28] },
      { key: "mp", label: "ÊúÄÂ§ßMP", type: "secondary", range: [6, 18] },
      { key: "physAtk", label: "Áâ©ÁêÜÊîªÊíÉÂäõ", type: "secondary", range: [6, 14] },
      { key: "magAtk", label: "È≠îÊ≥ïÊîªÊíÉÂäõ", type: "secondary", range: [6, 14] },
      { key: "physDef", label: "Áâ©ÁêÜÈò≤Âæ°Âäõ", type: "secondary", range: [4, 10] },
      { key: "magDef", label: "È≠îÊ≥ïÈò≤Âæ°Âäõ", type: "secondary", range: [4, 10] },
      { key: "speed", label: "ÈÄüÂ∫¶", type: "secondary", range: [1, 4] },
      { key: "critRate", label: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá", type: "secondary", range: [2, 8], unit: "%" },
      { key: "critDamage", label: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„ÉÄ„É°„Éº„Ç∏", type: "secondary", range: [4, 12], unit: "%" },
      { key: "evade", label: "ÂõûÈÅøÁéá", type: "secondary", range: [2, 8], unit: "%" },
      { key: "physPen", label: "Áâ©ÁêÜË≤´ÈÄö", type: "secondary", range: [1, 5], unit: "%" },
      { key: "magPen", label: "È≠îÊ≥ïË≤´ÈÄö", type: "secondary", range: [1, 5], unit: "%" },
      { key: "damageReduction", label: "Ë¢´„ÉÄ„É°„Éº„Ç∏ËªΩÊ∏õ", type: "secondary", range: [1, 4], unit: "%" },
      { key: "block", label: "„Éñ„É≠„ÉÉ„ÇØÁéá", type: "secondary", range: [1, 5], unit: "%" },
      { key: "controlResist", label: "Ë°åÂãïÈòªÂÆ≥ÊäµÊäó", type: "secondary", range: [3, 10], unit: "%" },
      { key: "dotResist", label: "DoTÊäµÊäó", type: "secondary", range: [3, 10], unit: "%" },
      { key: "debuffResist", label: "Âº±‰ΩìÂåñÊäµÊäó", type: "secondary", range: [3, 10], unit: "%" },
      { key: "cooldown", label: "CTÁü≠Á∏Æ", type: "secondary", range: [1, 6], unit: "%" },
      { key: "hpRegen", label: "HPÂÜçÁîü", type: "secondary", range: [0.5, 2], precision: 1 },
      { key: "lifeSteal", label: "HPÂê∏Âèé", type: "secondary", range: [1, 3], unit: "%" },
      { key: "barrier", label: "„Éê„É™„Ç¢", type: "secondary", range: [8, 20] },
      { key: "dropRate", label: "„Éâ„É≠„ÉÉ„ÉóÁéá", type: "secondary", range: [2, 8], unit: "%" },
      { key: "rarity", label: "„É¨„Ç¢„É™„ÉÜ„Ç£UP", type: "secondary", range: [1, 4], unit: "%" },
      { key: "namedRate", label: "„Éç„Éº„É†„ÉâÈÅ≠ÈÅáÁéá", type: "secondary", range: [2, 6], unit: "%" },
      { key: "titleChance", label: "Áß∞Âè∑‰ªò‰∏éÁéáUP", type: "secondary", range: [4, 10], unit: "%" },
      { key: "goldChance", label: "„Ç¥„Éº„É´„ÉâÁ¢∫Áéá", type: "secondary", range: [5, 18], unit: "%" },
    ];

    const EQUIPMENT_STAT_BY_KEY = Object.fromEntries(EQUIPMENT_STAT_POOL.map((s) => [s.key, s]));

    const EQUIPMENT_TEMPLATE_LIBRARY = {
      weapon: [
        {
          key: "steelSword",
          name: "Èãº„ÅÆÂâ£",
          base: [
            { key: "physAtk", range: [12, 18] },
            { key: "critRate", range: [4, 8], unit: "%" },
            { key: "speed", range: [1, 3] },
          ],
        },
        {
          key: "battleAxe",
          name: "ËΩüÊßå„ÅÆÊà¶Êñß",
          base: [
            { key: "physAtk", range: [16, 22] },
            { key: "critDamage", range: [8, 14], unit: "%" },
            { key: "str", range: [2, 5] },
          ],
        },
        {
          key: "sageStaff",
          name: "Âè°Êô∫„ÅÆÊùñ",
          base: [
            { key: "magAtk", range: [14, 20] },
            { key: "mp", range: [14, 24] },
            { key: "cooldown", range: [2, 6], unit: "%" },
          ],
        },
        {
          key: "skybreakerSpear",
          tier: "mid",
          name: "ËíºÁ©π„ÅÆÁ©øÊßç",
          base: [
            { key: "physAtk", range: [28, 38] },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "speed", range: [3, 6] },
          ],
        },
        {
          key: "astralSpellblade",
          tier: "late",
          name: "ÊòüÂπΩ„ÅÆÂë™ÂàÉ",
          base: [
            { key: "physAtk", range: [42, 58] },
            { key: "magAtk", range: [38, 52] },
            { key: "critDamage", range: [14, 22], unit: "%" },
          ],
        },
      ],
      subWeapon: [
        {
          key: "guardianShield",
          name: "ÂÆàË≠∑ËÄÖ„ÅÆÁõæ",
          base: [
            { key: "physDef", range: [8, 14] },
            { key: "block", range: [4, 8], unit: "%" },
            { key: "hp", range: [20, 36] },
          ],
        },
        {
          key: "spellBook",
          name: "ÊòüÁ¥ã„ÅÆÊõ∏",
          base: [
            { key: "magAtk", range: [8, 14] },
            { key: "magDef", range: [6, 12] },
            { key: "mp", range: [10, 18] },
          ],
        },
        {
          key: "shadowDagger",
          name: "ÂΩ±Ëµ∞„Çä„ÅÆÁü≠Ââ£",
          base: [
            { key: "physAtk", range: [8, 14] },
            { key: "speed", range: [2, 4] },
            { key: "critRate", range: [5, 9], unit: "%" },
          ],
        },
        {
          key: "auroraBulwark",
          tier: "mid",
          name: "Ê•µÂÖâ„ÅÆÂ§ßÁõæ",
          base: [
            { key: "physDef", range: [20, 32] },
            { key: "magDef", range: [14, 26] },
            { key: "block", range: [10, 16], unit: "%" },
          ],
        },
        {
          key: "runeboundTome",
          tier: "late",
          name: "Â∞ÅÂàª„ÅÆÊõ∏Êùø",
          base: [
            { key: "magAtk", range: [28, 40] },
            { key: "mp", range: [40, 60] },
            { key: "cooldown", range: [6, 10], unit: "%" },
          ],
        },
      ],
      head: [
        {
          key: "scoutHood",
          name: "Êñ•ÂÄô„ÅÆ„Éï„Éº„Éâ",
          base: [
            { key: "agi", range: [2, 4] },
            { key: "evade", range: [4, 9], unit: "%" },
            { key: "speed", range: [1, 3] },
          ],
        },
        {
          key: "sageCrown",
          name: "Ë≥¢ËÄÖ„ÅÆÂÜ†",
          base: [
            { key: "int", range: [2, 4] },
            { key: "magDef", range: [6, 12] },
            { key: "mp", range: [12, 20] },
          ],
        },
        {
          key: "veteranHelm",
          name: "Ê≠¥Êà¶„ÅÆÂÖú",
          base: [
            { key: "vit", range: [2, 5] },
            { key: "physDef", range: [8, 14] },
            { key: "hp", range: [18, 32] },
          ],
        },
        {
          key: "stormwatchHelm",
          tier: "mid",
          name: "Èõ∑Ë¶ñ„ÅÆÂÖú",
          base: [
            { key: "physDef", range: [18, 28] },
            { key: "accuracy", range: [10, 18], unit: "%" },
            { key: "speed", range: [3, 5] },
          ],
        },
        {
          key: "oraclesVisage",
          tier: "late",
          name: "Á•ûË®ó„ÅÆ„É¥„Çß„Ç§„É´",
          base: [
            { key: "magDef", range: [22, 34] },
            { key: "int", range: [6, 10] },
            { key: "cooldown", range: [6, 10], unit: "%" },
          ],
        },
      ],
      body: [
        {
          key: "brigandine",
          name: "ÊóÖ‰∫∫„ÅÆ„Ç≥„Éº„Éà",
          base: [
            { key: "evade", range: [3, 7], unit: "%" },
            { key: "speed", range: [1, 3] },
            { key: "hp", range: [18, 30] },
          ],
        },
        {
          key: "plateArmor",
          name: "ÈãºÈâÑ„ÅÆÈéß",
          base: [
            { key: "physDef", range: [10, 16] },
            { key: "magDef", range: [6, 12] },
            { key: "damageReduction", range: [2, 5], unit: "%" },
          ],
        },
        {
          key: "mageRobe",
          name: "ÊòüÈúú„ÅÆ„É≠„Éº„Éñ",
          base: [
            { key: "magDef", range: [8, 14] },
            { key: "mp", range: [16, 26] },
            { key: "cooldown", range: [2, 6], unit: "%" },
          ],
        },
        {
          key: "tempestMail",
          tier: "mid",
          name: "Êö¥È¢®„ÅÆÈéß",
          base: [
            { key: "physDef", range: [22, 32] },
            { key: "hp", range: [40, 62] },
            { key: "speed", range: [3, 5] },
          ],
        },
        {
          key: "starseerRaiment",
          tier: "late",
          name: "ÊòüË©†„Åø„ÅÆÊ≥ïË°£",
          base: [
            { key: "magDef", range: [28, 40] },
            { key: "mp", range: [46, 72] },
            { key: "evade", range: [10, 16], unit: "%" },
          ],
        },
      ],
      hands: [
        {
          key: "assassinGloves",
          name: "Â§úÂΩ±„ÅÆ„Ç∞„É≠„Éº„Éñ",
          base: [
            { key: "critRate", range: [4, 9], unit: "%" },
            { key: "speed", range: [1, 3] },
            { key: "physAtk", range: [6, 12] },
          ],
        },
        {
          key: "sageGloves",
          name: "Ë°ìÂ£´„ÅÆÊâãË¢ã",
          base: [
            { key: "magAtk", range: [6, 12] },
            { key: "magPen", range: [2, 5], unit: "%" },
            { key: "cooldown", range: [2, 6], unit: "%" },
          ],
        },
        {
          key: "guardianGauntlet",
          name: "ÂÆàË≠∑„ÅÆ„Ç¨„É≥„Éà„É¨„ÉÉ„Éà",
          base: [
            { key: "physDef", range: [6, 12] },
            { key: "block", range: [3, 7], unit: "%" },
            { key: "hp", range: [12, 24] },
          ],
        },
        {
          key: "arcShockFist",
          tier: "mid",
          name: "ÈõªÂàÉ„ÅÆÁØ≠Êâã",
          base: [
            { key: "physAtk", range: [20, 30] },
            { key: "speed", range: [3, 6] },
            { key: "critDamage", range: [10, 16], unit: "%" },
          ],
        },
        {
          key: "moonweaveGloves",
          tier: "late",
          name: "ÊúàÁπî„ÅÆÊâãË¢ã",
          base: [
            { key: "magAtk", range: [22, 34] },
            { key: "cooldown", range: [6, 10], unit: "%" },
            { key: "evade", range: [10, 16], unit: "%" },
          ],
        },
      ],
      feet: [
        {
          key: "scoutBoots",
          name: "ÁñæËµ∞„ÅÆ„Éñ„Éº„ÉÑ",
          base: [
            { key: "speed", range: [2, 5] },
            { key: "evade", range: [4, 8], unit: "%" },
            { key: "agi", range: [2, 4] },
          ],
        },
        {
          key: "heavyGreaves",
          name: "Ë¶ÅÂ°û„ÅÆ„Ç∞„É™„Éº„Éñ",
          base: [
            { key: "physDef", range: [8, 14] },
            { key: "magDef", range: [6, 12] },
            { key: "hp", range: [16, 30] },
          ],
        },
        {
          key: "mysticSandals",
          name: "Á•ûÁßò„ÅÆ„Çµ„É≥„ÉÄ„É´",
          base: [
            { key: "magDef", range: [8, 12] },
            { key: "mp", range: [12, 20] },
            { key: "cooldown", range: [2, 5], unit: "%" },
          ],
        },
        {
          key: "sandstormBoots",
          tier: "mid",
          name: "Á†ÇÊö¥„ÅÆËÑöÁî≤",
          base: [
            { key: "speed", range: [4, 7] },
            { key: "evade", range: [8, 14], unit: "%" },
            { key: "agi", range: [4, 7] },
          ],
        },
        {
          key: "auroraStride",
          tier: "late",
          name: "ÈªéÂÖâ„ÅÆÊ≠©„Åø",
          base: [
            { key: "speed", range: [6, 10] },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "damageReduction", range: [6, 10], unit: "%" },
          ],
        },
      ],
      accessory: [
        {
          key: "warriorCharm",
          name: "Ê≠¶Âãá„ÅÆË≠∑Á¨¶",
          base: [
            { key: "str", range: [2, 4] },
            { key: "physAtk", range: [6, 12] },
            { key: "critDamage", range: [6, 12], unit: "%" },
          ],
        },
        {
          key: "sagePendant",
          name: "Ë≥¢Êô∫„ÅÆ„Éö„É≥„ÉÄ„É≥„Éà",
          base: [
            { key: "int", range: [2, 4] },
            { key: "magAtk", range: [6, 12] },
            { key: "mp", range: [12, 22] },
          ],
        },
        {
          key: "luckyRing",
          name: "Âπ∏ÈÅã„ÅÆÊåáËº™",
          base: [
            { key: "luck", range: [2, 4] },
            { key: "dropRate", range: [4, 10], unit: "%" },
            { key: "critRate", range: [3, 7], unit: "%" },
          ],
        },
        {
          key: "timekeepersRing",
          tier: "mid",
          name: "ÊôÇÁ¥°„Åé„ÅÆÊåáËº™",
          base: [
            { key: "cooldown", range: [6, 10], unit: "%" },
            { key: "speed", range: [3, 6] },
            { key: "mp", range: [22, 36] },
          ],
        },
        {
          key: "dragonsEmbrace",
          tier: "late",
          name: "Á´úÊä±„Åç„ÅÆË≠∑Á¨¶",
          base: [
            { key: "hp", range: [50, 80] },
            { key: "damageReduction", range: [8, 12], unit: "%" },
            { key: "dropRate", range: [8, 16], unit: "%" },
          ],
        },
      ],
    };

    const EQUIPMENT_TITLE_PREFIXES = [
      { key: "nimble", name: "ËªΩ„ÇÑ„Åã„Å™", rank: 1, options: ["agi"] },
      { key: "sharp", name: "Èã≠„ÅÑ", rank: 1, options: ["critRate"] },
      { key: "colossal", name: "Â∑®Â§ß„Å™", rank: 2, options: ["str", "vit"] },
      { key: "arcane", name: "È≠îÂ∞é„ÅÆ", rank: 2, options: ["int", "mp"] },
      { key: "tempest", name: "ËøÖÈõ∑„ÅÆ", rank: 3, options: ["speed", "evade", "critRate"] },
      { key: "mythic", name: "Á•ûÁç£„ÅÆ", rank: 3, options: ["str", "vit", "hp"] },
      { key: "immortal", name: "‰∏çÊúΩ„ÅÆ", rank: 3, options: ["hp", "damageReduction", "block"] },
      { key: "twilight", name: "ÈªÑÊòè„ÅÆ", rank: 2, options: ["int", "magAtk"] },
      { key: "hunter", name: "Áã©‰∫∫„ÅÆ", rank: 2, options: ["critRate", "speed"] },
    ];

    const EQUIPMENT_TITLE_SUFFIXES = [
      { key: "apprentice", name: "„ÅÆÁ†îÈëΩ", rank: 1, options: ["hp"] },
      { key: "trailblazer", name: "„ÅÆÂÖàÈßÜËÄÖ", rank: 1, options: ["speed"] },
      { key: "onslaught", name: "„ÅÆÁåõÊîª", rank: 2, options: ["physAtk", "critDamage"] },
      { key: "sorcery", name: "„ÅÆÂè°Êô∫", rank: 2, options: ["magAtk", "cooldown"] },
      { key: "conqueror", name: "„ÅÆË¶áËÄÖ", rank: 3, options: ["physAtk", "physPen", "critRate"] },
      { key: "eternal", name: "„ÅÆÁµÇÁÑâ", rank: 3, options: ["magAtk", "magPen", "debuffResist"] },
      { key: "guardian", name: "„ÅÆÂÆàË≠∑ËÄÖ", rank: 2, options: ["hp", "physDef", "magDef"] },
      { key: "storm", name: "„ÅÆÈõ∑È≥¥", rank: 2, options: ["speed", "critRate"] },
      { key: "void", name: "„ÅÆËôöÁÑ°", rank: 3, options: ["magAtk", "dotResist", "controlResist"] },
    ];

    const LEGENDARY_EQUIPMENT_LIBRARY = {
      weapon: [
        {
          key: "infernoGreatsword",
          name: "ÁÅºÁÖå„ÅÆÂ§ßÂâ£",
          base: [
            { key: "physAtk", range: [28, 36] },
            { key: "critDamage", range: [12, 20], unit: "%" },
            { key: "str", range: [4, 7] },
            { key: "hp", range: [30, 50] },
            { key: "physPen", range: [4, 8], unit: "%" },
          ],
          unique: { name: "ÁÖâÁçÑË¶áÊñ¨", range: [28, 42], unit: "%", effect: "ÁÅ´Â±ûÊÄß„Çπ„Ç≠„É´„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "mistTwinblade",
          name: "ÈúßÈñÉ„ÅÆÂèåÂàÉ",
          base: [
            { key: "physAtk", range: [20, 30] },
            { key: "speed", range: [3, 6] },
            { key: "evade", range: [6, 12], unit: "%" },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "agi", range: [4, 6] },
          ],
          unique: {
            name: "ÂπªÂΩ±ÈÄ£Ëàû",
            range: [20, 32],
            unit: "%",
            effect: "ÈÄöÂ∏∏ÊîªÊíÉÂëΩ‰∏≠ÊôÇ{value}„Åß3ÈÄ£ÊíÉÂåñÔºàËøΩÂä†ÊîªÊíÉ„ÅØÂ®ÅÂäõ50%Ôºâ",
          },
        },
        {
          key: "raidenKatana",
          name: "Èõ∑È≥¥„ÅÆÂàÄ",
          base: [
            { key: "physAtk", range: [24, 34] },
            { key: "speed", range: [3, 6] },
            { key: "critRate", range: [8, 14], unit: "%" },
            { key: "hp", range: [24, 40] },
            { key: "damageReduction", range: [4, 8], unit: "%" },
          ],
          unique: { name: "Èõ∑È≥¥Â±ÖÂêà", range: [26, 40], unit: "%", effect: "„Çπ„Ç≠„É´ÂëΩ‰∏≠ÊôÇ„ÄÅ{value}„ÅßÊÑüÈõª„Çí2„Çø„Éº„É≥‰ªò‰∏é" },
        },
        {
          key: "dawnbringerAegis",
          name: "ÈªéÊòé„ÅÆËÅñÁõæÂâ£",
          base: [
            { key: "physAtk", range: [54, 72] },
            { key: "hp", range: [80, 120] },
            { key: "damageReduction", range: [10, 16], unit: "%" },
            { key: "speed", range: [4, 7] },
            { key: "critRate", range: [8, 14], unit: "%" },
          ],
          unique: { name: "Â§úÊòé„Åë„ÅÆË™ìÁ¥Ñ", range: [18, 28], unit: "%", effect: "HP50%‰ª•‰∏ä„ÅßË¢´„ÉÄ„É°-{value}„ÄÅ50%Êú™Ê∫Ä„Åß‰∏é„ÉÄ„É°+{value}" },
        },
      ],
      subWeapon: [
        {
          key: "azureBulwark",
          name: "ËíºÁ¥ã„ÅÆÁõæ",
          base: [
            { key: "physDef", range: [18, 28] },
            { key: "magDef", range: [12, 20] },
            { key: "hp", range: [36, 60] },
            { key: "block", range: [8, 14], unit: "%" },
            { key: "damageReduction", range: [6, 10], unit: "%" },
          ],
          unique: { name: "ËíºÂÆà„ÅÆÈöúÂ£Å", range: [320, 480], effect: "Êà¶ÈóòÈñãÂßãÊôÇ„ÄÅ{value}„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÇíÂê∏Âèé„Åô„Çã„Ç∑„Éº„É´„Éâ„ÇíÂæó„Çã" },
        },
        {
          key: "dawnGrimoire",
          name: "ÊöÅÊòü„ÅÆÈ≠îÂ∞éÊõ∏",
          base: [
            { key: "magAtk", range: [16, 24] },
            { key: "mp", range: [28, 44] },
            { key: "magDef", range: [12, 20] },
            { key: "cooldown", range: [4, 8], unit: "%" },
            { key: "int", range: [3, 6] },
          ],
          unique: {
            name: "ÈªéÊòé„ÅÆÂñùÈáá",
            range: [18, 30],
            unit: "%",
            effect: "„Çπ„Ç≠„É´‰ΩøÁî®Âæå„ÄÅÊ¨°„ÅÆÈÄöÂ∏∏ÊîªÊíÉ„ÅåÂøÖ„Åö„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Åó‰∏é„ÉÄ„É°„Éº„Ç∏+{value}",
          },
        },
        {
          key: "abyssCompass",
          name: "Ê∑±Ê∑µ„ÅÆÁæÖÈáùÁõ§",
          base: [
            { key: "magAtk", range: [14, 22] },
            { key: "magPen", range: [6, 10], unit: "%" },
            { key: "mp", range: [22, 36] },
            { key: "controlResist", range: [10, 18], unit: "%" },
            { key: "cooldown", range: [4, 7], unit: "%" },
          ],
          unique: { name: "Ê∑±Ê∑µ„ÅÆÂëº„Å≥Â£∞", range: [20, 32], unit: "%", effect: "„Éá„Éê„Éï„Åå‰ªò‰∏é„Åï„Çå„ÅüÊïµ„Å∏„ÅÆ‰∏é„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "cinderScepter",
          name: "ÁáºÁÅ∞„ÅÆËªçÈÖç",
          base: [
            { key: "magAtk", range: [30, 44] },
            { key: "mp", range: [48, 72] },
            { key: "burn", range: [8, 12] },
            { key: "cooldown", range: [6, 10], unit: "%" },
            { key: "damageReduction", range: [6, 10], unit: "%" },
          ],
          unique: { name: "ÁÑ¶ÁÜ±„ÅÆÂØ©Âà§", range: [18, 28], unit: "%", effect: "ÁÅ´ÂÇ∑‰∏≠„ÅÆÊïµ„Å∏‰∏é„ÉÄ„É°+{value}„ÄÅËá™ÂàÜ„ÅÆÁÅ´ÁÇéDoT„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
      ],
      head: [
        {
          key: "starseerCirclet",
          name: "ÊòüË™≠„ÅÆ„Çµ„Éº„ÇØ„É¨„ÉÉ„Éà",
          base: [
            { key: "int", range: [4, 7] },
            { key: "magAtk", range: [10, 18] },
            { key: "magDef", range: [12, 18] },
            { key: "mp", range: [24, 40] },
            { key: "cooldown", range: [4, 7], unit: "%" },
          ],
          unique: { name: "‰∫àÂÖÜË™≠„Åø", range: [8, 15], unit: "%", effect: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´ÊôÇ„ÄÅÂÖ®„Çπ„Ç≠„É´CT„Çí{value}Áü≠Á∏Æ" },
        },
        {
          key: "wyrmhelm",
          name: "Á´úÈ™®„ÅÆÂÖú",
          base: [
            { key: "str", range: [4, 7] },
            { key: "vit", range: [4, 7] },
            { key: "physDef", range: [14, 22] },
            { key: "hp", range: [32, 52] },
            { key: "critRate", range: [6, 12], unit: "%" },
          ],
          unique: { name: "Á´úÁúº„ÅÆÂ®ÅÂúß", range: [20, 32], unit: "%", effect: "Ë¢´ÂºæÊôÇ{value}„ÅßÊ¨°„ÅÆÊîªÊíÉ„ÅåÂøÖ‰∏≠ÔºÜ‰∏é„ÉÄ„É°‰∏äÊòá" },
        },
        {
          key: "moonveilHood",
          name: "ÊúàÂΩ±„ÅÆ„Éï„Éº„Éâ",
          base: [
            { key: "agi", range: [4, 6] },
            { key: "evade", range: [10, 16], unit: "%" },
            { key: "speed", range: [3, 5] },
            { key: "hp", range: [22, 40] },
            { key: "critRate", range: [6, 12], unit: "%" },
          ],
          unique: { name: "ÊúàÂΩ±„ÅÆË¶Ü„ÅÑ", range: [18, 28], unit: "%", effect: "ÂõûÈÅøÊôÇ„ÄÅÊ¨°„Çø„Éº„É≥„ÅÆ‰∏é„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "voidgazerCrown",
          name: "ËôöÊòü„ÅÆÂÜïÂÜ†",
          base: [
            { key: "int", range: [8, 12] },
            { key: "accuracy", range: [12, 18], unit: "%" },
            { key: "magAtk", range: [18, 28] },
            { key: "debuffResist", range: [12, 20], unit: "%" },
            { key: "dotResist", range: [10, 18], unit: "%" },
          ],
          unique: { name: "ÊòüÂñ∞„ÅÑ„ÅÆÁúº", range: [16, 26], unit: "%", effect: "Âº±‰ΩìÂåñ‰∏≠„ÅÆÊïµ„Å´‰∏é„ÉÄ„É°+{value}„ÄÅÂëΩ‰∏≠ÊôÇ„Å´‰ΩéÁ¢∫Áéá„ÅßÊ≤àÈªô‰ªò‰∏é" },
        },
      ],
      body: [
        {
          key: "azureScaleArmor",
          name: "ËíºÁ´ú„ÅÆÈ±óÈéß",
          base: [
            { key: "physDef", range: [18, 28] },
            { key: "magDef", range: [14, 22] },
            { key: "hp", range: [40, 64] },
            { key: "damageReduction", range: [6, 10], unit: "%" },
            { key: "block", range: [8, 12], unit: "%" },
          ],
          unique: { name: "È±ó„ÅÆÂÆàË≠∑", range: [12, 20], unit: "%", effect: "Âèó„Åë„Çã„ÉÄ„É°„Éº„Ç∏„ÇíÂ∏∏ÊôÇ{value}ËªΩÊ∏õ" },
        },
        {
          key: "wrathPlate",
          name: "Ëµ´ÊÄí„ÅÆÊà¶Ë£Ö",
          base: [
            { key: "physAtk", range: [14, 22] },
            { key: "hp", range: [32, 56] },
            { key: "physDef", range: [12, 20] },
            { key: "critDamage", range: [10, 16], unit: "%" },
            { key: "damageReduction", range: [4, 8], unit: "%" },
          ],
          unique: { name: "ÊÄíÊ∂õ„ÅÆÂæ©ËÆê", range: [18, 30], unit: "%", effect: "Ë¢´„ÉÄ„É°„Éº„Ç∏ÊôÇ„ÄÅÊ¨°„ÅÆ„Çø„Éº„É≥ÁµÇ‰∫Ü„Åæ„Åß‰∏é„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "sableRaiment",
          name: "ÈªíÊ™Ä„ÅÆÊ≥ïË°£",
          base: [
            { key: "magAtk", range: [16, 24] },
            { key: "mp", range: [32, 52] },
            { key: "magDef", range: [14, 22] },
            { key: "cooldown", range: [5, 9], unit: "%" },
            { key: "dotResist", range: [10, 18], unit: "%" },
          ],
          unique: { name: "Èóá„ÅÆÊÅ©ÂØµ", range: [20, 32], unit: "%", effect: "DoT„Çí‰ªò‰∏é‰∏≠„ÅÆÊïµ„Å∏„ÅÆ‰∏é„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "aegisCarapace",
          name: "ÂÆùÊÆª„ÅÆÂ§ßÈéß",
          base: [
            { key: "physDef", range: [30, 44] },
            { key: "magDef", range: [26, 38] },
            { key: "hp", range: [70, 110] },
            { key: "block", range: [12, 18], unit: "%" },
            { key: "damageReduction", range: [8, 12], unit: "%" },
          ],
          unique: { name: "ÂÆùÂÆà„ÅÆÈöúÂ£Å", range: [380, 520], effect: "Êà¶ÈóòÈñãÂßãÊôÇ„ÄÅ{value}„ÅÆ„Ç∑„Éº„É´„Éâ&Ë¢´„ÉÄ„É°ÊôÇ„Å´Á¢∫Áéá„ÅßËøΩÂä†„Ç∑„Éº„É´„ÉâÁç≤Âæó" },
        },
      ],
      hands: [
        {
          key: "stormGauntlet",
          name: "Èõ∑Á∫è„ÅÑ„ÅÆÁØ≠Êâã",
          base: [
            { key: "physAtk", range: [14, 22] },
            { key: "speed", range: [3, 6] },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "hp", range: [18, 32] },
            { key: "evade", range: [6, 10], unit: "%" },
          ],
          unique: { name: "Èõ∑Á¶ç„ÅÆÈÄ£Èéñ", range: [35, 55], unit: "%", effect: "„Çπ„Ç≠„É´ÂëΩ‰∏≠ÊôÇ„ÄÅËøΩÂä†„Åß{value}„ÅÆÁ¢∫Áéá„ÅßÊÑüÈõª„Çí‰ªò‰∏é" },
        },
        {
          key: "shadowWeave",
          name: "ÂΩ±Á∏´„ÅÑ„ÅÆÊâãË¢ã",
          base: [
            { key: "physAtk", range: [12, 20] },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "speed", range: [2, 5] },
            { key: "evade", range: [6, 12], unit: "%" },
            { key: "hp", range: [16, 28] },
          ],
          unique: { name: "ÊãòÊùü„ÅÆÂà∫Á™Å", range: [22, 36], unit: "%", effect: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´ÊôÇ„ÄÅÊïµ„Çí{value}„Åß1„Çø„Éº„É≥Ë°åÂãï‰∏çËÉΩ„Å´„Åô„Çã" },
        },
        {
          key: "frostbinder",
          name: "Ê∞∑Á∏õ„ÅÆÊâãÁî≤",
          base: [
            { key: "magAtk", range: [14, 22] },
            { key: "cooldown", range: [4, 8], unit: "%" },
            { key: "magPen", range: [5, 9], unit: "%" },
            { key: "hp", range: [18, 30] },
            { key: "magDef", range: [10, 16] },
          ],
          unique: { name: "Ê∞∑ÂàÉÂ∞ÅÊÆ∫", range: [24, 38], unit: "%", effect: "„Çπ„Ç≠„É´ÂëΩ‰∏≠ÊôÇ{value}„ÅßÂáçÁµê1„Çø„Éº„É≥‰ªò‰∏é" },
        },
        {
          key: "stormrunnerClaws",
          name: "ÁÅ∞Áøº„ÅÆÈâ§Áà™",
          base: [
            { key: "physAtk", range: [22, 32] },
            { key: "speed", range: [4, 7] },
            { key: "evade", range: [10, 16], unit: "%" },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "agi", range: [4, 7] },
          ],
          unique: { name: "ÁÅ∞Áøº„ÅÆÂº∑Ë•≤", range: [18, 28], unit: "%", effect: "ÂÖàÂà∂„Çø„Éº„É≥„Åß‰∏é„ÉÄ„É°+{value}„ÄÅÂõûÈÅøÊôÇ„Å´Ê¨°ÊîªÊíÉ„ÅåÂøÖ‰∏≠Âåñ" },
        },
      ],
      feet: [
        {
          key: "galeGreaves",
          name: "ÁñæÈ¢®„ÅÆ„Ç∞„É™„Éº„É¥",
          base: [
            { key: "speed", range: [4, 8] },
            { key: "evade", range: [10, 16], unit: "%" },
            { key: "agi", range: [4, 6] },
            { key: "hp", range: [16, 28] },
            { key: "critRate", range: [6, 10], unit: "%" },
          ],
          unique: { name: "È¢®Ëµ∞", range: [14, 24], unit: "%", effect: "ÂõûÈÅøÁéá+{value}„ÄÅÂõûÈÅøÊàêÂäüÊôÇ„ÅØÊ¨°„Çø„Éº„É≥„ÅÆË°åÂãïÈ†Ü„ÇíÊó©„ÇÅ„Çã" },
        },
        {
          key: "abyssWalker",
          name: "Ê∑±Ê∑µÊ≠©„Åç„ÅÆ„Éñ„Éº„ÉÑ",
          base: [
            { key: "speed", range: [3, 6] },
            { key: "evade", range: [10, 16], unit: "%" },
            { key: "hp", range: [18, 32] },
            { key: "damageReduction", range: [4, 7], unit: "%" },
            { key: "agi", range: [3, 5] },
          ],
          unique: { name: "Â•àËêΩ„ÅÆË∑≥Ë∫ç", range: [16, 28], unit: "%", effect: "ÂõûÈÅøÊàêÂäüÊôÇ„ÄÅ{value}„ÅßËøΩÂä†Ë°åÂãï„ÇíÂæó„Çã" },
        },
        {
          key: "sunstride",
          name: "ÈôΩÁÇé„ÅÆÈù¥",
          base: [
            { key: "speed", range: [4, 7] },
            { key: "evade", range: [8, 14], unit: "%" },
            { key: "hp", range: [18, 30] },
            { key: "physAtk", range: [10, 16] },
            { key: "critDamage", range: [8, 12], unit: "%" },
          ],
          unique: { name: "ÈôΩÁÇéÁñæÈßÜ", range: [18, 30], unit: "%", effect: "ÁßªÂãïÂæå„ÅÆ„Çø„Éº„É≥„ÄÅÂàùÂõûÊîªÊíÉ„ÅÆ‰∏é„ÉÄ„É°„Éº„Ç∏+{value}" },
        },
        {
          key: "stormreaverGreaves",
          name: "Èõ∑Á§´„ÅÆÊà¶ËÑö",
          base: [
            { key: "speed", range: [6, 10] },
            { key: "physAtk", range: [18, 28] },
            { key: "critRate", range: [10, 16], unit: "%" },
            { key: "evade", range: [10, 16], unit: "%" },
            { key: "damageReduction", range: [6, 10], unit: "%" },
          ],
          unique: { name: "Èõ∑Á§´„ÅÆÂ•îÊµÅ", range: [16, 26], unit: "%", effect: "ÈÄ£Á∂öÊîªÊíÉÊôÇ„ÅÆ2ÊíÉÁõÆ‰ª•Èôç„ÅÆ‰∏é„ÉÄ„É°+{value}„ÄÅË°åÂãïÂæå„Å´ÈÄüÂ∫¶Â∞è‰∏äÊòá" },
        },
      ],
      accessory: [
        {
          key: "twinMoonRing",
          name: "Âπ∏ÈÅã„ÅÆÂèåÊúà„É™„É≥„Ç∞",
          base: [
            { key: "luck", range: [4, 7] },
            { key: "dropRate", range: [10, 16], unit: "%" },
            { key: "critRate", range: [6, 10], unit: "%" },
            { key: "rarity", range: [6, 10], unit: "%" },
            { key: "hp", range: [14, 24] },
          ],
          unique: { name: "ÂèåÊúà„ÅÆÂ∞é„Åç", range: [6, 12], unit: "%", effect: "ÂÆùÁÆ±„Å®„Éâ„É≠„ÉÉ„Éó„ÅÆ„É¨„Ç¢„É™„ÉÜ„Ç£+{value}" },
        },
        {
          key: "verdantPledge",
          name: "Áø†Á∑ë„ÅÆË™ìÁ¥ÑÊåáËº™",
          base: [
            { key: "vit", range: [3, 6] },
            { key: "hp", range: [26, 44] },
            { key: "hpRegen", range: [1.5, 3], precision: 1 },
            { key: "damageReduction", range: [4, 8], unit: "%" },
            { key: "debuffResist", range: [10, 16], unit: "%" },
          ],
          unique: { name: "Áôí„Åó„ÅÆÁõüÁ¥Ñ", range: [18, 30], unit: "%", effect: "Á∂ôÁ∂öÂõûÂæ©ÂäπÊûúÈáè+{value}" },
        },
        {
          key: "bloodcrystalTalisman",
          name: "Ë°ÄÊô∂„ÅÆ„Çø„É™„Çπ„Éû„É≥",
          base: [
            { key: "physAtk", range: [10, 16] },
            { key: "magAtk", range: [10, 16] },
            { key: "lifeSteal", range: [4, 7], unit: "%" },
            { key: "hp", range: [18, 30] },
            { key: "critDamage", range: [8, 12], unit: "%" },
          ],
          unique: { name: "Ë°ÄÊô∂Âê∏Âèé", range: [6, 12], unit: "%", effect: "„Çπ„Ç≠„É´‰ΩøÁî®ÊôÇ„ÄÅ‰∏é„ÉÄ„É°„Éº„Ç∏„ÅÆ{value}„ÇíHP„Å®„Åó„Å¶Âê∏Âèé" },
        },
        {
          key: "starwardCharm",
          name: "ËíºÊòü„ÅÆË≠∑Á¨¶",
          base: [
            { key: "magDef", range: [12, 20] },
            { key: "barrier", range: [40, 70] },
            { key: "mp", range: [20, 34] },
            { key: "controlResist", range: [10, 18], unit: "%" },
            { key: "cooldown", range: [4, 7], unit: "%" },
          ],
          unique: { name: "ËíºÊòüÁµêÁïå", range: [80, 140], effect: "Áç≤Âæó„Åô„Çã„Éê„É™„Ç¢Èáè+{value}„ÄÅ„Éê„É™„Ç¢Á†¥Â£äÊôÇ„Å´Âë®Âõ≤„Å∏Â∞è„ÉÄ„É°„Éº„Ç∏" },
        },
        {
          key: "tidebinderChord",
          name: "Ê∑±Ê∏¶„ÅÆË™øÂæãÁ¥ê",
          base: [
            { key: "magAtk", range: [16, 26] },
            { key: "cooldown", range: [6, 10], unit: "%" },
            { key: "mp", range: [40, 64] },
            { key: "speed", range: [4, 7] },
            { key: "controlResist", range: [10, 16], unit: "%" },
          ],
          unique: { name: "ÊΩÆÈ≥¥„Çä„ÅÆÊóãÂæã", range: [16, 26], unit: "%", effect: "„Çπ„Ç≠„É´‰ΩøÁî®ÊØé„Å´‰∏é„ÉÄ„É°+{value}(ÊúÄÂ§ß3Âõû)„ÄÅCTÁü≠Á∏ÆÂäπÊûú+{value}" },
        },
        {
          key: "phoenixFeather",
          name: "‰∏çÊ≠ªÈ≥•„ÅÆÁæΩÊ†πÈ£æ„Çä",
          base: [
            { key: "hp", range: [28, 46] },
            { key: "hpRegen", range: [1.5, 3.2], precision: 1 },
            { key: "damageReduction", range: [4, 8], unit: "%" },
            { key: "magDef", range: [12, 20] },
            { key: "block", range: [4, 8], unit: "%" },
          ],
          unique: { name: "‰∏çÊ≠ªÈ≥•„ÅÆÂä†Ë≠∑", range: [20, 32], unit: "%", effect: "Ëá¥Ê≠ª„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å¶„ÇÇ{value}„ÅßHP1„ÅßË∏è„Åø„Å®„Å©„Åæ„Çã" },
        },
      ],
    };

    function createEmptyBonus() {
      return {
        hp: 0,
        mp: 0,
        physAtk: 0,
        magAtk: 0,
        physDef: 0,
        magDef: 0,
        speed: 0,
        critRate: 0,
        critDamage: 0,
        evade: 0,
        physPen: 0,
        magPen: 0,
        damageReduction: 0,
        block: 0,
        controlResist: 0,
        dotResist: 0,
        debuffResist: 0,
        cooldown: 0,
        hpRegen: 0,
        lifeSteal: 0,
        barrier: 0,
        dropRate: 0,
        rarity: 0,
        goldChance: 0,
        titleChance: 0,
        namedRate: 0,
      };
    }

    function createEmptyPrimaryBonus() {
      return { str: 0, int: 0, vit: 0, agi: 0, luck: 0 };
    }

    function ensureAcquiredOrder(item) {
      if (!item) return item;
      if (typeof item.acquiredOrder !== "number") {
        item.acquiredOrder = inventoryAcquireSequence++;
      }
      if (typeof item.favorite !== "boolean") {
        item.favorite = false;
      }
      return item;
    }

    function getAcquiredOrder(item, fallback) {
      if (typeof item?.acquiredOrder === "number") return item.acquiredOrder;
      return fallback;
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function weightedRandom(options, fallback = null) {
      if (!options?.length) return fallback;
      const total = options.reduce((sum, opt) => sum + (opt.weight ?? 0), 0);
      if (total <= 0) return options[0] ?? fallback;
      let roll = Math.random() * total;
      for (const opt of options) {
        roll -= opt.weight ?? 0;
        if (roll <= 0) return opt;
      }
      return options[options.length - 1] ?? fallback;
    }

    function rollValueInRange(range, precision = 0) {
      const [min, max] = range;
      const raw = min + Math.random() * (max - min);
      if (precision > 0) {
        const base = 10 ** precision;
        return Math.round(raw * base) / base;
      }
      return Math.round(raw);
    }

    function rollStatValue(def, rarity) {
      const [min, max] = def.range;
      const rarityScale = 1 + (rarity?.rank ?? 0) * 0.2;
      const raw = min + Math.random() * (max - min);
      const scaled = raw * rarityScale;
      const precision = def.precision ?? (def.unit === "%" ? 1 : 0);
      if (precision > 0) {
        const base = 10 ** precision;
        return Math.round(scaled * base) / base;
      }
      return Math.round(scaled);
    }

    function rollTemplateOptions(definitions, rarity) {
      const primaryBonus = createEmptyPrimaryBonus();
      const bonus = createEmptyBonus();
      const entries = (definitions || [])
        .map((def) => {
          const baseDef = EQUIPMENT_STAT_BY_KEY[def.key];
          if (!baseDef?.range) return null;
          const merged = {
            ...baseDef,
            ...def,
            range: def.range || baseDef.range,
            unit: def.unit ?? baseDef.unit,
            precision: def.precision ?? baseDef.precision,
          };
          const value = rollStatValue(merged, rarity);
          applyOptionToBonus(merged, value, primaryBonus, bonus);
          return { key: merged.key, label: merged.label, unit: merged.unit, type: merged.type, value };
        })
        .filter(Boolean);

      return { entries, primaryBonus, bonus };
    }

    function pickStatOptions(count) {
      const pool = [...EQUIPMENT_STAT_POOL];
      const options = [];
      for (let i = pool.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      for (let i = 0; i < count && i < pool.length; i += 1) {
        options.push(pool[i]);
      }
      return options;
    }

    function applyOptionToBonus(option, value, primaryBonus, bonus) {
      if (option.type === "primary") {
        primaryBonus[option.key] = (primaryBonus[option.key] ?? 0) + value;
      } else {
        bonus[option.key] = (bonus[option.key] ?? 0) + value;
      }
    }

    function generateEquipmentOptions(rarity, optionCount) {
      const primaryBonus = createEmptyPrimaryBonus();
      const bonus = createEmptyBonus();
      const entries = pickStatOptions(optionCount).map((option) => {
        const value = rollStatValue(option, rarity);
        applyOptionToBonus(option, value, primaryBonus, bonus);
        return { key: option.key, label: option.label, unit: option.unit, type: option.type, value };
      });
      return { entries, primaryBonus, bonus };
    }

    function getEquipmentTierKeyForFloor(floor) {
      const boundary = EQUIPMENT_TIER_BOUNDARIES.find((entry) => floor <= entry.maxFloor);
      return boundary?.key || "late";
    }

    function pickEquipmentTemplate(slotKey) {
      const list = EQUIPMENT_TEMPLATE_LIBRARY[slotKey];
      if (!list?.length) return null;
      const tierOrder = ["early", "mid", "late"];
      const currentTier = getEquipmentTierKeyForFloor(game.floor || 1);
      const currentIndex = tierOrder.indexOf(currentTier);
      const candidates = list.filter((entry) => {
        if (!entry.tier) return true;
        const idx = tierOrder.indexOf(entry.tier);
        return idx === -1 ? true : idx <= currentIndex;
      });
      const preferredTier = tierOrder[Math.max(0, currentIndex)];
      const prioritized = candidates.filter((entry) => (entry.tier || "early") === preferredTier);
      const pool = prioritized.length ? prioritized : candidates.length ? candidates : list;
      return pool[randomInt(0, pool.length - 1)];
    }

    function pickLegendaryEquipment(slotKey, preferredKey) {
      const list = LEGENDARY_EQUIPMENT_LIBRARY[slotKey];
      if (!list?.length) return null;
      if (preferredKey) {
        const found = list.find((entry) => entry.key === preferredKey);
        if (found) return found;
      }
      return list[randomInt(0, list.length - 1)];
    }

    function rollLegendaryUniqueOption(def) {
      if (!def?.unique) return null;
      const precision = def.unique.precision ?? (def.unique.unit === "%" ? 1 : 0);
      const value = def.unique.range ? rollValueInRange(def.unique.range, precision) : null;
      const replaced = def.unique.effect?.replace(
        "{value}",
        value != null ? `${value}${def.unique.unit || ""}` : ""
      );
      return { itemName: def.name, option: { name: def.unique.name, effect: replaced || def.unique.effect } };
    }

    function pickTitle(titles) {
      if (!titles?.length) return null;
      return titles[randomInt(0, titles.length - 1)];
    }

    function generateTitleOptions(title, rarity) {
      const primaryBonus = createEmptyPrimaryBonus();
      const bonus = createEmptyBonus();
      if (!title?.options?.length) return { entries: [], primaryBonus, bonus };

      const entries = title.options
        .map((key) => {
          const def = EQUIPMENT_STAT_BY_KEY[key];
          if (!def) return null;
          const value = rollStatValue(def, rarity);
          applyOptionToBonus(def, value, primaryBonus, bonus);
          return { key: def.key, label: def.label, unit: def.unit, type: def.type, value };
        })
        .filter(Boolean);

      return { entries, primaryBonus, bonus };
    }

    function rollTitleRank(rarity, titleBonus) {
      const maxRank = Math.min(3, (rarity?.rank ?? 0) + 1);
      const baseWeights = TITLE_RANK_WEIGHTS.map((entry) => ({ ...entry }));
      const bonus = Math.max(0, titleBonus || 0);
      baseWeights.forEach((entry) => {
        if (entry.rank === 1) entry.weight = Math.max(5, entry.weight - bonus * 0.4);
        if (entry.rank === 2) entry.weight += bonus * 0.45;
        if (entry.rank === 3) entry.weight += bonus * 0.35;
      });
      const filtered = baseWeights.filter((entry) => entry.rank <= maxRank);
      return weightedRandom(filtered, { rank: 1 })?.rank ?? 1;
    }

    function rollEquipmentTitle(pool, rarity, titleBonus, baseChance) {
      const bonus = Math.max(0, titleBonus || 0);
      const chance = Math.min(95, baseChance + bonus);
      const defaultResult = {
        title: null,
        options: { entries: [], primaryBonus: createEmptyPrimaryBonus(), bonus: createEmptyBonus() },
      };
      if (!pool?.length) return defaultResult;
      if (Math.random() * 100 >= chance) return defaultResult;
      const rank = rollTitleRank(rarity, bonus);
      const candidates = pool.filter((title) => title.rank <= rank);
      const fallbackRank = Math.min(3, (rarity?.rank ?? 0) + 1);
      const fallbackPool = pool.filter((title) => title.rank <= fallbackRank);
      const title = pickTitle(candidates.length ? candidates : fallbackPool.length ? fallbackPool : pool);
      const options = generateTitleOptions(title, rarity);
      return { title, options };
    }

    function formatEquipmentValue(entry) {
      const sign = entry.value >= 0 ? "+" : "";
      const unit = entry.unit || "";
      return `${entry.label} ${sign}${entry.value}${unit}`;
    }

    function buildEquipmentName(slotKey, rarity, prefixTitle, suffixTitle, baseName) {
      const slotLabel = EQUIPMENT_SLOTS[slotKey]?.label || slotKey;
      const prefixPool = {
        normal: ["Á≤óÂâä„Çä„Å™", "Ë¶ãÊÖ£„Çå„Åü", "ÊâãËªΩ„Å™"],
        magic: ["È≠îÊ∞ó„ÇíÂ∏Ø„Å≥„Åü", "Á†î„ÅéÊæÑ„Åæ„Åï„Çå„Åü", "Âø´Ê¥ª„Å™"],
        rare: ["Á•ùÁ¶è„Åï„Çå„Åü", "Á≤æÁ∑ª„Å™", "Ëã±ÈõÑ„ÅÆ"],
        legendary: ["‰ºùË™¨„ÅÆ", "Á•ûË©±„ÅÆ", "ÂîØ‰∏ÄÁÑ°‰∫å„ÅÆ"],
      };
      const list = prefixPool[rarity.key] || ["Ë¨é„ÇÅ„ÅÑ„Åü"];
      const rarityPrefix = list[randomInt(0, list.length - 1)];
      const prefix = prefixTitle?.name || rarityPrefix;
      const suffix = suffixTitle?.name ? `„Éª${suffixTitle.name}` : "";
      const base = baseName || slotLabel;
      return `${prefix} ${base}${suffix}`;
    }

    function createEquipmentItem(slotKey, rarityKey, { legendaryKey = "", titleBonus = 0 } = {}) {
      const slot = EQUIPMENT_SLOTS[slotKey] ? slotKey : "weapon";
      const rarity = EQUIPMENT_RARITIES[rarityKey] || EQUIPMENT_RARITIES.normal;
      const template = rarityKey === "legendary" ? pickLegendaryEquipment(slot, legendaryKey) : pickEquipmentTemplate(slot);
      const base = template?.base?.length
        ? rollTemplateOptions(template.base, rarity)
        : generateEquipmentOptions(rarity, rarity.baseOptions);
      const random = generateEquipmentOptions(rarity, rarity.randomOptions);
      const prefixRoll = rollEquipmentTitle(EQUIPMENT_TITLE_PREFIXES, rarity, titleBonus, TITLE_BASE_CHANCE.prefix);
      const suffixRoll = rollEquipmentTitle(EQUIPMENT_TITLE_SUFFIXES, rarity, titleBonus, TITLE_BASE_CHANCE.suffix);
      const prefixTitle = prefixRoll.title;
      const suffixTitle = suffixRoll.title;
      const prefixOptions = prefixRoll.options || { entries: [], primaryBonus: createEmptyPrimaryBonus(), bonus: createEmptyBonus() };
      const suffixOptions = suffixRoll.options || { entries: [], primaryBonus: createEmptyPrimaryBonus(), bonus: createEmptyBonus() };
      const uniqueOption = rarityKey === "legendary" ? rollLegendaryUniqueOption(template) : null;

      const primaryBonus = createEmptyPrimaryBonus();
      const bonus = createEmptyBonus();
      [...base.entries, ...random.entries, ...prefixOptions.entries, ...suffixOptions.entries].forEach((entry) => {
        applyOptionToBonus(entry, entry.value, primaryBonus, bonus);
      });

      const name = buildEquipmentName(slot, rarity, prefixTitle, suffixTitle, template?.name || uniqueOption?.itemName);

      const prefixAffix = prefixTitle
        ? { ...prefixTitle, options: prefixOptions.entries }
        : null;
      const suffixAffix = suffixTitle
        ? { ...suffixTitle, options: suffixOptions.entries }
        : null;

      return ensureAcquiredOrder({
        id: generateId("eq"),
        type: "equipment",
        slot,
        name,
        desc: "„Éá„Éê„ÉÉ„Ç∞„ÅßÁîüÊàê„Åó„ÅüË£ÖÂÇôÂìÅ",
        rarity: rarity.rank,
        equipment: {
          slot,
          rarity: rarity.key,
          rarityLabel: rarity.label,
          color: rarity.color,
          baseOptions: base.entries,
          randomOptions: random.entries,
          prefix: prefixAffix,
          suffix: suffixAffix,
          uniqueOptions: uniqueOption?.option ? [uniqueOption.option] : [],
        },
        primaryBonus,
        bonus,
      });
    }

    function applyItemRarityColor(element, item) {
      if (!element) return;
      const classNames = ["rarity-normal", "rarity-magic", "rarity-rare", "rarity-legendary"];
      classNames.forEach((cls) => element.classList.remove(cls));
      const rarityKey = item?.equipment?.rarity;
      if (!rarityKey || !EQUIPMENT_RARITIES[rarityKey]) {
        return;
      }
      element.classList.add(`rarity-${rarityKey}`);
    }

    function getEquipmentBonuses(item) {
      const primary = createEmptyPrimaryBonus();
      const secondary = createEmptyBonus();
      if (!item?.equipment) return { primary, secondary };

      if (item.primaryBonus || item.bonus) {
        Object.assign(primary, item.primaryBonus || {});
        Object.assign(secondary, item.bonus || {});
        return { primary, secondary };
      }

      const collect = (options) => {
        (options || []).forEach((opt) => {
          if (!opt) return;
          applyOptionToBonus(opt, opt.value, primary, secondary);
        });
      };

      collect(item.equipment.baseOptions);
      collect(item.equipment.randomOptions);
      collect(item.equipment.prefix?.options);
      collect(item.equipment.suffix?.options);
      return { primary, secondary };
    }

    function diffEquipmentBonuses(newItem, equippedItem) {
      const next = getEquipmentBonuses(newItem);
      const current = getEquipmentBonuses(equippedItem);
      const diffs = [];

      const pushDiff = (key, delta) => {
        if (!delta) return;
        const def = EQUIPMENT_STAT_BY_KEY[key];
        const unit = def?.unit || "";
        const precision = def?.precision ?? (unit === "%" ? 1 : 0);
        const value = Math.abs(delta);
        const formatted = precision ? value.toFixed(precision) : Math.round(value).toString();
        const label = def?.label || key;
        diffs.push({
          key,
          label,
          unit,
          delta,
          text: `${label} ${delta > 0 ? "+" : "-"}${formatted}${unit}`,
        });
      };

      const aggregateKeys = (objA, objB) => Array.from(new Set([...Object.keys(objA), ...Object.keys(objB)]));
      aggregateKeys(next.primary, current.primary).forEach((key) => {
        const delta = (next.primary?.[key] || 0) - (current.primary?.[key] || 0);
        pushDiff(key, delta);
      });
      aggregateKeys(next.secondary, current.secondary).forEach((key) => {
        const delta = (next.secondary?.[key] || 0) - (current.secondary?.[key] || 0);
        pushDiff(key, delta);
      });

      return diffs;
    }

    function getInventorySlotKey(item) {
      if (!item) return null;
      if (item.slot) return item.slot;
      if (item.equipmentSlot) return item.equipmentSlot;
      if (item.equipment?.slot) return item.equipment.slot;
      return null;
    }

    function isItemInventory(entry) {
      if (!entry?.item) return false;
      const slotKey = getInventorySlotKey(entry.item);
      return !slotKey;
    }

    function createPotionInventoryItem(potion, { description } = {}) {
      const kind = potion.type === "mp" ? "MP" : "HP";
      const desc = description || `${kind}„Çí${potion.amount}ÂõûÂæ© / Ê∂àË≤ª${potion.useCost ?? 25}%`;
      return {
        id: `inv-${potion.id}`,
        name: potion.name,
        desc,
        type: "potion",
        potion: { ...potion },
      };
    }

      // „Ç∞„É≠„Éº„Éê„É´ÂÜçË©ï‰æ°ÊôÇ„Åß„ÇÇÂÜçÂÆ£Ë®Ä„Ç®„É©„Éº„ÇíÂá∫„Åï„Å™„ÅÑ„Çà„ÅÜ„ÄÅ„Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁµåÁî±„ÅßÂàùÊúüÂåñ
      if (typeof globalThis.SKILL_MAX_LEVEL === "undefined") {
        globalThis.SKILL_MAX_LEVEL = 50;
      }
      if (typeof globalThis.ACTIVE_SKILL_SLOT_LIMIT === "undefined") {
        globalThis.ACTIVE_SKILL_SLOT_LIMIT = 4;
      }

      const SKILL_MAX_LEVEL = globalThis.SKILL_MAX_LEVEL;
      const ACTIVE_SKILL_SLOT_LIMIT = globalThis.ACTIVE_SKILL_SLOT_LIMIT;

    const ACTIVE_UNLOCK_SCHEDULE = [1, 10, 20, 30, 40];
    const PASSIVE_UNLOCK_SCHEDULE = [10, 10, 20, 20, 30, 30, 40, 40, 50, 50];
    const THRESHOLD_MULTIPLIERS = { 10: 1.6, 30: 2, 50: 2.4 };

    function applyUnlockPattern(definitions) {
      const tracker = {};
      definitions.forEach((skill) => {
        const state = tracker[skill.category] || { active: 0, passive: 0 };
        tracker[skill.category] = state;
        if (skill.type === "active") {
          const level = ACTIVE_UNLOCK_SCHEDULE[Math.min(state.active, ACTIVE_UNLOCK_SCHEDULE.length - 1)];
          skill.unlockLevel = level;
          state.active += 1;
        } else {
          const level = PASSIVE_UNLOCK_SCHEDULE[Math.min(state.passive, PASSIVE_UNLOCK_SCHEDULE.length - 1)];
          skill.unlockLevel = level;
          state.passive += 1;
        }
      });
    }

    function amplifyThresholdBonuses(thresholds = []) {
      return thresholds.map((threshold) => {
        const multiplier = THRESHOLD_MULTIPLIERS[threshold.level] || 1.8;
        const bonus = {};
        Object.entries(threshold.bonus || {}).forEach(([key, value]) => {
          if (typeof value !== "number") return;
          bonus[key] = Number((value * multiplier).toFixed(2));
        });
        return { ...threshold, bonus, effect: undefined };
      });
    }

    const player = {
      name: "„Éó„É¨„Ç§„É§„Éº",
      level: 1,
      exp: 0,
      expToLevel: 20,
      hp: 0,
      mp: 0,
      maxHp: 0,
      maxMp: 0,
      atk: 0,
      def: 0,
      spd: 0,
      accuracy: 0,
      evade: 0,
      attackCount: 1,
      attacksRemaining: 1,
      base: {
        hp: 80,
        mp: 30,
        physAtk: 10,
        magAtk: 8,
        physDef: 4,
        magDef: 4,
        speed: 4,
      },
      primary: {
        str: { label: "Âäõ", base: 1, bonus: 0 },
        int: { label: "Áü•Ë≠ò", base: 1, bonus: 0 },
        vit: { label: "‰ΩìÂäõ", base: 1, bonus: 0 },
        agi: { label: "ÊïèÊç∑", base: 1, bonus: 0 },
        luck: { label: "ÈÅã", base: 1, bonus: 0 },
      },
      allocations: {
        str: 0,
        int: 0,
        vit: 0,
        agi: 0,
        luck: 0,
      },
      bonus: createEmptyBonus(),
      baseBonus: createEmptyBonus(),
      equipmentBonus: createEmptyBonus(),
      equipmentPrimaryBonus: createEmptyPrimaryBonus(),
      equipment: {
        head: null,
        body: null,
        hands: null,
        feet: null,
        weapon: null,
        subWeapon: null,
        accessory1: null,
        accessory2: null,
      },
      gold: 0,
      statPoints: 0,
      skillPoints: 0,
      buffs: { guard: 0, haste: 0, focus: 0 },
      resist: { control: 0, dot: 0, debuff: 0 },
      statuses: [],
      inventory: {
        items: [
          ensureAcquiredOrder(createPotionInventoryItem({
            id: "potion-hp-small",
            name: "ÂõûÂæ©„Éù„Éº„Ç∑„Éß„É≥ (Â∞è)",
            short: "HPÂ∞è",
            type: "hp",
            amount: 24,
            useCost: 30,
            fullness: 100,
            maxFullness: 100,
            icon: "üß™",
          })),
          ensureAcquiredOrder(createPotionInventoryItem({
            id: "potion-hp-medium",
            name: "ÂõûÂæ©„Éù„Éº„Ç∑„Éß„É≥ (‰∏≠)",
            short: "HP‰∏≠",
            type: "hp",
            amount: 45,
            useCost: 40,
            fullness: 100,
            maxFullness: 100,
            icon: "üß™",
          })),
          ensureAcquiredOrder(
            createPotionInventoryItem(
              {
                id: "potion-hp-large",
                name: "ÂõûÂæ©„Éù„Éº„Ç∑„Éß„É≥ (Â§ß)",
                short: "HPÂ§ß",
                type: "hp",
                amount: 80,
                useCost: 55,
                fullness: 100,
                maxFullness: 100,
                icon: "üß™",
              },
              { description: "Â§ß„Åç„ÅèÂõûÂæ©„Åô„ÇãÈ´òÁ¥ö„Éù„Éº„Ç∑„Éß„É≥" }
            )
          ),
        ],
      },
      potions: [
        {
          id: "potion-hp-small",
          name: "„Åó„Çá„Åº„ÅÑHP„Éù„Éº„Ç∑„Éß„É≥",
          short: "HP",
          type: "hp",
          amount: 24,
          useCost: 35,
          fullness: 100,
          maxFullness: 100,
          icon: "üß™",
        },
        {
          id: "potion-mp-small",
          name: "„Åó„Çá„Åº„ÅÑMP„Éù„Éº„Ç∑„Éß„É≥",
          short: "MP",
          type: "mp",
          amount: 12,
          useCost: 30,
          fullness: 100,
          maxFullness: 100,
          icon: "üîÆ",
        },
      ],
      activeSkillSlots: Array.from({ length: ACTIVE_SKILL_SLOT_LIMIT }, () => ({ skillKey: null, cooldownRemaining: 0 })),
    };

    const game = {
      floor: 1,
      enemies: [],
      turnQueue: [],
      awaitingInput: false,
      defeatedBosses: 0,
    };

    let lastDerivedStats = null;

    const SKILL_CATEGORIES = ["Ââ£Â£´", "È≠îÊ≥ï", "ËÅñËÅ∑", "Âê∏Ë°Ä"];

    const SKILL_DEFINITIONS = [
      // Ââ£Â£´Ôºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÔºâ
      {
        key: "flurryBlade",
        name: "ÈÄ£ÊíÉÊñ¨",
        desc: "ÁñæÈ¢®„ÅÆ„Åî„Å®„ÅçÈÄ£ÊíÉ„ÇíÂè©„ÅçËæº„Åø„ÄÅÊâãÊï∞„ÅßÂúßÂÄí„Åô„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "active",
        unlockLevel: 1,
        scaling: { perLevel: { physAtk: 1.2, critRate: 0.1 } },
        thresholds: [
          { level: 10, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§10: „ÇØ„É™Áéá+2%" },
          { level: 30, bonus: { speed: 1.5 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈÄüÂ∫¶+1.5" },
          { level: 50, bonus: { critDamage: 10 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+10%" },
        ],
        activation: { cooldown: 4, mpCost: 5, effect: "2ÈÄ£ÊíÉ„ÇíË°å„ÅÑ„ÄÅ‰∏é„ÉÄ„É°„Å´Âê∏Âèé„Çí‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "guardStance",
        name: "ÂÆàÂã¢Êßã„Åà",
        desc: "Áõæ„Å®Ââ£„ÇíÈ´ò„ÅèÊé≤„Åí„ÄÅ‰ª≤Èñì„Åî„Å®ÂÆà„ÇãÈò≤Â£Å„Å®„Å™„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "active",
        unlockLevel: 3,
        scaling: { perLevel: { physDef: 0.9, damageReduction: 0.3 } },
        thresholds: [
          { level: 10, bonus: { block: 3 }, effect: "ÈñæÂÄ§10: „Éñ„É≠„ÉÉ„ÇØ+3%" },
          { level: 30, bonus: { barrier: 12 }, effect: "ÈñæÂÄ§30: „Éê„É™„Ç¢+12" },
          { level: 50, bonus: { damageReduction: 4 }, effect: "ÈñæÂÄ§50: Ë¢´„ÉÄ„É°-4%" },
        ],
        activation: { cooldown: 5, mpCost: 6, effect: "Ê¨°„ÅÆÂèó„Åë„Çã„ÉÄ„É°„Éº„Ç∏„ÇíÂ§ßÂπÖËªΩÊ∏õ„Åó„ÄÅÂèçÊíÉ„ÇíÊ∫ñÂÇô", slotCost: 1 },
      },
      {
        key: "skyBreaker",
        name: "Ë£ÇÁ©∫Á™Å„Åç",
        desc: "Á©∫Èñì„ÇíÊñ≠„Å°Âàá„ÇãÂã¢„ÅÑ„ÅßÁ™ÅÈÄ≤„Åó„ÄÅË£ÖÁî≤„ÇíÂàá„ÇäË£Ç„Åè„ÄÇ",
        category: "Ââ£Â£´",
        type: "active",
        unlockLevel: 6,
        scaling: { perLevel: { physAtk: 1, physPen: 0.5 } },
        thresholds: [
          { level: 10, bonus: { speed: 1 }, effect: "ÈñæÂÄ§10: Ë°åÂãïÈÄüÂ∫¶+1" },
          { level: 30, bonus: { physPen: 6 }, effect: "ÈñæÂÄ§30: Áâ©ÁêÜË≤´ÈÄö+6%" },
          { level: 50, bonus: { critRate: 3 }, effect: "ÈñæÂÄ§50: „ÇØ„É™Áéá+3%" },
        ],
        activation: { cooldown: 3, mpCost: 4, effect: "Á™ÅÈÄ≤„Åó„Å¶Èò≤Âæ°„ÇíÁÑ°Ë¶ñ„Åó„Åü‰∏ÄÊíÉ", slotCost: 1 },
      },
      {
        key: "drawTechnique",
        name: "Â±ÖÂêà„ÅÆÊ•µ„Åø",
        desc: "Èûò„Åã„ÇâÊäú„ÅèÁû¨Èñì„Å´ÂÖ®Âäõ„ÇíËæº„ÇÅ„ÄÅ‰∏ÄÂàÄ„ÅßÊ±∫„ÇÅ„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "active",
        unlockLevel: 10,
        scaling: { perLevel: { physAtk: 1.4, critDamage: 0.6 } },
        thresholds: [
          { level: 10, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§10: „ÇØ„É™Áéá+2%" },
          { level: 30, bonus: { speed: 2 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈÄüÂ∫¶+2" },
          { level: 50, bonus: { physPen: 5 }, effect: "ÈñæÂÄ§50: Áâ©ÁêÜË≤´ÈÄö+5%" },
        ],
        activation: { cooldown: 6, mpCost: 7, effect: "ÂàùÊâã„ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá„ÅåÂ§ßÂπÖ‰∏äÊòá„Åô„ÇãÈ´òÈÄüÊñ¨ÊíÉ", slotCost: 1 },
      },
      {
        key: "galeDance",
        name: "ÂàÉÈ¢®‰π±Ëàû",
        desc: "ÊóãÈ¢®„ÅÆ„Çà„ÅÜ„Å´Ëàû„ÅÑ„ÄÅÂ∫ÉÁØÑÂõ≤„ÇíÂàá„ÇäÂàª„ÇÄ„ÄÇ",
        category: "Ââ£Â£´",
        type: "active",
        unlockLevel: 14,
        scaling: { perLevel: { physAtk: 0.9, speed: 0.4 } },
        thresholds: [
          { level: 10, bonus: { block: 2 }, effect: "ÈñæÂÄ§10: „Éñ„É≠„ÉÉ„ÇØ+2%" },
          { level: 30, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§30: CTÁü≠Á∏Æ+2%" },
          { level: 50, bonus: { damageReduction: 3 }, effect: "ÈñæÂÄ§50: Ë¢´„ÉÄ„É°-3%" },
        ],
        activation: { cooldown: 4, mpCost: 6, effect: "Âë®Âõ≤„ÅÆÊïµ„Å∏3„Éí„ÉÉ„Éà„ÅÆÊñ¨ÊíÉ„ÇíÊîæ„Å§", slotCost: 1 },
      },
      // Ââ£Â£´Ôºà„Éë„ÉÉ„Ç∑„ÉñÔºâ
      {
        key: "bladeDiscipline",
        name: "Ââ£ÊäÄÈçõÈå¨",
        desc: "Âü∫Êú¨„Å´Âø†ÂÆü„Å™ÈçõÈå¨„Åß‰ΩìÂππ„Å®ÂàÉÁ≠ã„ÇíÊï¥„Åà„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 1,
        scaling: { perLevel: { physAtk: 1, speed: 0.2 } },
        thresholds: [
          { level: 10, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§10: „ÇØ„É™Áéá+2%" },
          { level: 30, bonus: { physPen: 4, speed: 1 }, effect: "ÈñæÂÄ§30: Áâ©ÁêÜË≤´ÈÄö+4%„ÄÅÈÄüÂ∫¶+1" },
          { level: 50, bonus: { critDamage: 8 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+8%" },
        ],
      },
      {
        key: "ironBody",
        name: "ÈâÑË∫´",
        desc: "Èçõ„ÅàÊäú„Åã„Çå„ÅüÁ≠ãËÇâ„ÅßË°ùÊíÉ„Çí„ÅÑ„Å™„Åô„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 2,
        scaling: { perLevel: { hp: 1.2, physDef: 0.8 } },
        thresholds: [
          { level: 10, bonus: { block: 2 }, effect: "ÈñæÂÄ§10: „Éñ„É≠„ÉÉ„ÇØ+2%" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { hp: 30 }, effect: "ÈñæÂÄ§50: ÊúÄÂ§ßHP+30" },
        ],
      },
      {
        key: "battleFocus",
        name: "Êà¶Ê∞óÈõÜ‰∏≠",
        desc: "Êà¶Èóò‰∏≠„ÅÆÈõÜ‰∏≠„ÇíÈ´ò„ÇÅ„ÄÅÁÑ°ÈßÑ„Å™„ÅèÂäõ„ÇíÊåØ„Çã„ÅÜ„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 4,
        scaling: { perLevel: { speed: 0.3, critRate: 0.15 } },
        thresholds: [
          { level: 10, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§10: CTÁü≠Á∏Æ+2%" },
          { level: 30, bonus: { critDamage: 6 }, effect: "ÈñæÂÄ§30: „ÇØ„É™„ÉÄ„É°+6%" },
          { level: 50, bonus: { namedRate: 3 }, effect: "ÈñæÂÄ§50: „Éç„Éº„É†„ÉâÁéá+3%" },
        ],
      },
      {
        key: "riposte",
        name: "Ëøî„ÅóÂàÉ",
        desc: "Âèó„ÅëÊµÅ„Åó„Åã„Çâ„ÅÆÂèçÊíÉ„ÇíÁøíÁÜü„Åô„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 5,
        scaling: { perLevel: { block: 0.3, critDamage: 0.3 } },
        thresholds: [
          { level: 10, bonus: { physAtk: 6 }, effect: "ÈñæÂÄ§10: Áâ©Êîª+6" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { physPen: 4 }, effect: "ÈñæÂÄ§50: Áâ©ÁêÜË≤´ÈÄö+4%" },
        ],
      },
      {
        key: "frontlineCommander",
        name: "ÂâçÁ∑öÊåáÊèÆ",
        desc: "Âë≥Êñπ„ÇíÈºìËàû„Åó„ÄÅÁ™ÅÊíÉ„ÅÆÂè∑‰ª§„ÇíÈ£õ„Å∞„Åô„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 8,
        scaling: { perLevel: { hp: 0.8, speed: 0.3 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
          { level: 30, bonus: { barrier: 6 }, effect: "ÈñæÂÄ§30: „Éê„É™„Ç¢+6" },
          { level: 50, bonus: { goldChance: 4 }, effect: "ÈñæÂÄ§50: „Ç¥„Éº„É´„ÉâÁéá+4%" },
        ],
      },
      {
        key: "unbreakableWill",
        name: "‰∏çÂ±à„ÅÆÊÑèÂøó",
        desc: "ÂÄí„Çå„Å¨Ë¶öÊÇü„ÅåË∫´‰ΩìËÉΩÂäõ„ÇíÊäº„Åó‰∏ä„Åí„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 12,
        scaling: { perLevel: { damageReduction: 0.25, hpRegen: 0.06 } },
        thresholds: [
          { level: 10, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§10: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 30, bonus: { hp: 20 }, effect: "ÈñæÂÄ§30: ÊúÄÂ§ßHP+20" },
          { level: 50, bonus: { dotResist: 4 }, effect: "ÈñæÂÄ§50: DoTËÄêÊÄß+4%" },
        ],
      },
      {
        key: "weaponPolish",
        name: "Ê≠¶Âô®Êï¥ÂÇô",
        desc: "ÂàÉ„ÇíÁ£®„Åç„ÄÅÈáçÂøÉ„ÇíÊï¥„Åà„ÄÅÊâ±„ÅÑ„ÇÑ„Åô„Åï„Çí‰∏ä„Åí„Çã„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 16,
        scaling: { perLevel: { physAtk: 0.7, physPen: 0.2 } },
        thresholds: [
          { level: 10, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§10: „É¨„Ç¢Áéá+3%" },
          { level: 30, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§30: „ÇØ„É™Áéá+2%" },
          { level: 50, bonus: { critDamage: 5 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+5%" },
        ],
      },
      {
        key: "counterTraining",
        name: "ËøéÊíÉË®ìÁ∑¥",
        desc: "ÂèçÊíÉ„ÅÆÂßøÂã¢„ÇíÂæπÂ∫ïÁöÑ„Å´Âè©„ÅçËæº„ÇÄ„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 20,
        scaling: { perLevel: { block: 0.4, physAtk: 0.4 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 1 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-1%" },
          { level: 30, bonus: { physPen: 3 }, effect: "ÈñæÂÄ§30: Áâ©ÁêÜË≤´ÈÄö+3%" },
          { level: 50, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§50: CTÁü≠Á∏Æ+2%" },
        ],
      },
      {
        key: "veteranFootwork",
        name: "Ê≠¥Êà¶„ÅÆË∂≥„Åï„Å∞„Åç",
        desc: "Êà¶Â†¥„ÅßÂüπ„Å£„ÅüË∏è„ÅøËæº„Åø„Å®Èõ¢ËÑ±„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 24,
        scaling: { perLevel: { speed: 0.5, damageReduction: 0.15 } },
        thresholds: [
          { level: 10, bonus: { magDef: 4 }, effect: "ÈñæÂÄ§10: È≠îÈò≤+4" },
          { level: 30, bonus: { physDef: 4 }, effect: "ÈñæÂÄ§30: Áâ©Èò≤+4" },
          { level: 50, bonus: { controlResist: 4 }, effect: "ÈñæÂÄ§50: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+4%" },
        ],
      },
      {
        key: "heroicLineage",
        name: "Ê≠¶ÂêçÁ∂ôÊâø",
        desc: "Âèó„ÅëÁ∂ô„ÅÑ„Å†Êà¶ÊäÄ„Åå„Åï„Çâ„Å™„ÇãÂäõ„ÇíÂºï„ÅçÂá∫„Åô„ÄÇ",
        category: "Ââ£Â£´",
        type: "passive",
        unlockLevel: 28,
        scaling: { perLevel: { critDamage: 0.5, hp: 0.6 } },
        thresholds: [
          { level: 10, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§10: Áß∞Âè∑Áéá+2%" },
          { level: 30, bonus: { dropRate: 4 }, effect: "ÈñæÂÄ§30: „Éâ„É≠„ÉÉ„ÉóÁéá+4%" },
          { level: 50, bonus: { rarity: 4 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+4%" },
        ],
      },
      // È≠îÊ≥ïÔºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÔºâ
      {
        key: "arcaneFlow",
        name: "È≠îÂäõÂæ™Áí∞",
        desc: "È≠îÂäõ„ÅÆÊµÅ„Çå„ÇíÊï¥„Åà„ÄÅÊà¶ÈóòÁ∂ôÁ∂öÂäõ„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "active",
        unlockLevel: 1,
        scaling: { perLevel: { mp: 1, magAtk: 0.6 } },
        thresholds: [
          { level: 10, bonus: { cooldown: 1 }, effect: "ÈñæÂÄ§10: CTÁü≠Á∏Æ+1%" },
          { level: 30, bonus: { magPen: 3 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+3%" },
          { level: 50, bonus: { rarity: 5, dropRate: 5 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢/„Éâ„É≠„ÉÉ„ÉóÁéá+5%" },
        ],
        activation: { cooldown: 4, mpCost: 3, effect: "MP„ÇíÂç≥ÊôÇÂõûÂæ©„Åó„ÄÅÊ¨°„ÅÆÈ≠îÊ≥ï„ÉÄ„É°„Éº„Ç∏Âº∑Âåñ", slotCost: 1 },
      },
      {
        key: "frostNova",
        name: "„Éï„É≠„Çπ„Éà„Éé„É¥„Ç°",
        desc: "ÂÜ∑Ê∞ó„ÇíÁàÜ„Åú„Åï„Åõ„ÄÅÂë®Âõ≤„ÇíÂáç„Å¶„Å§„Åã„Åõ„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "active",
        unlockLevel: 4,
        scaling: { perLevel: { magAtk: 1.1, magPen: 0.3 } },
        thresholds: [
          { level: 10, bonus: { controlResist: 2 }, effect: "ÈñæÂÄ§10: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+2%" },
          { level: 30, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§30: CTÁü≠Á∏Æ+2%" },
          { level: 50, bonus: { dotResist: 3 }, effect: "ÈñæÂÄ§50: DoTËÄêÊÄß+3%" },
        ],
        activation: { cooldown: 4, mpCost: 7, effect: "ÁØÑÂõ≤Ê∞∑„ÉÄ„É°+ÈàçË∂≥‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "meteorCall",
        name: "„É°„ÉÜ„Ç™„Ç≥„Éº„É´",
        desc: "Êòü„ÅÆÁÇé„ÇíÂëº„Å≥„ÄÅÊïµ„ÇíÁÑº„ÅçÊâï„ÅÜ„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "active",
        unlockLevel: 8,
        scaling: { perLevel: { magAtk: 1.5, critDamage: 0.4 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 2 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+2%" },
          { level: 30, bonus: { magPen: 5 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+5%" },
          { level: 50, bonus: { critRate: 3 }, effect: "ÈñæÂÄ§50: „ÇØ„É™Áéá+3%" },
        ],
        activation: { cooldown: 6, mpCost: 10, effect: "È´òÂÄçÁéá„ÅÆÁÅ´ÁêÉ„ÇíËêΩ„Å®„ÅóËøΩÂä†„ÅßÁáÉÁÑº", slotCost: 1 },
      },
      {
        key: "runeBarrier",
        name: "„É´„Éº„É≥„Éê„É™„Ç¢",
        desc: "È≠îÊ≥ïÈô£„ÅßÈöúÂ£Å„ÇíÂ±ïÈñã„ÅóË¢´ÂÆ≥„ÇíÊäë„Åà„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "active",
        unlockLevel: 12,
        scaling: { perLevel: { magDef: 0.9, barrier: 0.6 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-2%" },
          { level: 30, bonus: { hpRegen: 0.25 }, effect: "ÈñæÂÄ§30: HPÂÜçÁîü+0.25" },
          { level: 50, bonus: { block: 2 }, effect: "ÈñæÂÄ§50: „Éñ„É≠„ÉÉ„ÇØ+2%" },
        ],
        activation: { cooldown: 5, mpCost: 6, effect: "Êï∞„Çø„Éº„É≥„Éê„É™„Ç¢„Å®È≠îÈò≤‰∏äÊòá", slotCost: 1 },
      },
      {
        key: "chronoBoost",
        name: "„ÇØ„É≠„Éé„Éñ„Éº„Çπ„Éà",
        desc: "ÊôÇÈñì„ÅÆÊµÅ„Çå„ÇíÊìç„Çä„ÄÅË°åÂãï„ÇíÂä†ÈÄü„Åô„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "active",
        unlockLevel: 16,
        scaling: { perLevel: { speed: 0.7, cooldown: 0.3 } },
        thresholds: [
          { level: 10, bonus: { magAtk: 6 }, effect: "ÈñæÂÄ§10: È≠îÊîª+6" },
          { level: 30, bonus: { controlResist: 4 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+4%" },
          { level: 50, bonus: { rarity: 4 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+4%" },
        ],
        activation: { cooldown: 5, mpCost: 8, effect: "Âë≥ÊñπÂÖ®‰Ωì„ÅÆÈÄüÂ∫¶„Å®CTÁü≠Á∏Æ„Çí‰ªò‰∏é", slotCost: 1 },
      },
      // È≠îÊ≥ïÔºà„Éë„ÉÉ„Ç∑„ÉñÔºâ
      {
        key: "manaAffinity",
        name: "„Éû„ÉäÈÅ©ÊÄß",
        desc: "È≠îÂäõ„Å®„ÅÆË¶™ÂíåÊÄß„ÅåÈ´ò„Åè„ÄÅÊâ±„ÅÑ„ÇÑ„Åô„ÅÑ„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 1,
        scaling: { perLevel: { mp: 1.5, magAtk: 0.5 } },
        thresholds: [
          { level: 10, bonus: { cooldown: 1 }, effect: "ÈñæÂÄ§10: CTÁü≠Á∏Æ+1%" },
          { level: 30, bonus: { magPen: 4 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+4%" },
          { level: 50, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§50: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
        ],
      },
      {
        key: "spellcraft",
        name: "„Çπ„Éö„É´„ÇØ„É©„Éï„Éà",
        desc: "Ë©†Âî±ÊâãÈ†Ü„ÅÆÊúÄÈÅ©Âåñ„ÅßÈ≠îÊ≥ïÂäπÁéá„Çí‰∏ä„Åí„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 3,
        scaling: { perLevel: { magAtk: 0.8, cooldown: 0.15 } },
        thresholds: [
          { level: 10, bonus: { magDef: 3 }, effect: "ÈñæÂÄ§10: È≠îÈò≤+3" },
          { level: 30, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§30: „É¨„Ç¢Áéá+3%" },
          { level: 50, bonus: { magAtk: 15 }, effect: "ÈñæÂÄ§50: È≠îÊîª+15" },
        ],
      },
      {
        key: "wisdomOfTomes",
        name: "Âè§Êõ∏„ÅÆÂè°Êô∫",
        desc: "Âè§‰ª£Êõ∏Áâ©„Åã„ÇâÂ≠¶„Çì„Å†È≠îÊ≥ïÁêÜË´ñ„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 5,
        scaling: { perLevel: { magAtk: 0.9, mp: 0.8 } },
        thresholds: [
          { level: 10, bonus: { magPen: 3 }, effect: "ÈñæÂÄ§10: È≠îÊ≥ïË≤´ÈÄö+3%" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§50: Áß∞Âè∑Áéá+2%" },
        ],
      },
      {
        key: "manaShielding",
        name: "„Éû„Éä„Ç∑„Éº„É´„Éâ",
        desc: "È≠îÂäõ„ÇíËÜú„Å®„Åó„Å¶Á∫è„ÅÑ„ÄÅË¢´ÂÆ≥„ÇíÊäëÂà∂„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 7,
        scaling: { perLevel: { magDef: 0.7, barrier: 0.4 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 1 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-1%" },
          { level: 30, bonus: { hpRegen: 0.2 }, effect: "ÈñæÂÄ§30: HPÂÜçÁîü+0.2" },
          { level: 50, bonus: { dotResist: 4 }, effect: "ÈñæÂÄ§50: DoTËÄêÊÄß+4%" },
        ],
      },
      {
        key: "coldLogic",
        name: "ÂÜ∑Âæπ„Å™Ë´ñÁêÜ",
        desc: "ÂêàÁêÜÁöÑÂà§Êñ≠„ÅßÁÑ°ÈßÑ„ÇíÂâä„Çä„ÄÅÈ≠îÂäõÂäπÁéá„ÇíÊ•µ„ÇÅ„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 9,
        scaling: { perLevel: { cooldown: 0.2, magAtk: 0.4 } },
        thresholds: [
          { level: 10, bonus: { mp: 12 }, effect: "ÈñæÂÄ§10: ÊúÄÂ§ßMP+12" },
          { level: 30, bonus: { magPen: 4 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+4%" },
          { level: 50, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+3%" },
        ],
      },
      {
        key: "elementalEcho",
        name: "ÂÖÉÁ¥†ÂÖ±È≥¥",
        desc: "Ë§áÊï∞„ÅÆÂ±ûÊÄß„ÇíÂÖ±È≥¥„Åï„Åõ„ÄÅÂ®ÅÂäõ„ÇíÂ∫ï‰∏ä„Åí„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 13,
        scaling: { perLevel: { magAtk: 1, critRate: 0.1 } },
        thresholds: [
          { level: 10, bonus: { critDamage: 4 }, effect: "ÈñæÂÄ§10: „ÇØ„É™„ÉÄ„É°+4%" },
          { level: 30, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§30: CTÁü≠Á∏Æ+2%" },
          { level: 50, bonus: { magPen: 5 }, effect: "ÈñæÂÄ§50: È≠îÊ≥ïË≤´ÈÄö+5%" },
        ],
      },
      {
        key: "forbiddenStudy",
        name: "Á¶ÅÊõ∏„ÅÆÁ†îÁ©∂",
        desc: "Âç±Èô∫„Å™È≠îË°ì„Å´„ÇÇÊâã„Çí‰º∏„Å∞„Åó„ÄÅ„Åï„Çâ„Å™„ÇãÂäõ„ÇíÂæó„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 17,
        scaling: { perLevel: { magAtk: 1.1, hpRegen: -0.02 } },
        thresholds: [
          { level: 10, bonus: { magAtk: 8 }, effect: "ÈñæÂÄ§10: È≠îÊîª+8" },
          { level: 30, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§30: „ÇØ„É™Áéá+2%" },
          { level: 50, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§50: Áß∞Âè∑Áéá+2%" },
        ],
      },
      {
        key: "arcaneHaste",
        name: "È≠îÈÄüÊ≠©Ê≥ï",
        desc: "È≠îÊ≥ï„ÅßËÑöÂäõ„ÇíË£úÂä©„Åó„ÄÅÁ¥†Êó©„ÅÑË©†Âî±„ÇíÂèØËÉΩ„Å´„Åô„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 20,
        scaling: { perLevel: { speed: 0.5, cooldown: 0.1 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 2 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+2%" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { magDef: 10 }, effect: "ÈñæÂÄ§50: È≠îÈò≤+10" },
        ],
      },
      {
        key: "manaOverflow",
        name: "È≠îÂäõÊ∫¢Âá∫",
        desc: "Ê∫¢„Çå„ÇãÈ≠îÂäõ„ÅåÊîæÂ∞ÑÁä∂„Å´ÂΩ±Èüø„Çí‰∏é„Åà„Çã„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 23,
        scaling: { perLevel: { mp: 1.2, magAtk: 0.6 } },
        thresholds: [
          { level: 10, bonus: { rarity: 2 }, effect: "ÈñæÂÄ§10: „É¨„Ç¢Áéá+2%" },
          { level: 30, bonus: { magPen: 4 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+4%" },
          { level: 50, bonus: { magAtk: 12 }, effect: "ÈñæÂÄ§50: È≠îÊîª+12" },
        ],
      },
      {
        key: "astralSight",
        name: "ÊòüÁïå„ÅÆË¶ñÈáé",
        desc: "Êòü„ÄÖ„ÅÆ‰ΩçÁΩÆ„ÇíË™≠„Åø„ÄÅÈÅãÂëΩ„ÇíË¶ãÈÄö„Åô„ÄÇ",
        category: "È≠îÊ≥ï",
        type: "passive",
        unlockLevel: 26,
        scaling: { perLevel: { critRate: 0.2, dropRate: 0.2 } },
        thresholds: [
          { level: 10, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§10: „É¨„Ç¢Áéá+3%" },
          { level: 30, bonus: { goldChance: 4 }, effect: "ÈñæÂÄ§30: „Ç¥„Éº„É´„ÉâÁéá+4%" },
          { level: 50, bonus: { titleChance: 3 }, effect: "ÈñæÂÄ§50: Áß∞Âè∑Áéá+3%" },
        ],
      },
      // ËÅñËÅ∑Ôºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÔºâ
      {
        key: "sacredWard",
        name: "ËÅñÂüü„ÅÆÂÆàË≠∑",
        desc: "Á•à„Çä„ÅÆÂä†Ë≠∑„ÅßÂë≥Êñπ„ÇíÂåÖ„Åø„ÄÅÈò≤Âæ°„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "active",
        unlockLevel: 1,
        scaling: { perLevel: { hp: 1.4, magDef: 0.6, hpRegen: 0.04 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-2%" },
          { level: 30, bonus: { barrier: 8 }, effect: "ÈñæÂÄ§30: „Éê„É™„Ç¢+8" },
          { level: 50, bonus: { controlResist: 6 }, effect: "ÈñæÂÄ§50: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+6%" },
        ],
        activation: { cooldown: 4, mpCost: 6, effect: "Âë≥ÊñπÂÖ®‰Ωì„Å´„Éê„É™„Ç¢„Å®ÂõûÂæ©„Çí‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "holySmite",
        name: "„Éõ„Éº„É™„Éº„Çπ„Éû„Ç§„Éà",
        desc: "ËÅñÂÖâ„ÅÆÊù≠„ÅßÊïµ„ÇíÊíÉ„Å°Êäú„Åè„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "active",
        unlockLevel: 4,
        scaling: { perLevel: { magAtk: 1.2, critDamage: 0.3 } },
        thresholds: [
          { level: 10, bonus: { magPen: 3 }, effect: "ÈñæÂÄ§10: È≠îÊ≥ïË≤´ÈÄö+3%" },
          { level: 30, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§30: CTÁü≠Á∏Æ+2%" },
          { level: 50, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§50: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
        ],
        activation: { cooldown: 3, mpCost: 5, effect: "ËÅñÂ±ûÊÄß„ÉÄ„É°+ÊµÑÂåñ", slotCost: 1 },
      },
      {
        key: "benediction",
        name: "Á•ùÁ¶è„ÅÆÁ•à„Çä",
        desc: "Á•û„Å∏„ÅÆÁ•à„Çä„ÅßÂë≥Êñπ„ÅÆÂÜçÁîüÂäõ„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "active",
        unlockLevel: 8,
        scaling: { perLevel: { hpRegen: 0.2, hp: 1 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 1 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-1%" },
          { level: 30, bonus: { barrier: 10 }, effect: "ÈñæÂÄ§30: „Éê„É™„Ç¢+10" },
          { level: 50, bonus: { controlResist: 5 }, effect: "ÈñæÂÄ§50: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+5%" },
        ],
        activation: { cooldown: 5, mpCost: 7, effect: "Âæê„ÄÖ„Å´ÂõûÂæ©„Åô„ÇãÂÜçÁîü„Å®ËªΩÊ∏õ‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "aegisChant",
        name: "Â∫áË≠∑„ÅÆË©†Âî±",
        desc: "Ë©†Âî±„Å´„Çà„ÇäÂÆàË≠∑„ÅÆÂ£Å„ÇíÂ±ïÈñã„Åô„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "active",
        unlockLevel: 12,
        scaling: { perLevel: { magDef: 0.8, block: 0.25 } },
        thresholds: [
          { level: 10, bonus: { hp: 16 }, effect: "ÈñæÂÄ§10: ÊúÄÂ§ßHP+16" },
          { level: 30, bonus: { magPen: 2 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+2%" },
          { level: 50, bonus: { damageReduction: 3 }, effect: "ÈñæÂÄ§50: Ë¢´„ÉÄ„É°-3%" },
        ],
        activation: { cooldown: 4, mpCost: 6, effect: "Âë≥Êñπ„Å´„Éê„É™„Ç¢„Å®„Éñ„É≠„ÉÉ„ÇØÂº∑Âåñ", slotCost: 1 },
      },
      {
        key: "judgmentRay",
        name: "Ë£Å„Åç„ÅÆÂÖâ",
        desc: "ÁΩ™„ÇíÁÖß„Çâ„ÅôÂÖâ„ÅÆÊü±„ÇíÈôç„Çç„Åô„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "active",
        unlockLevel: 16,
        scaling: { perLevel: { magAtk: 1.3, critRate: 0.15 } },
        thresholds: [
          { level: 10, bonus: { critDamage: 5 }, effect: "ÈñæÂÄ§10: „ÇØ„É™„ÉÄ„É°+5%" },
          { level: 30, bonus: { magPen: 4 }, effect: "ÈñæÂÄ§30: È≠îÊ≥ïË≤´ÈÄö+4%" },
          { level: 50, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+3%" },
        ],
        activation: { cooldown: 5, mpCost: 9, effect: "È´òÂ®ÅÂäõ„ÅÆÂÖâ„ÉÄ„É°+Âº±‰ΩìËß£Èô§", slotCost: 1 },
      },
      // ËÅñËÅ∑Ôºà„Éë„ÉÉ„Ç∑„ÉñÔºâ
      {
        key: "faith",
        name: "Êè∫„Çã„Åå„Å¨‰ø°‰ª∞",
        desc: "‰ø°‰ª∞ÂøÉ„ÅåÂ∑±„ÇíÊîØ„Åà„ÄÅÈ≠îÂäõ„ÇíÂÆâÂÆö„Åï„Åõ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 1,
        scaling: { perLevel: { hp: 1.1, magDef: 0.6 } },
        thresholds: [
          { level: 10, bonus: { hpRegen: 0.2 }, effect: "ÈñæÂÄ§10: HPÂÜçÁîü+0.2" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { barrier: 8 }, effect: "ÈñæÂÄ§50: „Éê„É™„Ç¢+8" },
        ],
      },
      {
        key: "divineSense",
        name: "ËÅñÊÑüÁü•",
        desc: "ÈÇ™ÊÇ™„ÇíÂØüÁü•„Åó„ÄÅÂç≥Â∫ß„Å´Á•ì„ÅÜÊ∫ñÂÇô„ÇíÊï¥„Åà„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 3,
        scaling: { perLevel: { controlResist: 0.25, magAtk: 0.4 } },
        thresholds: [
          { level: 10, bonus: { dotResist: 3 }, effect: "ÈñæÂÄ§10: DoTËÄêÊÄß+3%" },
          { level: 30, bonus: { rarity: 2 }, effect: "ÈñæÂÄ§30: „É¨„Ç¢Áéá+2%" },
          { level: 50, bonus: { magAtk: 10 }, effect: "ÈñæÂÄ§50: È≠îÊîª+10" },
        ],
      },
      {
        key: "healingHands",
        name: "Áôí„Åó„ÅÆÊâã",
        desc: "Áôí„ÇÑ„Åó„ÅÆÂäõ„ÇíËæº„ÇÅ„ÄÅÂõûÂæ©ÂäπÁéá„Çí‰∏ä„Åí„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 5,
        scaling: { perLevel: { hpRegen: 0.25, hp: 0.8 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 2 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+2%" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { barrier: 10 }, effect: "ÈñæÂÄ§50: „Éê„É™„Ç¢+10" },
        ],
      },
      {
        key: "guardianChoir",
        name: "ÂÆàË≠∑„ÅÆËÅñÊ≠å",
        desc: "Ê≠åÂ£∞„ÅåÂë≥Êñπ„ÅÆÂ£´Ê∞ó„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 7,
        scaling: { perLevel: { hp: 0.9, speed: 0.2 } },
        thresholds: [
          { level: 10, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§10: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 30, bonus: { hpRegen: 0.3 }, effect: "ÈñæÂÄ§30: HPÂÜçÁîü+0.3" },
          { level: 50, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§50: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
        ],
      },
      {
        key: "benison",
        name: "ÊÅµ„Åø„ÅÆÂä†Ë≠∑",
        desc: "Â∞è„Åï„Å™Â•áË∑°„ÇíÈáç„Å≠„ÄÅÈÅãÂëΩ„ÇíÂë≥Êñπ„Å´„Åô„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 9,
        scaling: { perLevel: { rarity: 0.2, dropRate: 0.2 } },
        thresholds: [
          { level: 10, bonus: { goldChance: 3 }, effect: "ÈñæÂÄ§10: „Ç¥„Éº„É´„ÉâÁéá+3%" },
          { level: 30, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§30: Áß∞Âè∑Áéá+2%" },
          { level: 50, bonus: { namedRate: 3 }, effect: "ÈñæÂÄ§50: „Éç„Éº„É†„ÉâÁéá+3%" },
        ],
      },
      {
        key: "sanctuaryPractice",
        name: "Á•ûÊÆø‰øÆÁ∑¥",
        desc: "Èï∑Âπ¥„ÅÆÂ•â‰ªï„ÅßÂæó„ÅüÊåÅ‰πÖÂäõ„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 11,
        scaling: { perLevel: { hp: 1.1, physDef: 0.5 } },
        thresholds: [
          { level: 10, bonus: { block: 2 }, effect: "ÈñæÂÄ§10: „Éñ„É≠„ÉÉ„ÇØ+2%" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { hp: 30 }, effect: "ÈñæÂÄ§50: ÊúÄÂ§ßHP+30" },
        ],
      },
      {
        key: "prayerOfFortune",
        name: "Âπ∏ÈÅã„ÅÆÁ•à„Çä",
        desc: "Â∞è„Åï„Å™Âπ∏ÈÅã„ÇíÂëº„Å≥ÂØÑ„Åõ„ÇãÁ•à„Çä„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 13,
        scaling: { perLevel: { dropRate: 0.3, rarity: 0.3 } },
        thresholds: [
          { level: 10, bonus: { goldChance: 4 }, effect: "ÈñæÂÄ§10: „Ç¥„Éº„É´„ÉâÁéá+4%" },
          { level: 30, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§30: Áß∞Âè∑Áéá+2%" },
          { level: 50, bonus: { namedRate: 4 }, effect: "ÈñæÂÄ§50: „Éç„Éº„É†„ÉâÁéá+4%" },
        ],
      },
      {
        key: "holyDiscipline",
        name: "ËÅñ„Å™„ÇãË¶èÂæã",
        desc: "Âé≥Ê†º„Å™ÁîüÊ¥ª„ÅåÂøÉË∫´„ÇíÂºï„ÅçÁ∑†„ÇÅ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 15,
        scaling: { perLevel: { speed: 0.3, magDef: 0.6 } },
        thresholds: [
          { level: 10, bonus: { hpRegen: 0.2 }, effect: "ÈñæÂÄ§10: HPÂÜçÁîü+0.2" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§50: Ë¢´„ÉÄ„É°-2%" },
        ],
      },
      {
        key: "scriptureMemory",
        name: "ËÅñÂÖ∏ÊöóÂî±",
        desc: "ËÅñÂè•„ÅåÂøÉ„ÇíÂº∑„Åè„Åó„ÄÅÁ≤æÁ•ûÂäõ„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 18,
        scaling: { perLevel: { mp: 0.9, magAtk: 0.4 } },
        thresholds: [
          { level: 10, bonus: { magPen: 2 }, effect: "ÈñæÂÄ§10: È≠îÊ≥ïË≤´ÈÄö+2%" },
          { level: 30, bonus: { cooldown: 1 }, effect: "ÈñæÂÄ§30: CTÁü≠Á∏Æ+1%" },
          { level: 50, bonus: { magDef: 10 }, effect: "ÈñæÂÄ§50: È≠îÈò≤+10" },
        ],
      },
      {
        key: "relicCurator",
        name: "ËÅñÈÅ∫Áâ©ÁÆ°ÁêÜ",
        desc: "Á•ûËÅñ„Å™ÈÅ∫Áâ©„ÅÆÊâ±„ÅÑ„ÅßÂπ∏ÈÅã„ÇíÂæó„Çã„ÄÇ",
        category: "ËÅñËÅ∑",
        type: "passive",
        unlockLevel: 21,
        scaling: { perLevel: { rarity: 0.25, goldChance: 0.25 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
          { level: 30, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§30: Áß∞Âè∑Áéá+2%" },
          { level: 50, bonus: { rarity: 4 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+4%" },
        ],
      },
      // Âê∏Ë°ÄÔºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÔºâ
      {
        key: "bloodPact",
        name: "Ë°Ä„ÅÆÁõüÁ¥Ñ",
        desc: "Ë°Ä„ÇíÂ™í‰ªã„Å´ÊîªÈò≤„Çí‰∏°Á´ã„Åï„Åõ„ÇãÁßòË°ì„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "active",
        unlockLevel: 1,
        scaling: { perLevel: { physAtk: 0.8, lifeSteal: 0.08 } },
        thresholds: [
          { level: 10, bonus: { hp: 10 }, effect: "ÈñæÂÄ§10: ÊúÄÂ§ßHP+10" },
          { level: 30, bonus: { damageReduction: 2, hpRegen: 0.3 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%„ÄÅHPÂÜçÁîü+0.3" },
          { level: 50, bonus: { dropRate: 5 }, effect: "ÈñæÂÄ§50: „Éâ„É≠„ÉÉ„ÉóÁéá+5%" },
        ],
        activation: { cooldown: 5, mpCost: 5, effect: "HP„ÇíÊ∂àË≤ª„Åó„Å§„Å§È´òÂÄçÁéá„ÅÆ‰∏ÄÊíÉ„Å®Âê∏Ë°Ä", slotCost: 1 },
      },
      {
        key: "scarletRush",
        name: "Á¥ÖËìÆÁ™ÅÈÄ≤",
        desc: "Ë°ÄÁÖô„ÇíÁ∫è„ÅÑ„ÄÅÊïµÈô£„Å∏Á™ÅÊíÉ„Åô„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "active",
        unlockLevel: 4,
        scaling: { perLevel: { physAtk: 1.1, speed: 0.5 } },
        thresholds: [
          { level: 10, bonus: { physPen: 3 }, effect: "ÈñæÂÄ§10: Áâ©ÁêÜË≤´ÈÄö+3%" },
          { level: 30, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§30: „ÇØ„É™Áéá+2%" },
          { level: 50, bonus: { critDamage: 6 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+6%" },
        ],
        activation: { cooldown: 4, mpCost: 6, effect: "ÁßªÂãï„Åó„Å™„Åå„ÇâÊñ¨ÊíÉ„Åó„ÄÅÂê∏Âèé„ÅÆ‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "midnightFeast",
        name: "Ê∑±Á¥Ö„ÅÆÈ•óÂÆ¥",
        desc: "Êïµ„ÅÆÁîüÂëΩ„ÇíÂê∏„ÅÑÂ∞Ω„Åè„Åó„ÄÅÂ∑±„ÇíÊ∫Ä„Åü„Åô„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "active",
        unlockLevel: 8,
        scaling: { perLevel: { lifeSteal: 0.12, hp: 0.8 } },
        thresholds: [
          { level: 10, bonus: { hpRegen: 0.4 }, effect: "ÈñæÂÄ§10: HPÂÜçÁîü+0.4" },
          { level: 30, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§30: Ë¢´„ÉÄ„É°-2%" },
          { level: 50, bonus: { hp: 24 }, effect: "ÈñæÂÄ§50: ÊúÄÂ§ßHP+24" },
        ],
        activation: { cooldown: 5, mpCost: 8, effect: "Ââ≤ÂêàÂê∏Ë°Ä+ÂÜçÁîü„Çí‰ªò‰∏é", slotCost: 1 },
      },
      {
        key: "batSwarm",
        name: "ËùôËù†„ÅÆÁæ§„Çå",
        desc: "Áú∑Â±û„ÇíÂëº„Å≥ÂØÑ„Åõ„ÄÅÊïµ„Çí„Åã„Åè‰π±„Åô„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "active",
        unlockLevel: 12,
        scaling: { perLevel: { speed: 0.6, damageReduction: 0.25 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 2 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+2%" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§50: CTÁü≠Á∏Æ+2%" },
        ],
        activation: { cooldown: 4, mpCost: 5, effect: "ÂõûÈÅøÁéá„ÅÆ‰ª£„Çè„Çä„Å´Ë¢´„ÉÄ„É°ËªΩÊ∏õ„Å®Âê∏Âèé", slotCost: 1 },
      },
      {
        key: "crimsonMoon",
        name: "Á¥ÖÊúàÈôçËá®",
        desc: "Á¥Ö„ÅÑÊúà„ÅÆÁ•ùÁ¶è„ÅßÊîªÊíÉÊú¨ËÉΩ„ÇíËß£Êîæ„Åô„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "active",
        unlockLevel: 16,
        scaling: { perLevel: { physAtk: 1.2, critRate: 0.2 } },
        thresholds: [
          { level: 10, bonus: { critDamage: 5 }, effect: "ÈñæÂÄ§10: „ÇØ„É™„ÉÄ„É°+5%" },
          { level: 30, bonus: { physPen: 4 }, effect: "ÈñæÂÄ§30: Áâ©ÁêÜË≤´ÈÄö+4%" },
          { level: 50, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+3%" },
        ],
        activation: { cooldown: 6, mpCost: 9, effect: "‰∏ÄÂÆö„Çø„Éº„É≥ÊîªÊíÉÂº∑Âåñ„Å®Âê∏Ë°ÄÈáè‰∏äÊòá", slotCost: 1 },
      },
      // Âê∏Ë°ÄÔºà„Éë„ÉÉ„Ç∑„ÉñÔºâ
      {
        key: "bloodSense",
        name: "Ë°Ä„ÅÆÊÑüÁü•",
        desc: "Ë°ÄÊµÅ„ÅÆÂ§âÂåñ„ÇíË™≠„ÅøÂèñ„Çä„ÄÅÊ©üÂÖà„ÇíÂà∂„Åô„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 1,
        scaling: { perLevel: { speed: 0.4, critRate: 0.15 } },
        thresholds: [
          { level: 10, bonus: { physAtk: 6 }, effect: "ÈñæÂÄ§10: Áâ©Êîª+6" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { critDamage: 8 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+8%" },
        ],
      },
      {
        key: "nightRecovery",
        name: "Â§ú„ÅÆÂÜçÁîü",
        desc: "Èóá„ÅÆ‰∏≠„ÅßÂÇ∑„ÇíÁôí„ÇÑ„Åó„ÄÅÊ¥ªÂäõ„ÇíÊàª„Åô„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 2,
        scaling: { perLevel: { hpRegen: 0.3, hp: 0.7 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 1 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-1%" },
          { level: 30, bonus: { hp: 20 }, effect: "ÈñæÂÄ§30: ÊúÄÂ§ßHP+20" },
          { level: 50, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§50: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
        ],
      },
      {
        key: "hematophagy",
        name: "Ë°ÄÈ£üÁøíÊÄß",
        desc: "Ë°Ä„ÇíÁ≥ß„Å®„Åó„Å¶Âäõ„Å´Â§â„Åà„ÇãÊú¨ËÉΩ„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 4,
        scaling: { perLevel: { lifeSteal: 0.1, physAtk: 0.6 } },
        thresholds: [
          { level: 10, bonus: { physPen: 2 }, effect: "ÈñæÂÄ§10: Áâ©ÁêÜË≤´ÈÄö+2%" },
          { level: 30, bonus: { hpRegen: 0.3 }, effect: "ÈñæÂÄ§30: HPÂÜçÁîü+0.3" },
          { level: 50, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§50: „ÇØ„É™Áéá+2%" },
        ],
      },
      {
        key: "shadowWalk",
        name: "ÂΩ±Ê≠©„Åç",
        desc: "ÂΩ±„Å´Á¥õ„Çå„Å¶Âãï„Åç„ÄÅË¢´ÂÆ≥„ÇíÈÅø„Åë„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 6,
        scaling: { perLevel: { damageReduction: 0.2, speed: 0.3 } },
        thresholds: [
          { level: 10, bonus: { block: 2 }, effect: "ÈñæÂÄ§10: „Éñ„É≠„ÉÉ„ÇØ+2%" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { cooldown: 2 }, effect: "ÈñæÂÄ§50: CTÁü≠Á∏Æ+2%" },
        ],
      },
      {
        key: "predatorInstinct",
        name: "ÊçïÈ£üËÄÖ„ÅÆÊú¨ËÉΩ",
        desc: "Âº±ÁÇπ„ÇíÁ™Å„Åç„ÄÅÂäπÁéáÁöÑ„Å´‰ªïÁïô„ÇÅ„ÇãÂóÖË¶ö„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 9,
        scaling: { perLevel: { critRate: 0.25, physPen: 0.25 } },
        thresholds: [
          { level: 10, bonus: { critDamage: 5 }, effect: "ÈñæÂÄ§10: „ÇØ„É™„ÉÄ„É°+5%" },
          { level: 30, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§30: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
          { level: 50, bonus: { rarity: 3 }, effect: "ÈñæÂÄ§50: „É¨„Ç¢Áéá+3%" },
        ],
      },
      {
        key: "bloodArmor",
        name: "Ë°ÄÈéß",
        desc: "ÂáùÂõ∫„Åó„ÅüË°Ä„ÅßÈéß„ÇíÂΩ¢Êàê„Åó„ÄÅËÄê‰πÖ„ÇíÈ´ò„ÇÅ„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 12,
        scaling: { perLevel: { hp: 1.1, physDef: 0.6 } },
        thresholds: [
          { level: 10, bonus: { damageReduction: 2 }, effect: "ÈñæÂÄ§10: Ë¢´„ÉÄ„É°-2%" },
          { level: 30, bonus: { hpRegen: 0.3 }, effect: "ÈñæÂÄ§30: HPÂÜçÁîü+0.3" },
          { level: 50, bonus: { block: 3 }, effect: "ÈñæÂÄ§50: „Éñ„É≠„ÉÉ„ÇØ+3%" },
        ],
      },
      {
        key: "midnightLore",
        name: "ÂÆµÈóá„ÅÆ‰ºùÊâø",
        desc: "Èóá„ÅÆÁü•Ë≠ò„ÅåÈ≠îÂäõ„Å®Âπ∏ÈÅã„ÇíÂºï„ÅçÂØÑ„Åõ„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 15,
        scaling: { perLevel: { magAtk: 0.6, rarity: 0.2 } },
        thresholds: [
          { level: 10, bonus: { titleChance: 2 }, effect: "ÈñæÂÄ§10: Áß∞Âè∑Áéá+2%" },
          { level: 30, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§30: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
          { level: 50, bonus: { goldChance: 3 }, effect: "ÈñæÂÄ§50: „Ç¥„Éº„É´„ÉâÁéá+3%" },
        ],
      },
      {
        key: "immortalVigor",
        name: "‰∏çÊ≠ª„ÅÆÊ¥ªÂäõ",
        desc: "‰∏çÊ≠ªÊÄß„Å´Ëøë„ÅÑÂõûÂæ©Âäõ„ÇíË™á„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 18,
        scaling: { perLevel: { hpRegen: 0.35, damageReduction: 0.2 } },
        thresholds: [
          { level: 10, bonus: { hp: 18 }, effect: "ÈñæÂÄ§10: ÊúÄÂ§ßHP+18" },
          { level: 30, bonus: { controlResist: 4 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+4%" },
          { level: 50, bonus: { dotResist: 5 }, effect: "ÈñæÂÄ§50: DoTËÄêÊÄß+5%" },
        ],
      },
      {
        key: "thirstForPower",
        name: "Ê∏áÊúõ„ÅÆÂäõ",
        desc: "È£¢„Åà„ÇíÂäõ„Å∏„Å®ÊòáËèØ„ÅóÁ∂ö„Åë„Çã„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 21,
        scaling: { perLevel: { physAtk: 0.9, lifeSteal: 0.08 } },
        thresholds: [
          { level: 10, bonus: { physPen: 3 }, effect: "ÈñæÂÄ§10: Áâ©ÁêÜË≤´ÈÄö+3%" },
          { level: 30, bonus: { critRate: 2 }, effect: "ÈñæÂÄ§30: „ÇØ„É™Áéá+2%" },
          { level: 50, bonus: { critDamage: 6 }, effect: "ÈñæÂÄ§50: „ÇØ„É™„ÉÄ„É°+6%" },
        ],
      },
      {
        key: "nocturneGrace",
        name: "Â§úÊÉ≥„ÅÆÂÑ™ÈõÖ",
        desc: "Â§ú„ÅÆÂ∏≥„ÅåÂäõ„ÇíÂåÖ„Åø„ÄÅÊ∞óÈÖç„ÇíÊ∂à„Åô„ÄÇ",
        category: "Âê∏Ë°Ä",
        type: "passive",
        unlockLevel: 24,
        scaling: { perLevel: { damageReduction: 0.25, rarity: 0.2 } },
        thresholds: [
          { level: 10, bonus: { dropRate: 3 }, effect: "ÈñæÂÄ§10: „Éâ„É≠„ÉÉ„ÉóÁéá+3%" },
          { level: 30, bonus: { controlResist: 3 }, effect: "ÈñæÂÄ§30: Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß+3%" },
          { level: 50, bonus: { goldChance: 4 }, effect: "ÈñæÂÄ§50: „Ç¥„Éº„É´„ÉâÁéá+4%" },
        ],
      },
    ];

    applyUnlockPattern(SKILL_DEFINITIONS);
    SKILL_DEFINITIONS.forEach((skill) => {
      skill.thresholds = amplifyThresholdBonuses(skill.thresholds);
    });

    const SKILL_DEFINITION_MAP = SKILL_DEFINITIONS.reduce((acc, skill) => {
      acc[skill.key] = skill;
      return acc;
    }, {});

    const skills = SKILL_DEFINITIONS.reduce((acc, skill) => {
      acc[skill.key] = { ...skill, level: 0, max: SKILL_MAX_LEVEL };
      return acc;
    }, {});

    function mergeSkillsFromSave(savedSkills = {}) {
      Object.values(skills).forEach((skill) => {
        const base = SKILL_DEFINITION_MAP[skill.key] || {};
        const saved = savedSkills[skill.key] || {};
        const level = saved.level ?? 0;
        const max = saved.max ?? SKILL_MAX_LEVEL;
        Object.assign(skill, base, { level, max });
      });
    }

    function computeSkillBonusAtLevel(skill, level = 0) {
      const target = {};
      const effectiveLevel = Math.max(0, level || 0);
      if (!skill || effectiveLevel <= 0) return target;
      if (skill.scaling?.perLevel) addBonus(target, skill.scaling.perLevel, effectiveLevel);
      (skill.thresholds || []).forEach((threshold) => {
        if (effectiveLevel >= threshold.level) addBonus(target, threshold.bonus);
      });
      return target;
    }

    function describeSkillBonusAtLevel(skill, level, { locked = false, label = "ÁèæÂú®ÂäπÊûú" } = {}) {
      if (locked) return `${label}: ÔºüÔºüÔºü`;
      if (!level || level <= 0) return `${label}: Êú™ÁøíÂæó`;
      const summary = formatSkillBonusText(computeSkillBonusAtLevel(skill, level));
      return `${label}: ${summary || "ÂäπÊûú„Å™„Åó"}`;
    }

    function describeSkillNextBonus(skill, { locked = false } = {}) {
      if (locked) return "Ê¨°LvÂêàË®à: ÔºüÔºüÔºü";
      const maxLevel = skill.max ?? SKILL_MAX_LEVEL;
      if ((skill.level ?? 0) >= maxLevel) return "Ê¨°LvÂêàË®à: ÊúÄÂ§ßLv„Å´Âà∞ÈÅî";
      const nextLevel = Math.min((skill.level ?? 0) + 1, maxLevel);
      const summary = formatSkillBonusText(computeSkillBonusAtLevel(skill, nextLevel));
      return `Ê¨°LvÂêàË®à: ${summary || "ËøΩÂä†ÂäπÊûú„Å™„Åó"}`;
    }

    function addBonus(target, bonus = {}, multiplier = 1) {
      if (!target || !bonus) return;
      Object.entries(bonus).forEach(([key, value]) => {
        if (typeof value !== "number") return;
        target[key] = (target[key] ?? 0) + value * multiplier;
      });
    }

    function calculateSkillBonuses() {
      const aggregated = createEmptyBonus();
      Object.values(skills).forEach((skill) => {
        const level = skill.level ?? 0;
        const reached = [];
        if (level > 0) {
          if (skill.scaling?.perLevel) {
            addBonus(aggregated, skill.scaling.perLevel, level);
          }
          (skill.thresholds || []).forEach((threshold) => {
            if (level >= threshold.level) {
              addBonus(aggregated, threshold.bonus);
              reached.push(threshold);
            }
          });
        }
        skill.reachedThresholds = reached;
      });
      player.baseBonus = aggregated;
      return aggregated;
    }

    function formatSkillBonusText(bonus = {}) {
      const labels = {
        hp: "ÊúÄÂ§ßHP",
        mp: "ÊúÄÂ§ßMP",
        physAtk: "Áâ©ÁêÜÊîªÊíÉ",
        magAtk: "È≠îÊ≥ïÊîªÊíÉ",
        physDef: "Áâ©ÁêÜÈò≤Âæ°",
        magDef: "È≠îÊ≥ïÈò≤Âæ°",
        speed: "Ë°åÂãïÈÄüÂ∫¶",
        critRate: "„ÇØ„É™Áéá",
        critDamage: "„ÇØ„É™„ÉÄ„É°",
        physPen: "Áâ©ÁêÜË≤´ÈÄö",
        magPen: "È≠îÊ≥ïË≤´ÈÄö",
        damageReduction: "Ë¢´„ÉÄ„É°ËªΩÊ∏õ",
        block: "„Éñ„É≠„ÉÉ„ÇØ",
        controlResist: "Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß",
        dotResist: "DoTËÄêÊÄß",
        debuffResist: "Âº±‰ΩìËÄêÊÄß",
        cooldown: "CTÁü≠Á∏Æ",
        hpRegen: "HPÂÜçÁîü",
        lifeSteal: "HPÂê∏Âèé",
        barrier: "„Éê„É™„Ç¢",
        dropRate: "„Éâ„É≠„ÉÉ„ÉóÁéá",
        rarity: "„É¨„Ç¢Áéá",
        goldChance: "„Ç¥„Éº„É´„ÉâÁéá",
        titleChance: "Áß∞Âè∑Áéá",
        namedRate: "„Éç„Éº„É†„ÉâÁéá",
      };
      const percentKeys = [
        "critRate",
        "critDamage",
        "physPen",
        "magPen",
        "damageReduction",
        "block",
        "controlResist",
        "dotResist",
        "debuffResist",
        "lifeSteal",
        "dropRate",
        "rarity",
        "goldChance",
        "titleChance",
        "namedRate",
        "cooldown",
      ];
      return Object.entries(bonus)
        .map(([key, value]) => {
          if (typeof value !== "number") return null;
          const label = labels[key] || key;
          const unit = percentKeys.includes(key) ? "%" : "";
          const formatted = Math.abs(value) >= 1 ? value.toFixed(0) : value.toFixed(2);
          return `${label}+${formatted}${unit}`;
        })
        .filter(Boolean)
        .join(" / ");
    }

    function log(message, type = "info", options = {}) {
      const { asHtml = false } = options;
      const logBox = document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `entry ${type}`;
      entry.classList.add("log-enter");
      if (asHtml) {
        entry.innerHTML = message;
      } else {
        entry.textContent = message;
      }
      logBox.append(entry);
      logBox.scrollTop = logBox.scrollHeight;
    }

    const statusPopover = document.getElementById("status-popover");
    const statusPopoverName = document.getElementById("status-popover-name");
    const statusPopoverTurns = document.getElementById("status-popover-turns");
    const statusPopoverDesc = document.getElementById("status-popover-desc");
    let statusPopoverTimer = null;

    const levelUpToast = document.getElementById("level-up-toast");
    const levelUpValue = document.getElementById("level-up-value");
    let levelUpToastTimer = null;

    const dropCelebration = document.getElementById("drop-celebration");
    const dropItemName = document.getElementById("drop-item-name");
    const dropPill = document.getElementById("drop-pill");
    let dropCelebrationTimer = null;

    const getStatus = (entity, key) => (entity.statuses || []).find((s) => s.key === key);
    const hasStatus = (entity, key) => Boolean(getStatus(entity, key));

    function removeStatus(entity, key) {
      entity.statuses = (entity.statuses || []).filter((s) => s.key !== key);
    }

    function getResist(entity, category) {
      if (!entity.resist) return 0;
      return Math.max(0, Math.min(100, entity.resist[category] || 0));
    }

    function describeStatus(status) {
      const def = STATUS_DEFINITIONS[status.key];
      if (!def) return "";
      return `${def.description} / ÊÆã„Çä${status.remaining}T`;
    }

    function triggerLevelUpEffect(level) {
      if (!levelUpToast || !levelUpValue) return;
      levelUpValue.textContent = level;
      levelUpToast.setAttribute("aria-hidden", "false");
      levelUpToast.classList.remove("show");
      if (levelUpToastTimer) clearTimeout(levelUpToastTimer);
      void levelUpToast.offsetWidth;
      levelUpToast.classList.add("show");
      levelUpToastTimer = setTimeout(() => {
        levelUpToast?.classList.remove("show");
        levelUpToast?.setAttribute("aria-hidden", "true");
      }, 1900);
    }

    function triggerDropCelebration(item) {
      if (!dropCelebration || !dropItemName || !dropPill) return;
      const rarity = item?.equipment?.rarity;
      if (!rarity || !["rare", "legendary"].includes(rarity)) return;

      const label = rarity === "legendary" ? "LEGENDARY DROP" : "RARE DROP";
      dropPill.textContent = label;
      dropItemName.textContent = item?.name || "???";
      dropCelebration.setAttribute("aria-hidden", "false");
      dropCelebration.classList.remove("show", "rare", "legendary");
      if (dropCelebrationTimer) clearTimeout(dropCelebrationTimer);
      void dropCelebration.offsetWidth;
      dropCelebration.classList.add("show", rarity);
      dropCelebrationTimer = setTimeout(() => {
        dropCelebration?.classList.remove("show");
        dropCelebration?.setAttribute("aria-hidden", "true");
      }, 2600);
    }

    function showStatusPopover(def, status) {
      if (!def || !status) return;
      statusPopoverName.textContent = `${def.name} (${def.short})`;
      statusPopoverTurns.textContent = `ÊÆã„Çä ${status.remaining}T`;
      statusPopoverDesc.textContent = def.description;
      statusPopover.classList.remove("hidden");
      if (statusPopoverTimer) clearTimeout(statusPopoverTimer);
      statusPopoverTimer = setTimeout(() => statusPopover.classList.add("hidden"), 2300);
    }

    statusPopover.addEventListener("click", () => statusPopover.classList.add("hidden"));

    const primaryOrder = ["str", "int", "vit", "agi", "luck"];
    const stepOptions = [1, 10, 50];
    let currentStepIndex = 0;
    const skillStepOptions = [1, 10, 50];
    let currentSkillStepIndex = 0;
    let selectedSkillCategory = SKILL_CATEGORIES[0];
    let selectedSkillType = "active";
    let skillSummaryVisible = false;
    let pendingResetSpent = 0;

    const displayNumber = (num, { isPercent = false } = {}) => {
      if (isPercent) {
        return (Math.round(num * 10) / 10).toFixed(1);
      }
      return Math.round(num);
    };

    function formatStatValue(value, unit = "") {
      const isPercent = unit === "%";
      const total = displayNumber(value, { isPercent });
      if (isPercent) {
        return `<span class="total">${total}${unit}</span>`;
      }
      return `<span class="total">${total}</span>`;
    }

    const formatPrimaryValue = (stat) => {
      const total = stat.base + stat.bonus;
      if (!stat.bonus) return `<span class="total">${total}</span>`;
      const bonusSign = stat.bonus > 0 ? "+" : "";
      return `<span class="total">${total}</span> (<span class="base">${stat.base}</span> <span class="bonus">${bonusSign}${stat.bonus}</span>)`;
    };

    const statTotal = (key) => {
      const stat = player.primary[key];
      return stat.base + stat.bonus;
    };

    function calcSecondaryStats() {
      const str = statTotal("str");
      const int = statTotal("int");
      const vit = statTotal("vit");
      const agi = statTotal("agi");
      const luck = statTotal("luck");

      const maxHpBase = player.base.hp + vit * 8;
      const maxMpBase = player.base.mp + int * 3;
      const physAtkBase = player.base.physAtk + str * 1.2;
      const magAtkBase = player.base.magAtk + int * 1.3;
      const physDefBase = player.base.physDef + vit * 0.6 + str * 0.2;
      const magDefBase = player.base.magDef + vit * 0.5 + int * 0.3;
      const speedBase = player.base.speed + agi;
      const critBase = Math.min(70, (agi + luck) * 0.6);
      const evadeBase = Math.min(60, (agi + luck) * 0.4);
      const accuracyBase = Math.min(100, 70 + agi * 0.1);
      const physPenBase = Math.min(30, str * 0.2);
      const magPenBase = Math.min(30, int * 0.2);
      const critDmgBase = Math.min(50, luck * 0.6);
      const damageReductionBase = Math.min(40, vit * 0.4);
      const blockBase = Math.min(25, 5 + vit * 0.3);
      const controlResistBase = Math.min(60, (vit + luck) * 0.35);
      const dotResistBase = Math.min(60, vit * 0.45 + luck * 0.1);
      const debuffResistBase = Math.min(60, (vit + int) * 0.35 + luck * 0.1);
      const cooldownBase = Math.min(20, (agi + int) * 0.15);
      const hpRegenBase = vit * 0.2;
      const lifeStealBase = Math.min(10, Math.max(str, luck) * 0.1);
      const barrierBase = vit * 2 + int;
      const dropRateBase = Math.min(50, Math.sqrt(luck) * 4 + luck * 0.2);
      const rarityBase = Math.min(30, Math.sqrt(luck) * 2 + luck * 0.1);
      const titleChanceBase = Math.min(60, Math.sqrt(luck) * 3 + luck * 0.25);
      const namedRateBase = Math.min(70, 8 + Math.sqrt(luck) * 2 + luck * 0.25);
      const goldChanceBase = 100;

      return {
        maxHp: { base: maxHpBase, bonus: player.bonus.hp, total: maxHpBase + player.bonus.hp },
        maxMp: { base: maxMpBase, bonus: player.bonus.mp, total: maxMpBase + player.bonus.mp },
        physAtk: { base: physAtkBase, bonus: player.bonus.physAtk, total: physAtkBase + player.bonus.physAtk },
        magAtk: { base: magAtkBase, bonus: player.bonus.magAtk, total: magAtkBase + player.bonus.magAtk },
        physDef: { base: physDefBase, bonus: player.bonus.physDef, total: physDefBase + player.bonus.physDef },
        magDef: { base: magDefBase, bonus: player.bonus.magDef, total: magDefBase + player.bonus.magDef },
        speed: { base: speedBase, bonus: player.bonus.speed, total: speedBase + player.bonus.speed },
        critRate: { base: critBase, bonus: player.bonus.critRate, total: Math.min(70, critBase + player.bonus.critRate) },
        evade: { base: evadeBase, bonus: player.bonus.evade, total: Math.min(60, evadeBase + player.bonus.evade) },
        accuracy: { base: accuracyBase, bonus: 0, total: accuracyBase },
        physPen: { base: physPenBase, bonus: player.bonus.physPen, total: Math.min(30, physPenBase + player.bonus.physPen) },
        magPen: { base: magPenBase, bonus: player.bonus.magPen, total: Math.min(30, magPenBase + player.bonus.magPen) },
        critDamage: { base: critDmgBase, bonus: player.bonus.critDamage, total: Math.min(50, critDmgBase + player.bonus.critDamage) },
        damageReduction: { base: damageReductionBase, bonus: player.bonus.damageReduction, total: Math.min(40, damageReductionBase + player.bonus.damageReduction) },
        block: { base: blockBase, bonus: player.bonus.block, total: Math.min(25, blockBase + player.bonus.block) },
        controlResist: { base: controlResistBase, bonus: player.bonus.controlResist, total: Math.min(60, controlResistBase + player.bonus.controlResist) },
        dotResist: { base: dotResistBase, bonus: player.bonus.dotResist, total: Math.min(60, dotResistBase + player.bonus.dotResist) },
        debuffResist: { base: debuffResistBase, bonus: player.bonus.debuffResist, total: Math.min(60, debuffResistBase + player.bonus.debuffResist) },
        cooldown: { base: cooldownBase, bonus: player.bonus.cooldown, total: Math.min(20, cooldownBase + player.bonus.cooldown) },
        hpRegen: { base: hpRegenBase, bonus: player.bonus.hpRegen, total: hpRegenBase + player.bonus.hpRegen },
        lifeSteal: { base: lifeStealBase, bonus: player.bonus.lifeSteal, total: Math.min(10, lifeStealBase + player.bonus.lifeSteal) },
        barrier: { base: barrierBase, bonus: player.bonus.barrier, total: barrierBase + player.bonus.barrier },
        dropRate: { base: dropRateBase, bonus: player.bonus.dropRate, total: Math.min(50, dropRateBase + player.bonus.dropRate) },
        rarity: { base: rarityBase, bonus: player.bonus.rarity, total: Math.min(30, rarityBase + player.bonus.rarity) },
        titleChance: {
          base: titleChanceBase,
          bonus: player.bonus.titleChance,
          total: Math.min(80, titleChanceBase + player.bonus.titleChance),
        },
        goldChance: { base: goldChanceBase, bonus: player.bonus.goldChance, total: Math.max(0, goldChanceBase + player.bonus.goldChance) },
        namedRate: { base: namedRateBase, bonus: player.bonus.namedRate, total: Math.min(90, namedRateBase + player.bonus.namedRate) },
      };
    }

    function collectEquipmentBonuses() {
      const secondary = createEmptyBonus();
      const primary = createEmptyPrimaryBonus();
      Object.values(player.equipment || {}).forEach((item) => {
        if (!item) return;
        if (item.primaryBonus) {
          Object.entries(item.primaryBonus).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            primary[key] = (primary[key] ?? 0) + value;
          });
        }
        if (item.bonus) {
          Object.entries(item.bonus).forEach(([key, value]) => {
            if (typeof value !== "number") return;
            secondary[key] = (secondary[key] ?? 0) + value;
          });
        }
      });
      return { primary, secondary };
    }

    function mergeBonuses(baseBonus, extraBonus) {
      const merged = createEmptyBonus();
      Object.keys(merged).forEach((key) => {
        merged[key] = (baseBonus?.[key] ?? 0) + (extraBonus?.[key] ?? 0);
      });
      return merged;
    }

    function calcExpRewardForEnemy({ floor, enemyCount = 1, isBoss = false } = {}) {
      const base = 10 + floor * 3 + (floor % 5 === 0 ? 10 : 0);
      const adjusted = isBoss ? Math.round(base * 1.12) : base;
      return Math.max(1, Math.round(adjusted / Math.max(1, enemyCount)));
    }

    function getGoldMultiplier() {
      const derived = recalcDerivedStats();
      const chance = derived.goldChance?.total ?? 100;
      return Math.max(0, chance) / 100;
    }

    function formatGold(amount) {
      return Math.trunc(amount || 0).toLocaleString("ja-JP");
    }

    function grantGold(baseAmount, { source = "" } = {}) {
      const multiplier = getGoldMultiplier();
      const gained = Math.max(0, Math.round(baseAmount * multiplier));
      if (gained <= 0) return 0;
      player.gold += gained;
      const prefix = source ? `${source}: ` : "";
      log(`üí∞ ${prefix}${formatGold(gained)}G„ÇíÁç≤Âæó`, "good");
      return gained;
    }

    function grantExp(amount, { source = "" } = {}) {
      const gained = Math.max(0, Math.round(amount || 0));
      if (gained <= 0) return 0;
      player.exp += gained;
      const prefix = source ? `${source}: ` : "";
      log(`üéÅ ${prefix}${gained} EXP„ÇíÁç≤Âæó`, "good");
      while (player.exp >= player.expToLevel) {
        player.exp -= player.expToLevel;
        levelUp();
      }
      return gained;
    }

    function calculateItemSellValue(item) {
      if (!item) return 0;
      if (item.type === "equipment" && item.equipment) {
        const base = SELL_VALUE_BY_RARITY[item.equipment.rarity] ?? 0;
        const prefixRank = item.equipment.prefix?.rank ?? 0;
        const suffixRank = item.equipment.suffix?.rank ?? 0;
        const starBonus = prefixRank + suffixRank;
        const price = base * (1 + starBonus * 0.2);
        return Math.max(1, Math.round(price));
      }
      if (item.type === "potion") return 1;
      return 0;
    }

    function resolveDropSlotForFloor(floor, isBoss) {
      if (isBoss && BOSS_LEGENDARY_DROPS[floor]?.slot) return BOSS_LEGENDARY_DROPS[floor].slot;
      const table = FLOOR_DROP_TABLE.find((entry) => floor >= entry.min && floor <= entry.max);
      const slots = table?.slots?.length ? table.slots : Object.keys(EQUIPMENT_SLOTS);
      if (!slots.length) return "weapon";
      return slots[randomInt(0, slots.length - 1)];
    }

    function rollBaseDropRarity(isBoss) {
      const weights = isBoss ? BOSS_DROP_RARITY_WEIGHTS : DROP_RARITY_WEIGHTS;
      return weightedRandom(weights, { key: "normal" })?.key || "normal";
    }

    function upgradeRarityWithBonus(baseKey, rarityBonus) {
      const ladder = ["normal", "magic", "rare"];
      let current = baseKey;
      let upgradeChance = Math.min(80, Math.max(0, rarityBonus || 0));
      while (upgradeChance > 0) {
        const index = ladder.indexOf(current);
        if (index < 0 || index >= ladder.length - 1) break;
        if (Math.random() * 100 < upgradeChance) {
          current = ladder[index + 1];
          upgradeChance *= 0.45;
        } else {
          break;
        }
      }
      return current;
    }

    function rollDropRarityForEnemy(enemy, rarityBonus, slot) {
      const legendaryCandidate = enemy.isBoss ? BOSS_LEGENDARY_DROPS[game.floor] : null;
      if (legendaryCandidate && legendaryCandidate.slot === slot) {
        const chance = Math.min(60, 10 + (rarityBonus || 0) * 0.6);
        if (Math.random() * 100 < chance) {
          return { rarityKey: "legendary", legendaryKey: legendaryCandidate.legendaryKey };
        }
      }

      const baseKey = rollBaseDropRarity(enemy.isBoss);
      const upgraded = upgradeRarityWithBonus(baseKey, rarityBonus);
      return { rarityKey: upgraded, legendaryKey: "" };
    }

    function attemptEnemyDrop(enemy) {
      const derived = recalcDerivedStats();
      const dropBonus = (enemy.isBoss ? BOSS_DROP_BONUS : 0) + (enemy.dropChanceBonus || 0);
      const chance = Math.min(95, BASE_DROP_CHANCE + dropBonus + (derived.dropRate?.total ?? 0));
      if (Math.random() * 100 >= chance) return null;

      const slot = resolveDropSlotForFloor(game.floor, enemy.isBoss);
      const rarityBonus = (derived.rarity?.total ?? 0) + (enemy.rarityBonus || 0);
      const rarityRoll = rollDropRarityForEnemy(enemy, rarityBonus, slot);
      const item = createEquipmentItem(slot, rarityRoll.rarityKey, {
        legendaryKey: rarityRoll.legendaryKey,
        titleBonus: derived.titleChance.total,
      });
      player.inventory.items.push(item);
      const rarityLabel = item.equipment?.rarityLabel || EQUIPMENT_RARITIES[item.equipment?.rarity]?.label || "";
      const rarityText = rarityLabel ? `${rarityLabel} ` : "";
      const coloredName = item?.equipment?.rarity
        ? `<span class="rarity-${item.equipment.rarity}">${item.name}</span>`
        : item.name;
      log(`üéÅ ${enemy.name} „Åã„Çâ ${rarityText}${coloredName} „ÇíÂÖ•ÊâãÔºÅ`, "good", { asHtml: true });
      triggerDropCelebration(item);
      renderInventory();
      return item;
    }

    function recalcDerivedStats() {
      const equipmentBonuses = collectEquipmentBonuses();
      player.equipmentBonus = equipmentBonuses.secondary;
      player.equipmentPrimaryBonus = equipmentBonuses.primary;
      Object.keys(player.primary).forEach((key) => {
        player.primary[key].bonus = equipmentBonuses.primary[key] ?? 0;
      });
      player.bonus = mergeBonuses(player.baseBonus, player.equipmentBonus);
      const derived = calcSecondaryStats();
      const prevMaxHp = player.maxHp || derived.maxHp.total;
      const prevMaxMp = player.maxMp || derived.maxMp.total;

      if (player.maxHp === 0) {
        player.hp = derived.maxHp.total;
      } else {
        const hpDelta = derived.maxHp.total - prevMaxHp;
        if (hpDelta > 0) player.hp += hpDelta;
        if (player.hp > derived.maxHp.total) player.hp = derived.maxHp.total;
      }

      if (player.maxMp === 0) {
        player.mp = derived.maxMp.total;
      } else {
        const mpDelta = derived.maxMp.total - prevMaxMp;
        if (mpDelta > 0) player.mp += mpDelta;
        if (player.mp > derived.maxMp.total) player.mp = derived.maxMp.total;
      }

      player.maxHp = Math.round(derived.maxHp.total);
      player.maxMp = Math.round(derived.maxMp.total);
      player.atk = Math.round(derived.physAtk.total);
      player.def = Math.round(derived.physDef.total);
      player.spd = Math.round(derived.speed.total);
      player.accuracy = Math.round(derived.accuracy.total);
      player.evade = Math.round(derived.evade.total);
      player.resist.control = derived.controlResist.total;
      player.resist.dot = derived.dotResist.total;
      player.resist.debuff = derived.debuffResist.total;

      return derived;
    }

    function canEquipInSlot(itemSlot, targetSlot) {
      if (!itemSlot) return true;
      if (itemSlot === targetSlot) return true;
      if (itemSlot === "accessory" && (targetSlot === "accessory1" || targetSlot === "accessory2")) return true;
      return false;
    }

    function equipItem(slot, item) {
      if (!player.equipment || !(slot in player.equipment)) return;
      if (!canEquipInSlot(item?.equipment?.slot, slot)) return;
      player.equipment[slot] = item ?? null;
      const derived = recalcDerivedStats();
      updateUI(derived);
      maybeAutoSave("Ë£ÖÂÇôÂ§âÊõ¥");
    }

    function unequipItem(slot) {
      if (!player.equipment || !(slot in player.equipment)) return;
      player.equipment[slot] = null;
      const derived = recalcDerivedStats();
      updateUI(derived);
      maybeAutoSave("Ë£ÖÂÇôÂ§âÊõ¥");
    }

    function isBossFloor(floor) {
      return BOSS_FLOORS.includes(floor);
    }

    function pickEnemyBaseName(floor) {
      const pool = ENEMY_NAME_POOLS.find((p) => floor >= p.min && floor <= p.max) || ENEMY_NAME_POOLS[0];
      return pool.names[randomInt(0, pool.names.length - 1)];
    }

    let lastArchetypeKey = null;

    function pickEnemyVariant(floor, { avoidKey = null } = {}) {
      const pool = ENEMY_VARIANTS.filter((variant) => !variant.minFloor || floor >= variant.minFloor);
      if (!pool.length) return null;
      const primary = weightedRandom(pool, pool[0]);

      if (avoidKey && pool.length > 1 && primary?.key === avoidKey) {
        const rerollPool = pool.filter((v) => v.key !== avoidKey);
        const rerolled = weightedRandom(rerollPool, rerollPool[0]);
        return rerolled || primary;
      }

      return primary;
    }

    function pickEnemyBaseProfile(floor) {
      const pool = ENEMY_BASE_PROFILES.filter((profile) => !profile.minFloor || floor >= profile.minFloor);
      return weightedRandom(pool, pool[0]);
    }

    function rollArchetype(floor, derived) {
      const baseChance = 24 + Math.min(18, Math.floor(floor / 120) * 3);
      const namedBonus = Math.max(0, derived?.namedRate?.total ?? 0);
      const effective = Math.min(90, baseChance + namedBonus);
      if (Math.random() * 100 >= effective) return null;
      const variant = pickEnemyVariant(floor, { avoidKey: lastArchetypeKey });
      if (!variant) return null;
      const rank = weightedRandom(ARCHETYPE_RANK_WEIGHTS, ARCHETYPE_RANK_WEIGHTS[0])?.rank || 1;
      lastArchetypeKey = variant.key;
      return { variant, rank };
    }

    function applyArchetypeRoll(enemy, roll) {
      if (!roll) return;
      const { variant, rank } = roll;
      enemy.variant = variant.key;
      enemy.archetypeRank = rank;
      const rankLabel = variant.rankLabels?.[rank - 1] || variant.label;
      enemy.archetypeLabel = rankLabel;
      enemy.flavor = variant.description;
      applyEnemyModifiers(enemy, variant.baseModifiers);
      const applied = [];
      (variant.abilities || [])
        .filter(Boolean)
        .slice(0, rank)
        .forEach((ability) => {
          applyEnemyModifiers(enemy, ability.modifiers);
          applied.push({ label: ability.label, modifiers: ability.modifiers });
        });
      enemy.archetypeBaseModifiers = variant.baseModifiers;
      enemy.archetypeTraits = applied.map((a) => a.label);
      enemy.archetypeAbilities = applied;
      enemy.rarityBonus = (enemy.rarityBonus || 0) + rank * 3;
      enemy.dropChanceBonus = (enemy.dropChanceBonus || 0) + rank * 4;
    }

    function applyEnemyModifiers(enemy, modifiers = {}) {
      const applyRate = (key, rate, { keepDecimal = false } = {}) => {
        if (!rate) return;
        const value = enemy[key] * rate;
        enemy[key] = keepDecimal ? Math.round(value * 10) / 10 : Math.round(value);
      };

      const applyFlat = (key, delta, { clampMin = null } = {}) => {
        if (!delta) return;
        const next = (enemy[key] ?? 0) + delta;
        enemy[key] = clampMin !== null ? Math.max(clampMin, next) : next;
      };

      applyRate("hp", modifiers.hp);
      applyRate("maxHp", modifiers.hp);
      applyRate("atk", modifiers.atk);
      applyRate("def", modifiers.def);
      applyRate("spd", modifiers.spd, { keepDecimal: true });
      applyRate("accuracy", modifiers.accuracy);
      applyRate("evade", modifiers.evade);

      if (modifiers.resist) {
        enemy.resist.control = Math.min(100, Math.round(enemy.resist.control * (modifiers.resist.control || 1)));
        enemy.resist.dot = Math.min(100, Math.round(enemy.resist.dot * (modifiers.resist.dot || 1)));
        enemy.resist.debuff = Math.min(100, Math.round(enemy.resist.debuff * (modifiers.resist.debuff || 1)));
      }

      if (modifiers.attackCount) {
        enemy.attackCount = Math.max(1, Math.round(modifiers.attackCount));
      }
      if (modifiers.attackCountBonus) {
        enemy.attackCount = Math.max(1, Math.round(enemy.attackCount + modifiers.attackCountBonus));
      }

      applyFlat("dropChanceBonus", modifiers.dropChanceBonus, { clampMin: 0 });
      applyFlat("rarityBonus", modifiers.rarityBonus, { clampMin: 0 });
    }

    function describeModifiers(modifiers = {}) {
      if (!modifiers) return "";
      const parts = [];
      const formatRate = (rate) => {
        const delta = Math.round((rate - 1) * 1000) / 10;
        if (delta === 0) return null;
        const sign = delta > 0 ? "+" : "";
        return `${sign}${delta}%`;
      };

      const addRate = (key, label) => {
        if (typeof modifiers[key] === "number") {
          const formatted = formatRate(modifiers[key]);
          if (formatted) parts.push(`${label}${formatted}`);
        }
      };

      addRate("hp", "HP/ÊúÄÂ§ßHP");
      addRate("atk", "ÊîªÊíÉÂäõ");
      addRate("def", "Èò≤Âæ°Âäõ");
      addRate("spd", "ÈÄüÂ∫¶");
      addRate("accuracy", "ÂëΩ‰∏≠");
      addRate("evade", "ÂõûÈÅø");

      if (modifiers.resist) {
        const resist = modifiers.resist;
        if (typeof resist.control === "number") {
          const formatted = formatRate(resist.control);
          if (formatted) parts.push(`Ë°åÂãïÈòªÂÆ≥ËÄêÊÄß${formatted}`);
        }
        if (typeof resist.dot === "number") {
          const formatted = formatRate(resist.dot);
          if (formatted) parts.push(`ÊåÅÁ∂ö„ÉÄ„É°ËÄêÊÄß${formatted}`);
        }
        if (typeof resist.debuff === "number") {
          const formatted = formatRate(resist.debuff);
          if (formatted) parts.push(`Âº±‰ΩìËÄêÊÄß${formatted}`);
        }
      }

      if (modifiers.attackCount) {
        parts.push(`ÊîªÊíÉÂõûÊï∞„Çí${Math.max(1, Math.round(modifiers.attackCount))}Âõû„Å´Âõ∫ÂÆö`);
      }
      if (modifiers.attackCountBonus) {
        parts.push(`ÊîªÊíÉÂõûÊï∞+${Math.round(modifiers.attackCountBonus)}Âõû`);
      }
      if (modifiers.dropChanceBonus) {
        parts.push(`„Éâ„É≠„ÉÉ„ÉóÁéá„Éú„Éº„Éä„Çπ+${Math.round(modifiers.dropChanceBonus)}%`);
      }
      if (modifiers.rarityBonus) {
        parts.push(`„É¨„Ç¢„É™„ÉÜ„Ç£„Éú„Éº„Éä„Çπ+${Math.round(modifiers.rarityBonus)}%`);
      }

      return parts.join("„ÄÅ");
    }

    function createEnemy(isBoss = false, derivedStats = null) {
      const derived = derivedStats || recalcDerivedStats();
      const base = game.floor * 5 + (isBoss ? 20 : 0);
      const baseName = isBoss ? `ÈöéÂ±§„Éú„Çπ ${game.floor}F` : pickEnemyBaseName(game.floor);
      const baseProfile = !isBoss ? pickEnemyBaseProfile(game.floor) : null;
      const archetypeRoll = !isBoss ? rollArchetype(game.floor, derived) : null;
      const enemy = {
        id: generateId("enemy"),
        name: baseName,
        hp: base + (isBoss ? 30 : 0),
        maxHp: base + (isBoss ? 30 : 0),
        atk: 5 + game.floor * 1.5 + (isBoss ? 4 : 0),
        def: 2 + game.floor * 0.5 + (isBoss ? 2 : 0),
        spd: 4 + Math.random() * 2 + (isBoss ? 1.5 : 0),
        accuracy: 82 + game.floor * 0.6,
        evade: Math.min(25, 8 + game.floor * 0.4 + (isBoss ? 5 : 0)),
        attackCount: 1,
        attacksRemaining: 1,
        resist: {
          control: Math.min(50, 10 + game.floor * 0.8 + (isBoss ? 8 : 0)),
          dot: Math.min(50, 8 + game.floor * 0.7 + (isBoss ? 6 : 0)),
          debuff: Math.min(50, 8 + game.floor * 0.6 + (isBoss ? 6 : 0)),
        },
        isBoss,
        dropChanceBonus: 0,
        rarityBonus: 0,
        statuses: [],
      };

      if (baseProfile && !isBoss) {
        enemy.baseProfile = baseProfile.key;
        enemy.flavor = baseProfile.label;
        applyEnemyModifiers(enemy, baseProfile.modifiers);
      }

      if (archetypeRoll && !isBoss) {
        applyArchetypeRoll(enemy, archetypeRoll);
      }

      if (isBoss) {
        const bossDef = BOSS_DEFINITIONS[game.floor];
        if (bossDef) {
          enemy.name = bossDef.name;
          enemy.flavor = bossDef.flavor;
          enemy.bossLegendaryKey = bossDef.legendaryKey;
          const { modifiers = {} } = bossDef;
          applyEnemyModifiers(enemy, modifiers);
        }
      }

      enemy.attacksRemaining = enemy.attackCount;

      return enemy;
    }

    function spawnEnemies() {
      const boss = isBossFloor(game.floor);
      const count = boss ? 1 : 2 + Math.floor(Math.random() * 2);
      const derived = recalcDerivedStats();
      const expReward = calcExpRewardForEnemy({ floor: game.floor, enemyCount: count, isBoss: boss });
      game.enemies = Array.from({ length: count }, () => {
        const enemy = createEnemy(boss, derived);
        enemy.expReward = expReward;
        return enemy;
      });
      log(`${game.floor}F ‰æµÂÖ•„ÄÇ${count}‰Ωì„ÅÆÊïµ„ÅåÁèæ„Çå„ÅüÔºÅ`);
      buildTurnQueue();
      game.awaitingInput = true;
      updateUI(derived);
      promptPlayerTurn();
    }

    function getEffectiveSpeed(entity, type) {
      let speed = entity.spd || 0;
      if (type === "player" && player.buffs.haste > 0 && !hasStatus(entity, "seal")) {
        speed += 2;
      }
      const speedDown = getStatus(entity, "speedDown");
      if (speedDown) {
        speed *= 1 - (speedDown.potency ?? STATUS_DEFINITIONS.speedDown.potency ?? 0.25);
      }
      if (hasStatus(entity, "knockdown")) {
        speed = Math.max(0.2, speed * 0.1);
      }
      return speed + Math.random() * 2;
    }

    function decayStatuses(entity) {
      entity.statuses = (entity.statuses || [])
        .map((s) => ({ ...s, remaining: s.remaining - 1 }))
        .filter((s) => s.remaining > 0);
    }

    function tickBuffs(entity) {
      if (!entity.buffs) return;
      Object.keys(entity.buffs).forEach((key) => {
        if (entity.buffs[key] > 0) entity.buffs[key] -= 1;
      });
    }

    function tickSkillCooldowns() {
      player.activeSkillSlots = player.activeSkillSlots || [];
      player.activeSkillSlots.forEach((slot) => {
        if (slot.cooldownRemaining > 0) {
          slot.cooldownRemaining = Math.max(0, slot.cooldownRemaining - 1);
        }
      });
    }

    function buildTurnQueue() {
      const queue = [];
      if (player.hp > 0) {
        queue.push({ type: "player", speed: getEffectiveSpeed(player, "player") });
      }
      game.enemies.filter(e => e.hp > 0).forEach(e => {
        queue.push({ type: "enemy", id: e.id, speed: getEffectiveSpeed(e, "enemy") });
      });
      queue.sort((a, b) => b.speed - a.speed);
      game.turnQueue = queue;
    }

    function applyStatus(target, key, { duration = 2, chance = 100, potency, payload, ignoreResist = false } = {}) {
      const def = STATUS_DEFINITIONS[key];
      if (!def) return false;
      const resist = ignoreResist ? 0 : getResist(target, def.category);
      const effectiveChance = Math.max(0, Math.min(100, chance - resist));
      if (effectiveChance <= 0) return false;
      const roll = Math.random() * 100;
      if (roll > effectiveChance) return false;
      const existing = getStatus(target, key);
      if (existing) {
        existing.remaining = Math.max(existing.remaining, duration);
        if (potency !== undefined) existing.potency = potency;
        if (payload !== undefined) existing.payload = payload;
      } else {
        target.statuses = target.statuses || [];
        target.statuses.push({ key, remaining: duration, potency: potency ?? def.potency ?? 0, payload });
      }
      if (key === "seal" && target.buffs) {
        Object.keys(target.buffs).forEach((buff) => (target.buffs[buff] = 0));
      }
      return true;
    }

    function calculateDotDamage(target, status) {
      switch (status.key) {
        case "bleed":
          return Math.max(1, Math.round(((status.payload?.attack || target.maxHp * 0.05) * 0.4)));
        case "poison":
          return Math.max(1, Math.round(target.maxHp * 0.06 + 2));
        case "curse":
          return Math.max(1, Math.round(target.maxHp * 0.04 + 1));
        case "burn":
          return Math.max(1, Math.round(target.maxHp * 0.05 + 3));
        default:
          return 0;
      }
    }

    function applyDotEffects(entity) {
      (entity.statuses || []).forEach((status) => {
        const def = STATUS_DEFINITIONS[status.key];
        if (!def || def.category !== STATUS_CATEGORIES.dot) return;
        const dotDmg = calculateDotDamage(entity, status);
        if (dotDmg <= 0) return;
        const dealt = applyDamage(entity, dotDmg, { type: "dot", source: status.key, isDot: true });
        if (dealt > 0) {
          log(`ü©∏ ${entity.name} „ÅØ${def.name}„Åß ${dealt} „ÉÄ„É°„Éº„Ç∏`, "danger");
        }
      });
    }

    function processTurnStart(entity) {
      const baseAttacks = Math.max(0, Math.floor(entity.attackCount || 0));
      entity.attacksRemaining = baseAttacks;
      applyDotEffects(entity);
      if (entity.hp <= 0) return { defeated: true, skipTurn: true };
      if (entity === player) {
        tickSkillCooldowns();
      }
      const skipTurn = hasStatus(entity, "stun") || hasStatus(entity, "sleep");
      if (skipTurn) {
        log(`${entity.name} „ÅØË°åÂãï‰∏çËÉΩ‚Ä¶`, "warning");
      }
      return { skipTurn, defeated: false };
    }

    function finalizeTurn(entity) {
      decayStatuses(entity);
      tickBuffs(entity);
    }

    function updateBars(id, current, max, cls) {
      const bar = document.getElementById(id);
      const percent = Math.max(0, Math.min(100, (current / max) * 100));
      bar.style.width = `${percent}%`;
      bar.className = cls;
    }

    function flashBar(spanId) {
      const fill = document.getElementById(spanId);
      const bar = fill?.parentElement;
      if (!bar) return;
      bar.classList.remove("flash");
      // Âº∑Âà∂ÂÜçË®àÊ∏¨„Åß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÁπ∞„ÇäËøî„ÅóÈÅ©Áî®
      void bar.offsetWidth;
      bar.classList.add("flash");
    }

    function showDamagePopup(container, amount, variant = "enemy") {
      if (!container) return;
      const popup = document.createElement("div");
      popup.className = `damage-popup ${variant}`;
      const numeric = Math.abs(amount);
      popup.textContent = amount >= 0 ? `-${numeric}` : `+${numeric}`;
      container.appendChild(popup);
      popup.addEventListener("animationend", () => popup.remove());
    }

    function consumeMp(cost) {
      if (!cost || cost <= 0) return;
      player.mp = Math.max(0, player.mp - cost);
      flashBar("mp-bar");
      const mpBar = document.getElementById("mp-bar")?.parentElement;
      showDamagePopup(mpBar, cost, "mp");
    }

    function findEnemyCard(enemy) {
      return document.querySelector(`.enemy-card[data-enemy-id="${enemy?.id}"]`);
    }

    function triggerEnemyHit(enemy, amount = 0) {
      const card = findEnemyCard(enemy);
      if (!card) return;
      const bar = card.querySelector(".enemy-bar");
      if (bar) {
        bar.classList.remove("pulse");
        void bar.offsetWidth;
        bar.classList.add("pulse");
      }
      showDamagePopup(card, amount, "enemy");
    }

    function updateEnemyCardHp(enemy) {
      const card = findEnemyCard(enemy);
      if (!card) return;
      const fill = card.querySelector(".enemy-bar .fill");
      const label = card.querySelector(".enemy-bar .label");
      const hpPct = Math.max(0, Math.floor((enemy.hp / enemy.maxHp) * 100));
      if (fill) fill.style.width = `${hpPct}%`;
      if (label) label.textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp} (${hpPct}%)`;
    }

    function updateUI(derivedStats = null) {
      const derived = derivedStats || recalcDerivedStats();
      lastDerivedStats = derived;
      updateStepButton();
      document.getElementById("floor-inline").textContent = game.floor;
      document.getElementById("hp-label").textContent = `HP ${Math.ceil(player.hp)} / ${derived.maxHp.total}`;
      document.getElementById("mp-label").textContent = `MP ${Math.ceil(player.mp)} / ${derived.maxMp.total}`;
      document.getElementById("exp-label").textContent = `EXP ${player.exp} / ${player.expToLevel}`;
      document.getElementById("level").textContent = player.level;
      document.getElementById("gold").textContent = formatGold(player.gold);
      document.getElementById("stat-points").textContent = player.statPoints;
      document.getElementById("skill-points-skill").textContent = player.skillPoints;
      updateBars("hp-bar", player.hp, derived.maxHp.total, "hp");
      updateBars("mp-bar", player.mp, derived.maxMp.total, "mp");
      updateBars("exp-bar", player.exp, player.expToLevel, "exp");
      const phone = document.querySelector(".phone");
      phone?.classList.toggle("player-down", player.hp <= 0);

      renderEnemies();
      renderActions();
      renderSecondaryStats(derived);
      renderPrimaryStats();
      renderSkills();
      renderStatusList(document.getElementById("player-status-list"), player);
    }

    function renderStatusList(container, entity) {
      if (!container) return;
      container.innerHTML = "";
      (entity.statuses || []).forEach((status) => {
        const def = STATUS_DEFINITIONS[status.key];
        if (!def) return;
        const pill = document.createElement("div");
        pill.className = `status-pill ${def.category}`;
        pill.textContent = def.short;
        pill.title = describeStatus(status);
        pill.onclick = (e) => {
          e.stopPropagation();
          showStatusPopover(def, status);
        };
        container.appendChild(pill);
      });
    }

    function renderDebugStatusButtons() {
      const container = document.getElementById("debug-status-buttons");
      if (!container) return;
      container.innerHTML = "";
      const groups = { control: [], dot: [], debuff: [] };
      Object.entries(STATUS_DEFINITIONS).forEach(([key, def]) => {
        if (!groups[def.category]) return;
        groups[def.category].push({ key, def });
      });

      Object.entries(groups).forEach(([category, items]) => {
        const section = document.createElement("div");
        section.className = "debug-section";
        const title = document.createElement("h4");
        const label =
          category === STATUS_CATEGORIES.control
            ? "Ë°åÂãïÈòªÂÆ≥"
            : category === STATUS_CATEGORIES.dot
              ? "DoT"
              : "Âº±‰ΩìÂåñ";
        title.textContent = `${label} (${items.length})`;
        section.appendChild(title);

        const row = document.createElement("div");
        row.className = "debug-buttons";
        items.forEach(({ key, def }) => {
          const btn = document.createElement("button");
          btn.textContent = `${def.short} ${def.name}`;
          btn.onclick = () => {
            const target = getDebugTarget();
            if (!target) {
              log("ÂØæË±°„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì", "warning");
              return;
            }
            const applied = applyStatus(target, key, { duration: 3, chance: 100, potency: def.potency, ignoreResist: true });
            if (applied) {
              log(`üêû „Éá„Éê„ÉÉ„Ç∞: ${target.name} „Å´${def.name}„Çí‰ªò‰∏é`, "info");
              updateUI();
            } else {
              log("‰ªò‰∏é„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", "warning");
            }
          };
          row.appendChild(btn);
        });
        section.appendChild(row);
        container.appendChild(section);
      });
    }

    function populateDebugEnemySelect() {
      const select = document.getElementById("debug-enemy");
      if (!select) return;
      select.innerHTML = "";
      if (!game.enemies.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Êïµ„Å™„Åó";
        select.appendChild(opt);
        return;
      }
      game.enemies.forEach((enemy, index) => {
        const opt = document.createElement("option");
        opt.value = String(enemy.id);
        opt.textContent = `#${index + 1} ${enemy.name}${enemy.hp <= 0 ? " (ÊíÉÁ†¥)" : ""}`;
        select.appendChild(opt);
      });
    }

    function updateDebugTargetState() {
      const targetSelect = document.getElementById("debug-target");
      const enemySelect = document.getElementById("debug-enemy");
      if (!targetSelect || !enemySelect) return;
      const isPlayer = targetSelect.value === "player";
      enemySelect.disabled = isPlayer;
      if (!isPlayer && enemySelect.options.length > 0 && !enemySelect.value) {
        enemySelect.value = enemySelect.options[0].value;
      }
    }

    function getDebugTarget() {
      const targetSelect = document.getElementById("debug-target");
      const enemySelect = document.getElementById("debug-enemy");
      if (!targetSelect) return null;
      if (targetSelect.value === "player") return player;
      const enemyId = enemySelect?.value;
      if (!enemyId) return game.enemies[0] || null;
      return (
        game.enemies.find((e) => String(e.id) === enemyId && e.hp > 0) ||
        game.enemies.find((e) => String(e.id) === enemyId) ||
        game.enemies[0] ||
        null
      );
    }

    function populateDebugGearSelects() {
      if (!debugGearSlotSelect || !debugGearRaritySelect) return;
      if (!debugGearSlotSelect.options.length) {
        Object.entries(EQUIPMENT_SLOTS).forEach(([key, def]) => {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = def.label;
          debugGearSlotSelect.appendChild(opt);
        });
      }
      if (!debugGearRaritySelect.options.length) {
        DEBUG_RARITY_OPTIONS.forEach((rarity) => {
          const opt = document.createElement("option");
          opt.value = rarity.key;
          opt.textContent = rarity.label;
          debugGearRaritySelect.appendChild(opt);
        });
      }
      if (!debugGearSlotSelect.value) debugGearSlotSelect.value = "weapon";
      if (!debugGearRaritySelect.value) debugGearRaritySelect.value = "random";
    }

    function populateLegendaryTemplateSelect() {
      if (!debugLegendarySelect) return;
      const slotKey = debugGearSlotSelect?.value || "weapon";
      const rarityKey = debugGearRaritySelect?.value;
      const isLegendary = rarityKey === "legendary";

      debugLegendaryWrapper?.classList.toggle("hidden", !isLegendary);
      debugLegendarySelect.innerHTML = "";
      if (!isLegendary) return;

      const list = LEGENDARY_EQUIPMENT_LIBRARY[slotKey] || [];
      const randomOpt = document.createElement("option");
      randomOpt.value = "";
      randomOpt.textContent = "„Åä„Åæ„Åã„ÅõÔºà„É©„É≥„ÉÄ„É†Ôºâ";
      debugLegendarySelect.appendChild(randomOpt);

      list.forEach((entry) => {
        const opt = document.createElement("option");
        opt.value = entry.key;
        opt.textContent = entry.name;
        debugLegendarySelect.appendChild(opt);
      });

      if (!debugLegendarySelect.value) debugLegendarySelect.value = "";
    }

    function switchDebugTab(tabKey) {
      const panels = {
        status: debugTabStatus,
        equipment: debugTabEquipment,
        adjust: debugTabAdjust,
        save: debugTabSave,
      };
      Object.entries(panels).forEach(([key, panel]) => {
        panel?.classList.toggle("hidden", key !== tabKey);
      });
      debugTabButtons.forEach((btn) => {
        const active = btn.dataset.tab === tabKey;
        btn.classList.toggle("active", active);
      });
      if (tabKey === "equipment") {
        populateDebugGearSelects();
        populateLegendaryTemplateSelect();
        renderDebugGearPreview(lastGeneratedEquipment);
      } else if (tabKey === "status") {
        populateDebugEnemySelect();
        renderDebugStatusButtons();
        updateDebugTargetState();
      } else if (tabKey === "adjust") {
        syncDebugAdjustInputs();
      } else if (tabKey === "save") {
        renderSaveSlots();
      }
    }

    function calcExpToNextLevel(targetLevel) {
      let req = 20;
      for (let level = 1; level < targetLevel; level += 1) {
        req = Math.round(req * 1.18);
      }
      return req;
    }

    function syncDebugAdjustInputs() {
      if (debugLevelInput) debugLevelInput.value = player.level;
      if (debugHpInput) debugHpInput.value = Math.round(player.hp);
      if (debugFloorInput) debugFloorInput.value = game.floor;
    }

    function applyDebugLevelChange() {
      if (!debugLevelInput) return;
      const requested = Number(debugLevelInput.value);
      if (Number.isNaN(requested)) return;
      const nextLevel = Math.max(1, Math.floor(requested));
      const delta = nextLevel - player.level;
      if (delta === 0) {
        log("„É¨„Éô„É´„ÅØÊó¢„Å´ÊåáÂÆöÂÄ§„Åß„Åô", "info");
        return;
      }

      player.level = nextLevel;
      player.exp = 0;
      player.expToLevel = calcExpToNextLevel(nextLevel);
      player.statPoints = Math.max(0, player.statPoints + delta * 5);
      player.skillPoints = Math.max(0, player.skillPoints + delta);

      const derived = recalcDerivedStats();
      updateUI(derived);
      log(`üîß Lv${nextLevel} „Å´Â§âÊõ¥ (ËÉΩÂäõP${delta >= 0 ? "+" : ""}${delta * 5} / „Çπ„Ç≠„É´P${delta >= 0 ? "+" : ""}${delta})`, "info");
      maybeAutoSave("„Éá„Éê„ÉÉ„Ç∞:„É¨„Éô„É´Â§âÊõ¥");
    }

    function applyDebugHpChange() {
      if (!debugHpInput) return;
      const requested = Number(debugHpInput.value);
      if (Number.isNaN(requested)) return;
      const nextHp = Math.max(0, Math.floor(requested));
      player.hp = Math.min(nextHp, Math.round(player.maxHp));
      updateUI();
      log(`üíö HP„Çí ${player.hp} „Å´Ë®≠ÂÆö`, "info");
      maybeAutoSave("„Éá„Éê„ÉÉ„Ç∞:HPË™øÊï¥");
    }

    function applyDebugFloorChange() {
      if (!debugFloorInput) return;
      const requested = Number(debugFloorInput.value);
      if (Number.isNaN(requested)) return;
      const nextFloor = Math.max(1, Math.floor(requested));
      if (nextFloor !== game.floor) {
        game.floor = nextFloor;
        game.turnQueue = [];
        spawnEnemies();
        log(`üåÄ ${nextFloor}F „Å∏„Ç∏„É£„É≥„Éó`, "info");
        maybeAutoSave("„Éá„Éê„ÉÉ„Ç∞:ÈöéÂ±§Â§âÊõ¥");
      } else {
        log("ÁèæÂú®„ÅÆÈöéÂ±§„Å®Âêå„Åò„Åß„Åô", "info");
      }
    }

    const SAVE_VERSION = 1;
    const SAVE_SLOTS = [
      { id: "slot1", label: "„Çπ„É≠„ÉÉ„Éà1" },
      { id: "slot2", label: "„Çπ„É≠„ÉÉ„Éà2" },
      { id: "slot3", label: "„Çπ„É≠„ÉÉ„Éà3" },
    ];
    const ACTIVE_SAVE_SLOT_KEY = "hakusura-active-slot";
    const AUTO_SAVE_COOLDOWN_MS = 3000;
    let lastAutoSaveAt = 0;
    let activeSaveSlotId = "slot1";

    const INITIAL_SAVE_STATE = buildSaveState();

function maybeAutoSave(reason = "auto") {
  try {
    requestAutoSave(reason); // „ÇØ„Éº„É´„Çø„Ç§„É†„ÇÇÂê´„ÇÅ„Å¶‰∏≠„Åß„ÇÑ„Å£„Å¶„ÇÇ„Çâ„ÅÜ
  } catch (e) {
    console.error("auto save failed:", e);
  }
}
      
    function cloneState(data) {
      if (typeof structuredClone === "function") return structuredClone(data);
      return JSON.parse(JSON.stringify(data));
    }

    function saveStorageKey(slotId, type = "primary") {
      return `hakusura-save-${slotId}-${type}`;
    }

    function readSave(slotId, type = "primary") {
      try {
        const raw = localStorage.getItem(saveStorageKey(slotId, type));
        if (!raw) return null;
        const data = JSON.parse(raw);
        if (data?.version !== SAVE_VERSION) return null;
        return data;
      } catch (err) {
        console.warn("save read failed", err);
        return null;
      }
    }

    function writeSave(slotId, state, { silent = false, reason = "ÊâãÂãï‰øùÂ≠ò" } = {}) {
      try {
        const payload = { ...state, version: SAVE_VERSION, savedAt: Date.now(), reason };
        const primaryKey = saveStorageKey(slotId, "primary");
        const backupKey = saveStorageKey(slotId, "backup");
        const currentPrimary = localStorage.getItem(primaryKey);
        if (currentPrimary) {
          localStorage.setItem(backupKey, currentPrimary);
        }
        localStorage.setItem(primaryKey, JSON.stringify(payload));
        if (!silent) {
          log(`üíæ ${getSaveSlotLabel(slotId)} „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü`, "good");
        }
      } catch (err) {
        console.error("save failed", err);
        if (!silent) log("‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü („Çπ„Éà„É¨„Éº„Ç∏‰ΩøÁî®‰∏çÂèØ)", "danger");
      }
    }

    function deleteSave(slotId) {
      localStorage.removeItem(saveStorageKey(slotId, "primary"));
      localStorage.removeItem(saveStorageKey(slotId, "backup"));
      log(`üóë ${getSaveSlotLabel(slotId)} „ÇíÂâäÈô§„Åó„Åæ„Åó„Åü`, "info");
    }

    function buildSaveState() {
      return cloneState({
        player,
        game,
        skills,
      });
    }

    function replaceObject(target, source) {
      Object.keys(target).forEach((key) => delete target[key]);
      Object.entries(source).forEach(([key, value]) => {
        target[key] = cloneState(value);
      });
    }

    function restoreAttackCounts() {
      player.attacksRemaining = Math.max(0, Math.floor(player.attackCount || 0));
      game.enemies = game.enemies || [];
      game.enemies.forEach((enemy) => {
        enemy.attacksRemaining = Math.max(0, Math.floor(enemy.attackCount || 0));
      });
    }

    function applyLoadedState(state, { usedBackup = false, slotId, suppressLog = false } = {}) {
      if (!state) return false;
      const payload = cloneState(state);
      replaceObject(player, payload.player || {});
      replaceObject(game, payload.game || {});
      mergeSkillsFromSave(payload.skills || {});
      calculateSkillBonuses();
      const derived = recalcDerivedStats();
      const battleActive = game.awaitingInput || (game.enemies || []).some((e) => e.hp > 0);
      if (battleActive) {
        restoreAttackCounts();
      }
      updateUI(derived);
      renderInventoryFilters();
      renderInventory();
      renderSkillSummary();
      renderActiveSkillLoadout();
      buildTurnQueue();
      if (!suppressLog) {
        log(
          `üìÇ ${getSaveSlotLabel(slotId)} „Åã„Çâ„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü${usedBackup ? " („Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Åã„ÇâÂæ©Êóß)" : ""}`,
          "good"
        );
      }
      return true;
    }

    function getSaveSlotLabel(slotId) {
      const def = SAVE_SLOTS.find((s) => s.id === slotId);
      return def ? def.label : slotId;
    }

    function isPlayableSlot(slotId) {
      return SAVE_SLOTS.some((s) => s.id === slotId);
    }

    function setActiveSaveSlot(slotId, { persist = true, announce = false } = {}) {
      if (!isPlayableSlot(slotId)) return;
      activeSaveSlotId = slotId;
      if (persist) localStorage.setItem(ACTIVE_SAVE_SLOT_KEY, slotId);
      if (announce) log(`üéØ ÁèæÂú®„ÅÆ„Çª„Éº„ÉñÂÖà: ${getSaveSlotLabel(slotId)}`, "info");
      renderSaveSlots();
    }

    function startNewRun(slotId) {
      applyLoadedState(INITIAL_SAVE_STATE, { slotId, suppressLog: true });
      spawnEnemies();
      setActiveSaveSlot(slotId, { announce: true });
      log("=== Êñ∞„Åó„ÅèÊåëÊà¶„ÇíÈñãÂßã ===", "info");
    }

    function activateSaveSlot(slotId) {
      if (!isPlayableSlot(slotId)) return;
      const { primary, backup } = readSlotPair(slotId);
      const source = primary || backup;
      if (source) {
        applyLoadedState(source, { usedBackup: !primary && !!backup, slotId });
        setActiveSaveSlot(slotId, { announce: true });
        return;
      }
      startNewRun(slotId);
    }

    function loadActiveSlotPreference() {
      const stored = localStorage.getItem(ACTIVE_SAVE_SLOT_KEY);
      if (isPlayableSlot(stored)) {
        activeSaveSlotId = stored;
      } else {
        activeSaveSlotId = "slot1";
        localStorage.setItem(ACTIVE_SAVE_SLOT_KEY, activeSaveSlotId);
      }
    }

    function autoLoadLastActiveSlot() {
      const { primary, backup } = readSlotPair(activeSaveSlotId);
      const source = primary || backup;
      if (!source) return false;
      try {
        applyLoadedState(source, { usedBackup: !primary && !!backup, slotId: activeSaveSlotId });
        return true;
      } catch (err) {
        console.error("failed to load save", err);
        log("„Çª„Éº„Éñ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åü„Åü„ÇÅ„ÄÅÊñ∞„Åó„ÅèÈñãÂßã„Åó„Åæ„Åô", "warning");
        return false;
      }
    }

    function readSlotPair(slotId) {
      return {
        primary: readSave(slotId, "primary"),
        backup: readSave(slotId, "backup"),
      };
    }

    function formatSaveMeta(state) {
      if (!state) return "Êú™‰øùÂ≠ò";
      const date = state.savedAt ? new Date(state.savedAt) : null;
      const ts = date ? date.toLocaleString() : "‰∏çÊòé„Å™Êó•ÊôÇ";
      const level = state.player?.level ?? "?";
      const floor = state.game?.floor ?? "?";
      return `Lv${level} / ${floor}F @ ${ts}`;
    }

    function renderSaveSlots() {
      if (!saveSlotList) return;
      saveSlotList.innerHTML = "";
      SAVE_SLOTS.forEach((slot) => {
        const pair = readSlotPair(slot.id);
        const card = document.createElement("div");
        card.className = "save-slot-card";
        if (slot.id === activeSaveSlotId) card.classList.add("active");

        const header = document.createElement("div");
        header.className = "save-slot-header";
        const title = document.createElement("div");
        title.className = "save-slot-title";
        title.textContent = slot.label;
        if (slot.id === activeSaveSlotId) {
          const activeBadge = document.createElement("span");
          activeBadge.className = "save-slot-badge pill";
          activeBadge.textContent = "„Éó„É¨„Ç§‰∏≠";
          title.appendChild(activeBadge);
        }
        if (slot.description) {
          const badge = document.createElement("span");
          badge.className = "save-slot-badge pill";
          badge.textContent = slot.description;
          title.appendChild(badge);
        }
        const meta = document.createElement("div");
        meta.className = "save-slot-meta";
        meta.textContent = formatSaveMeta(pair.primary || pair.backup);
        header.appendChild(title);
        header.appendChild(meta);

        const actions = document.createElement("div");
        actions.className = "save-slot-actions";

        const activateBtn = document.createElement("button");
        activateBtn.textContent = "„Åì„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÅßÈÅä„Å∂";
        activateBtn.onclick = () => activateSaveSlot(slot.id);
        actions.appendChild(activateBtn);

        const saveBtn = document.createElement("button");
        saveBtn.textContent = "„Åì„ÅÆ„Çπ„É≠„ÉÉ„Éà„Å´‰øùÂ≠ò";
        saveBtn.dataset.saveAction = "save";
        saveBtn.dataset.slot = slot.id;
        actions.appendChild(saveBtn);

        const loadBtn = document.createElement("button");
        loadBtn.textContent = "„É≠„Éº„Éâ";
        loadBtn.dataset.saveAction = "load";
        loadBtn.dataset.slot = slot.id;
        loadBtn.disabled = !pair.primary && !pair.backup;
        actions.appendChild(loadBtn);

        const exportBtn = document.createElement("button");
        exportBtn.textContent = "JSON„Çí„Ç≥„Éî„Éº";
        exportBtn.dataset.saveAction = "export";
        exportBtn.dataset.slot = slot.id;
        exportBtn.disabled = !pair.primary && !pair.backup;
        actions.appendChild(exportBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "„Éá„Éº„ÇøÂâäÈô§";
        deleteBtn.dataset.saveAction = "delete";
        deleteBtn.dataset.slot = slot.id;
        deleteBtn.disabled = !pair.primary && !pair.backup;
        actions.appendChild(deleteBtn);

        const backupRow = document.createElement("div");
        backupRow.className = "subtle";
        backupRow.textContent = pair.backup
          ? "„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅÇ„Çä (Áõ¥Ââç„ÅÆ‰øùÂ≠ò„Çí‰øùÊåÅ)"
          : "„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊú™‰ΩúÊàê";

        card.appendChild(header);
        card.appendChild(actions);
        card.appendChild(backupRow);
        saveSlotList.appendChild(card);
      });
    }

    function handleSaveAction(event) {
      const btn = event.target.closest("[data-save-action]");
      if (!btn) return;
      const slotId = btn.dataset.slot;
      const action = btn.dataset.saveAction;
      if (!slotId || !action) return;
      if (action === "save") {
        writeSave(slotId, buildSaveState());
        if (isPlayableSlot(slotId)) setActiveSaveSlot(slotId, { announce: true });
        renderSaveSlots();
      } else if (action === "load") {
        const { primary, backup } = readSlotPair(slotId);
        const source = primary || backup;
        if (!source) {
          log("‰øùÂ≠ò„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", "warning");
          return;
        }
        applyLoadedState(source, { usedBackup: !primary && !!backup, slotId });
        if (isPlayableSlot(slotId)) setActiveSaveSlot(slotId, { announce: true });
        renderSaveSlots();
      } else if (action === "delete") {
        deleteSave(slotId);
        if (slotId === activeSaveSlotId) {
          startNewRun(slotId);
        } else {
          renderSaveSlots();
        }
      } else if (action === "export") {
        const { primary, backup } = readSlotPair(slotId);
        const source = primary || backup;
        if (!source) {
          log("„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åß„Åç„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", "warning");
          return;
        }
        const json = JSON.stringify(source);
        navigator.clipboard
          ?.writeText(json)
          .then(() => log("„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü", "info"))
          .catch(() => {
            log("„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊâãÂãï„ÅßÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "warning");
            prompt("‰∏ãË®ò„Çí„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ", json);
          });
      }
    }

    function requestAutoSave(reason = "„Ç™„Éº„Éà„Çª„Éº„Éñ") {
      const now = Date.now();
      if (now - lastAutoSaveAt < AUTO_SAVE_COOLDOWN_MS) return;
      lastAutoSaveAt = now;
      const targetSlot = isPlayableSlot(activeSaveSlotId) ? activeSaveSlotId : "slot1";
      writeSave(targetSlot, buildSaveState(), { silent: true, reason });
      renderSaveSlots();
    }

    let lastGeneratedEquipment = null;

    function renderDebugGearPreview(item) {
      if (!debugGearPreview) return;
      debugGearPreview.innerHTML = "";
      if (!item) {
        const empty = document.createElement("div");
        empty.className = "option-label";
        empty.textContent = "„Éó„É¨„Éì„É•„Éº„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô";
        debugGearPreview.appendChild(empty);
        return;
      }

      const title = document.createElement("div");
      title.className = "option-value";
      title.textContent = `${item.name} (${EQUIPMENT_RARITIES[item.equipment?.rarity]?.label || item.equipment?.rarityLabel || ""})`;
      applyItemRarityColor(title, item);
      debugGearPreview.appendChild(title);

      const slot = document.createElement("div");
      slot.className = "option-label";
      const slotLabel = EQUIPMENT_SLOTS[item.equipment?.slot]?.label || item.equipment?.slot;
      slot.textContent = `ÈÉ®‰Ωç: ${slotLabel}`;
      debugGearPreview.appendChild(slot);

      const appendList = (titleText, options) => {
        if (!options?.length) return;
        const heading = document.createElement("div");
        heading.className = "option-label";
        heading.textContent = titleText;
        debugGearPreview.appendChild(heading);
        options.forEach((opt) => {
          const row = document.createElement("div");
          row.className = "option-value";
          row.textContent = formatEquipmentValue(opt);
          debugGearPreview.appendChild(row);
        });
      };

      const appendAffix = (label, affix) => {
        if (!affix?.options?.length) return;
        appendList(`${label} (‚òÖ${affix.rank}) ${affix.name}`, affix.options);
      };

      if (item.equipment?.uniqueOptions?.length) {
        const heading = document.createElement("div");
        heading.className = "option-label";
        heading.textContent = "Âõ∫Êúâ„Ç™„Éó„Ç∑„Éß„É≥";
        debugGearPreview.appendChild(heading);
        item.equipment.uniqueOptions.forEach((opt) => {
          const row = document.createElement("div");
          row.className = "option-value";
          row.textContent = `${opt.name}: ${opt.effect}`;
          debugGearPreview.appendChild(row);
        });
      }
      appendList("Âü∫Á§é„Ç™„Éó„Ç∑„Éß„É≥", item.equipment?.baseOptions);
      appendList("„É©„É≥„ÉÄ„É†„Ç™„Éó„Ç∑„Éß„É≥", item.equipment?.randomOptions);
      appendAffix("ÂâçÁß∞Âè∑", item.equipment?.prefix);
      appendAffix("ÂæåÁß∞Âè∑", item.equipment?.suffix);
    }

    function resolveDebugRarity(selection) {
      if (selection === "legendary") return "legendary";
      return NON_LEGENDARY_RARITIES[randomInt(0, NON_LEGENDARY_RARITIES.length - 1)];
    }

    function generateDebugGear({ randomRarity = false } = {}) {
      if (!debugGearSlotSelect || !debugGearRaritySelect) return null;
      const slotKey = debugGearSlotSelect.value || "weapon";
      const rarityChoice = randomRarity
        ? DEBUG_RARITY_OPTIONS[randomInt(0, DEBUG_RARITY_OPTIONS.length - 1)]?.key
        : debugGearRaritySelect.value;
      const rarityKey = resolveDebugRarity(rarityChoice);
      const legendaryKey = rarityChoice === "legendary" ? debugLegendarySelect?.value || "" : "";
      const item = createEquipmentItem(slotKey, rarityKey, { legendaryKey });
      lastGeneratedEquipment = item;
      player.inventory.items.push(item);
      log(`üõ†Ô∏è ${item.name} „ÇíÁîüÊàê„Åó„Ç§„É≥„Éô„É≥„Éà„É™„Å∏ËøΩÂä†`, "info");
      renderInventory();
      renderDebugGearPreview(item);
      return item;
    }

    function openDebugModal() {
      switchDebugTab("status");
      debugModal?.classList.remove("hidden");
    }

    function closeDebugModal() {
      debugModal?.classList.add("hidden");
    }

    function renderEnemies() {
  const wrapper = document.getElementById("enemies");
  if (!wrapper) return;

  const enemyColumns = Math.max(1, Math.min(3, game.enemies.length || 1));
  wrapper.style.setProperty("--enemy-columns", enemyColumns);

  // ‚òÖ „ÅÑ„ÅæÁîªÈù¢‰∏ä„Å´„ÅÇ„Çã .enemy-card „ÇíÂÖ®ÈÉ®Êãæ„Å£„Å¶„Åä„Åè
  const existing = new Map(
    Array.from(wrapper.querySelectorAll(".enemy-card")).map((card) => [
      card.dataset.enemyId,
      card,
    ])
  );
  const used = new Set();

  function createEnemyCard(enemy) {
    const card = document.createElement("div");
    card.className = "enemy-card";
    card.dataset.enemyId = String(enemy.id);
    card.setAttribute("role", "button");
    card.setAttribute("aria-label", `${enemy.name} „ÅÆË©≥Á¥∞`);

    const top = document.createElement("div");
    top.className = "enemy-top";

    const name = document.createElement("div");
    name.className = "enemy-name";
    const titleLabel = document.createElement("span");

    const meta = document.createElement("div");
    meta.className = "enemy-meta";
    const order = document.createElement("span");
    const archetype = document.createElement("span");
    archetype.className = "tag clickable";
    const statusList = document.createElement("div");
    statusList.className = "status-list";
    meta.appendChild(order);
    meta.appendChild(archetype);
    meta.appendChild(statusList);

    name.appendChild(titleLabel);
    name.appendChild(meta);
    top.appendChild(name);

    const tag = document.createElement("div");
    tag.className = "pill";
    tag.textContent = "BOSS";
    top.appendChild(tag);

    const bar = document.createElement("div");
    bar.className = "enemy-bar";
    bar.addEventListener("animationend", (event) => {
      if (event.animationName === "barPulse") bar.classList.remove("pulse");
    });
    const fill = document.createElement("span");
    fill.className = "fill";
    const hpLabel = document.createElement("span");
    hpLabel.className = "label";
    bar.appendChild(fill);
    bar.appendChild(hpLabel);

    const attackBadge = document.createElement("div");
    attackBadge.className = "attack-badge enemy";
    attackBadge.title = "1„Çø„Éº„É≥„ÅÇ„Åü„Çä„ÅÆÊîªÊíÉÂõûÊï∞";

    card.appendChild(top);
    card.appendChild(bar);
    card.appendChild(attackBadge);

    card._refs = {
      titleLabel,
      order,
      archetype,
      statusList,
      tag,
      bar,
      fill,
      hpLabel,
      attackBadge,
    };
    return card;
  }

  function updateEnemyCard(card, enemy, index) {
    const refs = card._refs || {};
    card.dataset.enemyId = String(enemy.id);
    card.onclick = () => openEnemyModal(enemy);
    card.classList.toggle("defeated", enemy.hp <= 0);

    if (refs.titleLabel) {
      refs.titleLabel.textContent = `${enemy.isBoss ? "üëë" : "üëæ"} ${enemy.name}`;
    }
    if (refs.order) {
      refs.order.textContent = `#${index + 1}`;
    }

    if (refs.archetype) {
      const hasArchetype = Boolean(enemy.archetypeLabel && !enemy.isBoss);
      refs.archetype.style.display = hasArchetype ? "inline-flex" : "none";
      refs.archetype.textContent = hasArchetype ? enemy.archetypeLabel : "";
      refs.archetype.onclick = hasArchetype
        ? (event) => {
            event.stopPropagation();
            openArchetypeModal(enemy);
          }
        : null;
    }

    if (refs.statusList) {
      refs.statusList.innerHTML = "";
      renderStatusList(refs.statusList, enemy);
    }

    if (refs.tag) {
      refs.tag.textContent = enemy.isBoss ? "BOSS" : "ENEMY";
      refs.tag.style.display = enemy.isBoss ? "inline-flex" : "none";
    }

    const hpPct =
      enemy.maxHp > 0 ? Math.max(0, Math.floor((enemy.hp / enemy.maxHp) * 100)) : 0;
    if (refs.fill) {
      refs.fill.style.width = `${hpPct}%`;
    }
    if (refs.hpLabel) {
      refs.hpLabel.textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp} (${hpPct}%)`;
    }

    if (refs.attackBadge) {
      const enemyAttacks = Math.max(
        0,
        enemy.attacksRemaining ?? enemy.attackCount ?? 0
      );
      refs.attackBadge.textContent = `x${enemyAttacks}`;
    }
  }

  // ‚òÖ „Åì„Åì„ÅåÈáçË¶ÅÔºöwrapper.innerHTML = "" „ÅßÂÖ®Ê∂à„Åó„Åó„Å™„ÅÑÔºÅ
  // Êó¢Â≠ò„Ç´„Éº„Éâ„ÇíÂÜçÂà©Áî®„Åó„Å§„Å§„ÄÅË∂≥„Çä„Å™„ÅÑÂàÜ„Å†„ÅëÊñ∞Ë¶è‰ΩúÊàê
  game.enemies.forEach((enemy, index) => {
    const id = String(enemy.id);
    let card = existing.get(id);
    if (!card) {
      card = createEnemyCard(enemy);
      wrapper.appendChild(card);
    }
    updateEnemyCard(card, enemy, index);
    used.add(id);
  });

  // „ÇÇ„ÅÜ„ÅÑ„Å™„ÅÑÊïµ„ÅÆ„Ç´„Éº„Éâ„Å†„ÅëÁâá‰ªò„Åë„Çã
  existing.forEach((card, id) => {
    if (!used.has(id)) card.remove();
  });
}


    function renderActions() {
      const container = document.getElementById("actions");
      container.innerHTML = "";
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      const battleInProgress = game.awaitingInput || enemiesAlive || (game.turnQueue?.length > 0);
      const victoryAchieved = !enemiesAlive && !battleInProgress;
      const canAct = game.awaitingInput && enemiesAlive && player.hp > 0;

      const row = document.createElement("div");
      row.className = "actions-row";

      const escapeWrapper = document.createElement("div");
      escapeWrapper.className = "action-button-wrapper";
      const escapeBtn = document.createElement("button");
      escapeBtn.textContent = "üèÉ „Å´„Åí„Çã";
      escapeBtn.disabled = !canAct;
      escapeBtn.onclick = attemptEscape;
      escapeWrapper.appendChild(escapeBtn);
      row.appendChild(escapeWrapper);

      (player.potions || []).forEach((potion, index) => {
        const potionRow = document.createElement("div");
        potionRow.className = "potion-row";

        const potionBtn = document.createElement("button");
        potionBtn.className = "potion-button";
        potionBtn.onclick = () => usePotion(index);
        const useCost = potion.useCost ?? 25;
        const maxFullness = potion.maxFullness ?? 100;
        potion.fullness = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
        const resourceFull = potion.type === "hp" ? player.hp >= player.maxHp : player.mp >= player.maxMp;
        const icon = document.createElement("div");
        icon.className = "potion-icon";
        icon.textContent = potion.icon || "üß™";

        const meta = document.createElement("div");
        meta.className = "potion-meta";
        const textWrap = document.createElement("div");
        textWrap.className = "potion-text";
        const shortLabel = document.createElement("div");
        shortLabel.className = "potion-short";
        shortLabel.textContent = potion.short || (potion.type === "hp" ? "HP" : "MP");
        const fill = document.createElement("div");
        fill.className = "potion-fill";
        fill.textContent = `${Math.round(potion.fullness)}%`;
        textWrap.appendChild(shortLabel);
        textWrap.appendChild(fill);

        const infoBtn = document.createElement("div");
        infoBtn.className = "potion-info-button";
        infoBtn.textContent = "i";
        infoBtn.title = "„Éù„Éº„Ç∑„Éß„É≥Ë©≥Á¥∞";
        infoBtn.tabIndex = 0;
        infoBtn.setAttribute("role", "button");
        infoBtn.onclick = (event) => {
          event.stopPropagation();
          openPotionModal(potion);
        };
        infoBtn.onkeydown = (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            event.stopPropagation();
            openPotionModal(potion);
          }
        };

        meta.appendChild(textWrap);
        meta.appendChild(infoBtn);

        potionBtn.appendChild(icon);
        potionBtn.appendChild(meta);

        potionBtn.title = `${potion.short || potion.name} (${useCost}%Ê∂àË≤ª)`;
        potionBtn.disabled = !canAct || potion.fullness < useCost || resourceFull;
        potionRow.appendChild(potionBtn);
        row.appendChild(potionRow);
      });

      (player.activeSkillSlots || []).forEach((slot, index) => {
        const skill = slot.skillKey ? skills[slot.skillKey] : null;
        const wrapper = document.createElement("div");
        wrapper.className = "action-button-wrapper";

        const skillBtn = document.createElement("button");
        skillBtn.className = "skill-button";
        const remaining = Math.max(0, slot.cooldownRemaining || 0);
        const ready = remaining <= 0;
        const baseCooldown = skill ? getEffectiveSkillCooldown(skill) : null;
        const mpCost = skill?.activation?.mpCost ?? 0;
        skillBtn.disabled = skill ? (!canAct || !ready) : false;
        skillBtn.title = skill
          ? (skill.activation?.effect
            ? `${skill.activation.effect} / CT: ${skill.activation.cooldown || "--"}T / MP: ${mpCost}`
            : "„Çª„ÉÉ„Éà„Åó„Åü„Çπ„Ç≠„É´")
          : "„Çπ„Ç≠„É´Êú™„Çª„ÉÉ„Éà";
        skillBtn.onclick = () => {
          if (!skill) {
            openSkillsModal();
            return;
          }
          useActiveSkill(index);
        };

        const name = document.createElement("div");
        name.className = "skill-name";
        name.textContent = skill ? `${skill.name} (MP${mpCost})` : `„Çπ„Ç≠„É´${index + 1} Êú™„Çª„ÉÉ„Éà`;

        const textWrap = document.createElement("div");
        textWrap.className = "skill-text";
        textWrap.appendChild(name);

        const infoBtn = document.createElement("div");
        infoBtn.className = "potion-info-button";
        infoBtn.textContent = "i";
        infoBtn.title = "„Çπ„Ç≠„É´Ë©≥Á¥∞";
        infoBtn.tabIndex = 0;
        infoBtn.setAttribute("role", "button");
        infoBtn.onclick = (event) => {
          event.stopPropagation();
          if (skill) {
            openSkillInfoModal(skill);
          } else {
            openSkillsModal();
          }
        };
        infoBtn.onkeydown = (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            event.stopPropagation();
            if (skill) {
              openSkillInfoModal(skill);
            } else {
              openSkillsModal();
            }
          }
        };

        skillBtn.appendChild(textWrap);
        skillBtn.appendChild(infoBtn);

        const badge = document.createElement("div");
        badge.className = "cooldown-badge";
        badge.textContent = skill ? (ready ? `CT ${baseCooldown || "--"}T` : `ÊÆã„Çä ${remaining}T`) : "Êú™„Çª„ÉÉ„Éà";

        wrapper.appendChild(skillBtn);
        wrapper.appendChild(badge);
        row.appendChild(wrapper);
      });

      const wrapper = document.createElement("div");
      wrapper.className = "action-button-wrapper";
      const btn = document.createElement("button");
      const playerAttacks = Math.max(0, player.attacksRemaining ?? player.attackCount ?? 0);

      if (player.hp <= 0) {
        btn.textContent = "Êà¶Èóò‰∏çËÉΩ";
        btn.disabled = true;
      } else if (!enemiesAlive) {
        btn.textContent = "Ê¨°„ÅÆÈöéÂ±§„Å∏";
        btn.onclick = nextFloor;
      } else {
        btn.textContent = "‚öîÔ∏è „Åì„ÅÜ„Åí„Åç";
        btn.disabled = !canAct;
        btn.onclick = playerAttack;
      }
      wrapper.appendChild(btn);
      if (player.hp > 0 && enemiesAlive) {
        const attackBadge = document.createElement("div");
        attackBadge.className = "attack-badge";
        attackBadge.textContent = `x${playerAttacks}`;
        attackBadge.title = "1„Çø„Éº„É≥„ÅÇ„Åü„Çä„ÅÆÊîªÊíÉÂõûÊï∞";
        wrapper.appendChild(attackBadge);
      }
      row.appendChild(wrapper);
      container.appendChild(row);
    }

    function renderSecondaryStats(derived) {
      const container = document.getElementById("secondary-stats");
      container.innerHTML = "";
      const rows = [
        { label: "Áâ©ÁêÜÊîªÊíÉÂäõ", value: derived.physAtk.total },
        { label: "È≠îÊ≥ïÊîªÊíÉÂäõ", value: derived.magAtk.total },
        { label: "Áâ©ÁêÜË≤´ÈÄö", value: derived.physPen.total, unit: "%" },
        { label: "È≠îÊ≥ïË≤´ÈÄö", value: derived.magPen.total, unit: "%" },
        { label: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá", value: derived.critRate.total, unit: "%" },
        { label: "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„ÉÄ„É°„Éº„Ç∏", value: derived.critDamage.total, unit: "%" },
        { label: "ÂëΩ‰∏≠Áéá", value: derived.accuracy.total, unit: "%" },
        { label: "ÂõûÈÅøÁéá", value: derived.evade.total, unit: "%" },
        { label: "ÊúÄÂ§ßHP", value: derived.maxHp.total },
        { label: "ÊúÄÂ§ßMP", value: derived.maxMp.total },
        { label: "Áâ©ÁêÜÈò≤Âæ°Âäõ", value: derived.physDef.total },
        { label: "È≠îÊ≥ïÈò≤Âæ°Âäõ", value: derived.magDef.total },
        { label: "Ë¢´„ÉÄ„É°„Éº„Ç∏ËªΩÊ∏õ", value: derived.damageReduction.total, unit: "%" },
        { label: "„Éñ„É≠„ÉÉ„ÇØÁéá", value: derived.block.total, unit: "%" },
        { label: "Ë°åÂãïÈÄüÂ∫¶", value: derived.speed.total },
        { label: "„ÇØ„Éº„É´„Çø„Ç§„É†Áü≠Á∏Æ", value: derived.cooldown.total, unit: "%" },
        { label: "Ë°åÂãïÈòªÂÆ≥ÊäµÊäó", value: derived.controlResist.total, unit: "%" },
        { label: "DoTÊäµÊäó", value: derived.dotResist.total, unit: "%" },
        { label: "Âº±‰ΩìÂåñÊäµÊäó", value: derived.debuffResist.total, unit: "%" },
        { label: "HPÂÜçÁîü", value: derived.hpRegen.total },
        { label: "HPÂê∏Âèé", value: derived.lifeSteal.total, unit: "%" },
        { label: "„Éê„É™„Ç¢", value: derived.barrier.total },
        { label: "„Éâ„É≠„ÉÉ„ÉóÁéáUP", value: derived.dropRate.total, unit: "%" },
        { label: "„É¨„Ç¢„É™„ÉÜ„Ç£UP", value: derived.rarity.total, unit: "%" },
        { label: "„Éç„Éº„É†„ÉâÈÅ≠ÈÅáÁéá", value: derived.namedRate.total, unit: "%" },
        { label: "Áß∞Âè∑‰ªò‰∏éÁéáUP", value: derived.titleChance.total, unit: "%" },
        { label: "„Ç¥„Éº„É´„ÉâÁ¢∫Áéá", value: derived.goldChance.total, unit: "%" },
      ];

      rows.forEach((row) => {
        const el = document.createElement("div");
        el.className = "stat-row";
        const left = document.createElement("div");
        left.className = "stat-label secondary";
        left.innerHTML = `<span>${row.label}</span>`;
        const right = document.createElement("div");
        right.className = "stat-value";
        const rendered = formatStatValue(row.value, row.unit || "");
        right.innerHTML = rendered;
        el.appendChild(left);
        el.appendChild(right);
        container.appendChild(el);
      });
    }

    function adjustPrimary(key, delta) {
      if (delta === 0) return;
      if (delta > 0) {
        const use = Math.min(delta, player.statPoints);
        if (use <= 0) return;
        player.statPoints -= use;
        player.primary[key].base += use;
        player.allocations[key] += use;
        log(`ËÉΩÂäõP„Çí‰ΩøÁî®: ${player.primary[key].label} +${use}`, "good");
      } else {
        const refundable = player.allocations[key];
        const giveBack = Math.min(refundable, Math.abs(delta));
        if (giveBack <= 0) return;
        player.primary[key].base -= giveBack;
        player.allocations[key] -= giveBack;
        player.statPoints += giveBack;
        log(`ËÉΩÂäõP„ÇíËøîÂç¥: ${player.primary[key].label} -${giveBack}`, "info");
      }
      updateUI();
      maybeAutoSave("„Çπ„ÉÜ„Éº„Çø„ÇπË™øÊï¥");
    }

    function getAdjustStep() {
      return stepOptions[currentStepIndex];
    }

    function updateStepButton() {
      if (!statStepButton) return;
      const step = getAdjustStep();
      statStepButton.textContent = `¬±${step}`;
      statStepButton.title = `Â¢óÊ∏õÂπÖ ${step}`;
    }

    function getSkillAdjustStep() {
      return skillStepOptions[currentSkillStepIndex];
    }

    function updateSkillStepButton() {
      if (!skillStepButton) return;
      const step = getSkillAdjustStep();
      skillStepButton.textContent = `¬±${step}`;
      skillStepButton.title = `„Çπ„Ç≠„É´Â¢óÊ∏õÂπÖ ${step}`;
    }

    function renderPrimaryStats() {
      const container = document.getElementById("primary-stats");
      container.innerHTML = "";
      const step = getAdjustStep();

      primaryOrder.forEach((key) => {
        const stat = player.primary[key];
        const row = document.createElement("div");
        row.className = "stat-row primary-row";

        const info = document.createElement("div");
        info.className = "primary-info";

        const label = document.createElement("div");
        label.className = "stat-label inline";
        label.textContent = stat.label;

        const value = document.createElement("div");
        value.className = "stat-value";
        value.innerHTML = formatPrimaryValue(stat);

        info.appendChild(label);
        info.appendChild(value);

        const actions = document.createElement("div");
        actions.className = "primary-actions";

        const inc = document.createElement("button");
        inc.textContent = `+${step}`;
        inc.classList.add("mini-btn");
        inc.disabled = player.statPoints <= 0;
        inc.title = `${step}„Éù„Ç§„É≥„ÉàÂ¢óÂä†`;
        inc.onclick = () => adjustPrimary(key, step);

        const dec = document.createElement("button");
        dec.textContent = `-${step}`;
        dec.classList.add("mini-btn");
        dec.disabled = player.allocations[key] <= 0;
        dec.title = `${step}„Éù„Ç§„É≥„ÉàÊ∏õÂ∞ë`;
        dec.onclick = () => adjustPrimary(key, -step);

        actions.appendChild(inc);
        actions.appendChild(dec);

        row.appendChild(info);
        row.appendChild(actions);
        container.appendChild(row);
      });
    }

    function getActiveSkillSlotIndex(skillKey) {
      return player.activeSkillSlots.findIndex((slot) => slot.skillKey === skillKey);
    }

    function isSkillUnlocked(skill) {
      if (!skill) return false;
      const required = skill.unlockLevel || 1;
      return player.level >= required;
    }

    function toggleActiveSkillSlot(skillKey) {
      const skill = skills[skillKey];
      if (!skill || skill.type !== "active") return;
      if (skill.level <= 0) {
        log("„Çπ„Ç≠„É´„ÇíÁøíÂæó„Åó„Å¶„Åã„Çâ„Çª„ÉÉ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "warning");
        return;
      }
      const assignedIndex = getActiveSkillSlotIndex(skillKey);
      if (assignedIndex >= 0) {
        player.activeSkillSlots[assignedIndex] = { skillKey: null, cooldownRemaining: 0 };
        log(`üóë ${skill.name}„Çí„Çπ„É≠„ÉÉ„Éà${assignedIndex + 1}„Åã„ÇâËß£Èô§`, "info");
        renderActiveSkillLoadout();
        renderActions();
        return;
      }
      const emptyIndex = player.activeSkillSlots.findIndex((slot) => !slot.skillKey);
      if (emptyIndex === -1) {
        log(`„Çª„ÉÉ„ÉàÊû†„ÅåÁ©∫„ÅÑ„Å¶„ÅÑ„Åæ„Åõ„Çì (ÊúÄÂ§ß${ACTIVE_SKILL_SLOT_LIMIT}Êû†)`, "warning");
        return;
      }
      player.activeSkillSlots[emptyIndex] = { skillKey, cooldownRemaining: 0 };
      log(`‚ú® ${skill.name}„Çí„Çπ„É≠„ÉÉ„Éà${emptyIndex + 1}„Å´„Çª„ÉÉ„Éà`, "good");
      renderActiveSkillLoadout();
      renderActions();
    }

    function getEffectiveSkillCooldown(skill) {
      const derived = lastDerivedStats || recalcDerivedStats();
      const baseCooldown = Math.max(0, skill?.activation?.cooldown ?? 0);
      if (baseCooldown <= 0) return 0;
      const reduction = Math.max(0, derived?.cooldown?.total ?? 0);
      const scaled = Math.round(baseCooldown * (1 - reduction / 100));
      return Math.max(1, scaled);
    }

    function renderSkillThresholds(skill, { locked = false } = {}) {
      const wrapper = document.createElement("div");
      wrapper.className = "help-panel";
      const label = document.createElement("div");
      label.className = "option-label";
      label.textContent = "ÈñæÂÄ§ÂäπÊûú (10 / 30 / 50)";
      wrapper.appendChild(label);

      if (locked) {
        const row = document.createElement("div");
        row.className = "option-value";
        row.textContent = "ÔºüÔºüÔºü";
        wrapper.appendChild(row);
      } else {
        (skill.thresholds || []).forEach((threshold) => {
          const row = document.createElement("div");
          row.className = "option-value";
          const reached = (skill.reachedThresholds || []).some((t) => t.level === threshold.level);
          const detail = threshold.effect || formatSkillBonusText(threshold.bonus);
          row.textContent = `${threshold.level}Lv: ${detail || "ÂäπÊûúÊú™Ë®≠ÂÆö"}${reached ? " (ÈÅîÊàê)" : ""}`;
          if (reached) row.style.color = "#34d399";
          wrapper.appendChild(row);
        });
      }

      return wrapper;
    }

    function describeSkillScaling(skill, { locked = false } = {}) {
      if (locked) return "ÊØéLv: ÔºüÔºüÔºü";
      if (!skill.scaling?.perLevel) return "ÊØéLvÂäπÊûú„Å™„Åó";
      const text = formatSkillBonusText(skill.scaling.perLevel);
      return text ? `ÊØéLv: ${text}` : "ÊØéLvÂäπÊûú„Å™„Åó";
    }

    function adjustSkillLevel(key, delta) {
      const skill = skills[key];
      if (!skill || delta === 0) return;
      if (delta > 0) {
        if (!isSkillUnlocked(skill)) {
          log(`Lv${skill.unlockLevel}„ÅßËß£Êîæ„Åï„Çå„Åæ„Åô`, "warning");
          return;
        }
        const spendable = Math.min(delta, player.skillPoints, skill.max - skill.level);
        if (spendable <= 0) return;
        player.skillPoints -= spendable;
        skill.level += spendable;
        log(`„Çπ„Ç≠„É´„Äé${skill.name}„Äè„ÇíÂº∑Âåñ (+${spendable}) (${skill.level}/${skill.max})`, "good");
      } else {
        const refundable = Math.min(skill.level, Math.abs(delta));
        if (refundable <= 0) return;
        skill.level -= refundable;
        player.skillPoints += refundable;
        log(`„Çπ„Ç≠„É´„Äé${skill.name}„Äè„ÇíÊ∏õÂ∞ë (-${refundable}) (${skill.level}/${skill.max})`, "info");
      }
      calculateSkillBonuses();
      const derived = recalcDerivedStats();
      updateUI(derived);
      maybeAutoSave(delta > 0 ? "„Çπ„Ç≠„É´„É¨„Éô„É´„Ç¢„ÉÉ„Éó" : "„Çπ„Ç≠„É´Ë™øÊï¥");
    }

    function renderActiveSkillLoadout() {
      const container = document.getElementById("active-skill-loadout");
      if (!container) return;
      container.innerHTML = "";

      const title = document.createElement("div");
      title.className = "option-label";
      title.textContent = `„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çπ„Ç≠„É´Êû† (${ACTIVE_SKILL_SLOT_LIMIT}Êû†„Åæ„Åß„Çª„ÉÉ„ÉàÂèØ)`;
      container.appendChild(title);

      player.activeSkillSlots.forEach((slot, index) => {
        const skill = slot.skillKey ? skills[slot.skillKey] : null;
        const row = document.createElement("div");
        row.className = "option-value";
        const cooldownText = skill?.activation?.cooldown ? ` / CT: ${skill.activation.cooldown}T` : "";
        const remaining = slot.cooldownRemaining ? ` / ÊÆã„Çä: ${slot.cooldownRemaining}T` : "";
        row.textContent = `„Çπ„É≠„ÉÉ„Éà${index + 1}: ${skill ? skill.name : "Êú™„Çª„ÉÉ„Éà"}${skill ? `${cooldownText}${remaining}` : ""}`;
        if (skill?.activation?.effect) {
          const detail = document.createElement("div");
          detail.className = "subtle";
          detail.textContent = `ÂäπÊûú: ${skill.activation.effect}`;
          row.appendChild(detail);
        }
        container.appendChild(row);
      });
    }

    function renderSkillCategoryTabs() {
      const container = document.getElementById("skill-category-tabs");
      if (!container) return;
      container.innerHTML = "";
      SKILL_CATEGORIES.forEach((category) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "tab-button";
        const isActive = category === selectedSkillCategory;
        if (isActive) btn.classList.add("active");
        btn.textContent = category;
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
        btn.onclick = () => {
          selectedSkillCategory = category;
          renderSkills();
        };
        container.appendChild(btn);
      });
    }

    function renderSkillTypeTabs() {
      const container = document.getElementById("skill-type-tabs");
      if (!container) return;
      container.innerHTML = "";
      [
        { key: "active", label: "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ" },
        { key: "passive", label: "„Éë„ÉÉ„Ç∑„Éñ" },
      ].forEach((type) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "tab-button";
        const isActive = type.key === selectedSkillType;
        if (isActive) btn.classList.add("active");
        btn.textContent = type.label;
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
        btn.onclick = () => {
          selectedSkillType = type.key;
          renderSkills();
        };
        container.appendChild(btn);
      });
    }

    function renderSkillDetailList() {
      const container = document.getElementById("skills");
      if (!container) return;
      container.innerHTML = "";
      const step = getSkillAdjustStep();

      const section = document.createElement("div");
      const header = document.createElement("div");
      header.className = "section-title";
      const typeLabel = selectedSkillType === "active" ? "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ" : "„Éë„ÉÉ„Ç∑„Éñ";
      header.textContent = `${selectedSkillCategory} / ${typeLabel}`;
      section.appendChild(header);

      const filteredSkills = Object.entries(skills)
        .filter(([, skill]) => skill.category === selectedSkillCategory && skill.type === selectedSkillType)
        .sort((a, b) => (a[1].unlockLevel || 0) - (b[1].unlockLevel || 0));

      filteredSkills.forEach(([key, skill]) => {
        const locked = !isSkillUnlocked(skill);
        const row = document.createElement("div");
        row.className = "card";
        row.style.marginBottom = "6px";

        const headerRow = document.createElement("div");
        headerRow.className = "inline-buttons";
        headerRow.style.justifyContent = "space-between";

        const name = document.createElement("div");
        name.className = "stat-label inline";
        name.textContent = `${locked ? "ÔºüÔºüÔºü" : skill.name} (${skill.level}/${skill.max})`;

        const meta = document.createElement("div");
        meta.className = "pill";
        const unlock = skill.unlockLevel ? `Lv${skill.unlockLevel}` : "Lv1";
        meta.textContent = `${skill.category} / ${skill.type === "active" ? "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ" : "„Éë„ÉÉ„Ç∑„Éñ"} / ÂèñÂæó${unlock}`;

        headerRow.appendChild(name);
        headerRow.appendChild(meta);
        row.appendChild(headerRow);

        const desc = document.createElement("div");
        desc.className = "subtle";
        desc.textContent = locked ? "ÔºüÔºüÔºü" : skill.desc;
        row.appendChild(desc);

        const scaling = document.createElement("div");
        scaling.className = "subtle";
        scaling.textContent = describeSkillScaling(skill, { locked });
        row.appendChild(scaling);

        const currentBonus = document.createElement("div");
        currentBonus.className = "subtle";
        currentBonus.textContent = describeSkillBonusAtLevel(skill, skill.level, { locked });
        row.appendChild(currentBonus);

        const nextBonus = document.createElement("div");
        nextBonus.className = "subtle";
        nextBonus.textContent = describeSkillNextBonus(skill, { locked });
        row.appendChild(nextBonus);

        if (skill.type === "active") {
          const activation = document.createElement("div");
          activation.className = "subtle";
          const cooldownText = skill.activation?.cooldown ? `${skill.activation.cooldown}T` : "--";
          const mpCostText = skill.activation?.mpCost != null ? `MP${skill.activation.mpCost}` : "MP--";
          const activationDetail = locked
            ? "Áô∫Âãï: ÔºüÔºüÔºü"
            : `CT: ${cooldownText} / Ê∂àË≤ª: ${mpCostText} / ÂäπÊûú: ${skill.activation?.effect || "Êú™Ë®≠ÂÆö"}`;
          activation.textContent = activationDetail;
          row.appendChild(activation);

          const slotButton = document.createElement("button");
          slotButton.className = "mini-btn";
          const assignedIndex = getActiveSkillSlotIndex(key);
          slotButton.textContent = assignedIndex >= 0 ? `„Çπ„É≠„ÉÉ„Éà${assignedIndex + 1}Ëß£Èô§` : "„Çπ„É≠„ÉÉ„Éà„Å´„Çª„ÉÉ„Éà";
          slotButton.disabled = locked || skill.level <= 0;
          slotButton.onclick = () => {
            toggleActiveSkillSlot(key);
            renderSkills();
          };
          row.appendChild(slotButton);
        }

        row.appendChild(renderSkillThresholds(skill, { locked }));

        const controls = document.createElement("div");
        controls.className = "inline-buttons";
        controls.style.marginTop = "6px";

        const downBtn = document.createElement("button");
        downBtn.className = "mini-btn";
        downBtn.textContent = `-${step}`;
        downBtn.disabled = skill.level <= 0;
        downBtn.onclick = () => adjustSkillLevel(key, -step);

        const upBtn = document.createElement("button");
        upBtn.className = "mini-btn";
        upBtn.textContent = `+${step}`;
        upBtn.disabled = player.skillPoints <= 0 || skill.level >= skill.max || locked;
        upBtn.onclick = () => adjustSkillLevel(key, step);

        controls.appendChild(downBtn);
        controls.appendChild(upBtn);
        row.appendChild(controls);

        section.appendChild(row);
      });

      if (!filteredSkills.length) {
        const empty = document.createElement("div");
        empty.className = "option-value";
        empty.textContent = "„Çπ„Ç≠„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì";
        section.appendChild(empty);
      }

      container.appendChild(section);
    }

    function renderSkillSummary() {
      const container = document.getElementById("skills-summary");
      if (!container) return;
      container.innerHTML = "";

      SKILL_CATEGORIES.forEach((category) => {
        const card = document.createElement("div");
        card.className = "card";
        card.style.marginBottom = "6px";

        const header = document.createElement("div");
        header.className = "section-title";
        header.textContent = `${category}„Çπ„Ç≠„É´‰∏ÄË¶ß`;
        card.appendChild(header);

        const list = document.createElement("div");
        list.className = "help-panel";
        list.style.marginTop = "6px";

        const categorySkills = Object.values(skills)
          .filter((skill) => skill.category === category)
          .sort((a, b) => (a.unlockLevel || 0) - (b.unlockLevel || 0));

        categorySkills.forEach((skill) => {
          const locked = !isSkillUnlocked(skill);
          const row = document.createElement("div");
          row.className = "option-value";
          const typeLabel = skill.type === "active" ? "Act" : "Pas";
          const unlock = skill.unlockLevel ? `ÂèñÂæóLv${skill.unlockLevel}` : "ÂèñÂæóLv1";
          const status = locked ? "Êú™Ëß£Êîæ" : `ÁèæÂú®${skill.level}/${skill.max}`;
          const name = locked ? "ÔºüÔºüÔºü" : skill.name;
          row.textContent = `„Éª${name} (${typeLabel}) / ${unlock} / ${status}`;
          list.appendChild(row);
        });

        card.appendChild(list);
        container.appendChild(card);
      });
    }

    function updateSkillSummaryVisibility() {
      if (skillSummaryModal) {
        skillSummaryModal.classList.toggle("hidden", !skillSummaryVisible);
      }
      if (skillSummaryToggleButton) {
        skillSummaryToggleButton.textContent = skillSummaryVisible ? "ÂÖ®ËÅ∑Ê•≠‰∏ÄË¶ß„ÇíÈñâ„Åò„Çã" : "ÂÖ®ËÅ∑Ê•≠‰∏ÄË¶ß„ÇíË°®Á§∫";
        skillSummaryToggleButton.setAttribute("aria-pressed", skillSummaryVisible ? "true" : "false");
      }
    }

    function renderSkills() {
      updateSkillStepButton();
      renderSkillCategoryTabs();
      renderSkillTypeTabs();
      renderActiveSkillLoadout();
      renderSkillDetailList();
      renderSkillSummary();
      updateSkillSummaryVisibility();
    }

    function isItemEquipped(item) {
      if (!item) return false;
      if (item.type === "potion" && item.potion?.id) {
        return (player.potions || []).some((p) => p?.id === item.potion.id);
      }
      if (item.type === "equipment" && item.id) {
        return Object.values(player.equipment || {}).some((eq) => eq?.id === item.id);
      }
      return false;
    }

    function toggleInventorySortMode() {
      inventorySortMode = inventorySortMode === "acquire" ? "rarity" : "acquire";
    }

    function renderInventoryFilters() {
      const container = document.getElementById("inventory-filters");
      if (!container) return;
      const sortLabel = INVENTORY_SORT_LABEL[inventorySortMode] || INVENTORY_SORT_LABEL.acquire;
      container.innerHTML = "";

      INVENTORY_FILTER_OPTIONS.forEach((option) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "inventory-filter-button";
        const isSortButton = option.key === "sort";
        const isActive = !isSortButton && option.key === inventoryFilter;
        if (isActive) {
          btn.classList.add("active");
        }
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
        btn.textContent = isSortButton ? `${option.label}: ${sortLabel}` : option.label;
        btn.onclick = () => {
          if (isSortButton) {
            toggleInventorySortMode();
            renderInventoryFilters();
          } else {
            inventoryFilter = option.key;
            renderInventoryFilters();
          }
          renderInventory();
        };
        container.appendChild(btn);
      });
    }

    function renderInventory() {
      const container = document.getElementById("inventory-list");
      container.innerHTML = "";
      const items = player.inventory?.items || [];
      items.forEach((item) => ensureAcquiredOrder(item));

      const entries = items.map((item, index) => ({ item, index }));
      const filtered = (() => {
        if (inventoryFilter === "all") return entries;
        if (inventoryFilter === "items") return entries.filter((entry) => isItemInventory(entry));
        return entries.filter(({ item }) => getInventorySlotKey(item) === inventoryFilter);
      })();

      const sorted = [...filtered].sort((a, b) => {
        if (inventorySortMode === "rarity") {
          const rarityA = typeof a.item?.rarity === "number" ? a.item.rarity : 0;
          const rarityB = typeof b.item?.rarity === "number" ? b.item.rarity : 0;
          if (rarityA !== rarityB) return rarityB - rarityA;
        }
        const orderA = getAcquiredOrder(a.item, a.index);
        const orderB = getAcquiredOrder(b.item, b.index);
        return orderA - orderB;
      });

      if (sorted.length === 0) {
        const empty = document.createElement("div");
        empty.className = "help-panel";
        empty.textContent = "Ë©≤ÂΩì„Åô„Çã„Ç¢„Ç§„ÉÜ„É†„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ";
        container.appendChild(empty);
        return;
      }

      sorted.forEach(({ item, index }) => {
        const row = document.createElement("button");
        row.type = "button";
        row.className = "inventory-row";
        row.onclick = () => openInventoryItemModal(item, index);

        const name = document.createElement("div");
        name.className = "name";
        if (isItemEquipped(item)) {
          const badge = document.createElement("span");
          badge.className = "equip-badge";
          badge.textContent = "[E]";
          name.appendChild(badge);
        }
        if (item.favorite) {
          const fav = document.createElement("span");
          fav.className = "favorite-badge";
          fav.textContent = "‚òÖ";
          name.appendChild(fav);
        }
        const label = document.createElement("span");
        label.textContent = item?.name || "‰∏çÊòé„Å™„Ç¢„Ç§„ÉÜ„É†";
        applyItemRarityColor(label, item);
        name.appendChild(label);

        row.appendChild(name);
        container.appendChild(row);
      });
    }

    function equipPotionFromInventory(inventoryIndex, slotIndex) {
      const items = player.inventory?.items || [];
      if (!items[inventoryIndex]) return;
      const entry = items[inventoryIndex];
      if (entry.type !== "potion" || !entry.potion) return;
      if (!player.potions?.length || !player.potions[slotIndex]) return;

      const newPotion = { ...entry.potion };
      const previous = player.potions[slotIndex];
      player.potions[slotIndex] = newPotion;
      items.splice(inventoryIndex, 1);

      if (previous) {
        items.push(
          ensureAcquiredOrder(
            createPotionInventoryItem(previous, { description: "„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÂ§ñ„Åó„Åü„Éù„Éº„Ç∑„Éß„É≥" })
          )
        );
      }

      log(`üíß ${newPotion.name} „Çí„Çπ„É≠„ÉÉ„Éà${slotIndex + 1}„Å´Ë£ÖÂÇô„Åó„Åü`, "info");
      updateUI();
      renderInventory();
    }

    function sellInventoryItem(index, item, priceOverride) {
      const items = player.inventory?.items || [];
      if (!items[index]) return;
      if (isItemEquipped(item)) {
        log("Ë£ÖÂÇô‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅØÂ£≤Âç¥„Åß„Åç„Åæ„Åõ„Çì", "warning");
        return;
      }
      if (item.favorite) {
        log("„ÅäÊ∞ó„Å´ÂÖ•„ÇäÁôªÈå≤‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅØÂ£≤Âç¥„Åß„Åç„Åæ„Åõ„Çì", "warning");
        return;
      }
      const sellPrice = priceOverride ?? calculateItemSellValue(item);
      if (!sellPrice || sellPrice <= 0) {
        log("„Åì„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅØÂ£≤Âç¥„Åß„Åç„Åæ„Åõ„Çì", "warning");
        return;
      }
      items.splice(index, 1);
      grantGold(sellPrice, { source: "Â£≤Âç¥" });
      closeInventoryItemModal();
      renderInventory();
      updateUI();
    }

    const enemyModal = document.getElementById("enemy-modal");
    const potionModal = document.getElementById("potion-modal");
    const skillInfoModal = document.getElementById("skill-info-modal");
    const playerModal = document.getElementById("player-modal");
    const skillsModal = document.getElementById("skills-modal");
    const inventoryModal = document.getElementById("inventory-modal");
    const inventoryItemModal = document.getElementById("inventory-item-modal");
    const closeModalButton = document.getElementById("modal-close");
    const potionModalCloseButton = document.getElementById("potion-close");
    const skillInfoCloseButton = document.getElementById("skill-info-close");
    const playerModalCloseButton = document.getElementById("player-close");
    const skillsModalCloseButton = document.getElementById("skills-close");
    const inventoryModalCloseButton = document.getElementById("inventory-close");
    const inventoryItemCloseButton = document.getElementById("inventory-item-close");
    const statHelpButton = document.getElementById("stat-help");
    const potionModalName = document.getElementById("potion-modal-name");
    const inventoryCompareResult = document.getElementById("inventory-compare-result");
    const potionModalType = document.getElementById("potion-modal-type");
    const potionModalEffect = document.getElementById("potion-modal-effect");
    const potionModalCost = document.getElementById("potion-modal-cost");
    const potionModalFill = document.getElementById("potion-modal-fill");
    const skillInfoName = document.getElementById("skill-info-name");
    const skillInfoType = document.getElementById("skill-info-type");
    const skillInfoCooldown = document.getElementById("skill-info-cooldown");
    const skillInfoLevel = document.getElementById("skill-info-level");
    const skillInfoEffect = document.getElementById("skill-info-effect");
    const skillInfoNote = document.getElementById("skill-info-note");
    const inventoryItemName = document.getElementById("inventory-item-name");
    const inventoryItemDesc = document.getElementById("inventory-item-desc");
    const inventoryItemMeta = document.getElementById("inventory-item-meta");
    const inventoryItemDetail = document.getElementById("inventory-item-detail");
    const inventoryItemActions = document.getElementById("inventory-item-actions");
    const memoModal = document.getElementById("memo-modal");
    const memoCloseButton = document.getElementById("memo-close");
    const resetModal = document.getElementById("reset-modal");
    const resetCloseButton = document.getElementById("reset-close");
    const resetCancelButton = document.getElementById("reset-cancel");
    const resetConfirmButton = document.getElementById("reset-confirm");
    const resetSpentLabel = document.getElementById("reset-spent");
    const resetButton = document.getElementById("reset-stats");
    const statStepButton = document.getElementById("stat-step");
    const skillStepButton = document.getElementById("skill-step");
    const skillSummaryToggleButton = document.getElementById("skill-summary-toggle");
    const skillDetailView = document.getElementById("skill-detail-view");
    const skillSummaryModal = document.getElementById("skill-summary-modal");
    const skillSummaryCloseButton = document.getElementById("skill-summary-close");
    const resetSkillsButton = document.getElementById("reset-skills");
    const skillResetModal = document.getElementById("skill-reset-modal");
    const skillResetCloseButton = document.getElementById("skill-reset-close");
    const skillResetCancelButton = document.getElementById("skill-reset-cancel");
    const skillResetConfirmButton = document.getElementById("skill-reset-confirm");
    const skillResetSpentLabel = document.getElementById("skill-reset-spent");
    const debugModal = document.getElementById("debug-modal");
    const debugOpenButton = document.getElementById("btn-debug");
    const debugCloseButton = document.getElementById("debug-close");
    const debugTargetSelect = document.getElementById("debug-target");
    const debugEnemySelect = document.getElementById("debug-enemy");
    const debugClearButton = document.getElementById("debug-clear-status");
    const debugTabButtons = document.querySelectorAll(".debug-tab-button");
    const debugTabStatus = document.getElementById("debug-tab-status");
    const debugTabEquipment = document.getElementById("debug-tab-equipment");
    const debugTabAdjust = document.getElementById("debug-tab-adjust");
    const debugTabSave = document.getElementById("debug-tab-save");
    const saveSlotList = document.getElementById("save-slot-list");
    const debugGearSlotSelect = document.getElementById("debug-gear-slot");
    const debugGearRaritySelect = document.getElementById("debug-gear-rarity");
    const debugLegendaryWrapper = document.getElementById("debug-legendary-wrapper");
    const debugLegendarySelect = document.getElementById("debug-legendary-template");
    const debugGearPreview = document.getElementById("debug-gear-preview");
    const debugGenerateGearButton = document.getElementById("debug-generate-gear");
    const debugGenerateGearRandomButton = document.getElementById("debug-generate-gear-random");
    const debugLevelInput = document.getElementById("debug-level-input");
    const debugHpInput = document.getElementById("debug-hp-input");
    const debugFloorInput = document.getElementById("debug-floor-input");
    const debugApplyLevelButton = document.getElementById("debug-apply-level");
    const debugApplyHpButton = document.getElementById("debug-apply-hp");
    const debugApplyFloorButton = document.getElementById("debug-apply-floor");
    const debugNewRunButton = document.getElementById("debug-new-run");
    const inventoryOpenButton = document.getElementById("btn-inventory");
    const archetypeModal = document.getElementById("archetype-modal");
    const archetypeModalName = document.getElementById("archetype-modal-name");
    const archetypeModalDesc = document.getElementById("archetype-modal-desc");
    const archetypeModalAbilities = document.getElementById("archetype-modal-abilities");
    const archetypeCloseButton = document.getElementById("archetype-close");

    function openEnemyModal(enemy) {
      document.getElementById("modal-name").textContent = enemy.name;
      document.getElementById("modal-hp").textContent = `${Math.ceil(enemy.hp)} / ${enemy.maxHp}`;
      document.getElementById("modal-atk").textContent = Math.ceil(enemy.atk);
      document.getElementById("modal-def").textContent = Math.ceil(enemy.def);
      document.getElementById("modal-spd").textContent = enemy.spd.toFixed(1);
      const tag = document.getElementById("modal-tag");
      if (enemy.isBoss) {
        tag.textContent = "BOSS";
        tag.style.display = "inline-flex";
      } else if (enemy.archetypeLabel) {
        tag.textContent = enemy.archetypeLabel;
        tag.style.display = "inline-flex";
      } else {
        tag.style.display = "none";
      }
      enemyModal.classList.remove("hidden");
    }

    function closeEnemyModal() {
      enemyModal.classList.add("hidden");
    }

    function openArchetypeModal(enemy) {
      if (!enemy?.archetypeLabel) return;
      archetypeModalName.textContent = enemy.archetypeLabel;
      const variant = ENEMY_VARIANTS.find((v) => v.key === enemy.variant);
      archetypeModalDesc.textContent = variant?.description || enemy.flavor || "ÁâπÂæ¥‰∏çÊòé";
      archetypeModalAbilities.innerHTML = "";
      const baseModifierText = describeModifiers(enemy.archetypeBaseModifiers || variant?.baseModifiers);
      const baseRow = document.createElement("div");
      baseRow.className = "option-value";
      baseRow.textContent = baseModifierText ? `Âü∫Á§éË£úÊ≠£: ${baseModifierText}` : "Âü∫Á§éË£úÊ≠£: „Å™„Åó";
      archetypeModalAbilities.appendChild(baseRow);

      const abilityList = enemy.archetypeAbilities?.length
        ? enemy.archetypeAbilities
        : (variant?.abilities || [])
            .filter(Boolean)
            .slice(0, enemy.archetypeRank || 1);

      if (!abilityList.length) {
        const none = document.createElement("div");
        none.className = "option-value";
        none.textContent = "ËøΩÂä†ËÉΩÂäõ„Å™„Åó";
        archetypeModalAbilities.appendChild(none);
      } else {
        abilityList.forEach((ability) => {
          const row = document.createElement("div");
          row.className = "option-value";
          const detail = describeModifiers(ability.modifiers);
          row.textContent = detail ? `„Éª${ability.label}: ${detail}` : `„Éª${ability.label}`;
          archetypeModalAbilities.appendChild(row);
        });
      }

      archetypeModal?.classList.remove("hidden");
    }

    function closeArchetypeModal() {
      archetypeModal?.classList.add("hidden");
    }

    function openPotionModal(potion) {
      if (!potion) return;
      const useCost = potion.useCost ?? 25;
      const maxFullness = potion.maxFullness ?? 100;
      const currentFill = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
      potionModalName.textContent = potion.name;
      potionModalType.textContent = potion.type === "hp" ? "HPÂõûÂæ©" : "MPÂõûÂæ©";
      potionModalEffect.textContent = potion.type === "hp" ? `HP„Çí${potion.amount}ÂõûÂæ©` : `MP„Çí${potion.amount}ÂõûÂæ©`;
      potionModalCost.textContent = `1Âõû ${useCost}% Ê∂àË≤ª`;
      potionModalFill.textContent = `${Math.round(currentFill)}% / ${maxFullness}%`;
      potionModal.classList.remove("hidden");
    }

    function closePotionModal() {
      potionModal.classList.add("hidden");
    }

    function openSkillInfoModal(skill) {
      if (!skill) return;
      const baseCooldown = skill.activation?.cooldown ?? 0;
      const effectiveCooldown = baseCooldown > 0 ? getEffectiveSkillCooldown(skill) : 0;
      const cooldownText = baseCooldown
        ? `Âü∫Á§é ${baseCooldown}T / ÂÆüÂäπ ${effectiveCooldown}T`
        : "CT„Å™„Åó";
      const mpCost = skill.activation?.mpCost ?? 0;
      const mpCostText = mpCost > 0 ? `MP${mpCost}` : "MPÊ∂àË≤ª„Å™„Åó";
      const locked = !isSkillUnlocked(skill);
      skillInfoName.textContent = skill.name;
      skillInfoType.textContent = `${skill.type === "active" ? "„Ç¢„ÇØ„ÉÜ„Ç£„Éñ" : "„Éë„ÉÉ„Ç∑„Éñ"} (${skill.category || "ÂàÜÈ°û‰∏çÊòé"})`;
      skillInfoCooldown.textContent = `${cooldownText} / Ê∂àË≤ª: ${mpCostText}`;
      skillInfoLevel.textContent = `${skill.level || 0} / ${skill.max ?? "--"}`;
      skillInfoEffect.textContent = skill.activation?.effect || skill.desc || "ÂäπÊûúÊú™Ë®≠ÂÆö";
      const perLevelText = skill.scaling?.perLevel
        ? `ÊØéLv: ${formatSkillBonusText(skill.scaling.perLevel)}`
        : "ÊØéLvÂäπÊûú„Å™„Åó";
      const currentText = describeSkillBonusAtLevel(skill, skill.level, { locked, label: "ÁèæÂú®ÂêàË®à" });
      const nextText = describeSkillNextBonus(skill, { locked });
      skillInfoNote.innerHTML = `<div>${perLevelText}</div><div>${currentText}</div><div>${nextText}</div>`;
      skillInfoModal?.classList.remove("hidden");
    }

    function closeSkillInfoModal() {
      skillInfoModal?.classList.add("hidden");
    }

    function resetSkillBonuses() {
      calculateSkillBonuses();
      recalcDerivedStats();
    }

    function resetSkills() {
      const spent = Object.values(skills).reduce((sum, skill) => sum + skill.level, 0);
      if (spent === 0) {
        log("„É™„Çª„ÉÉ„Éà„Åô„Çã„Çπ„Ç≠„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", "info");
        return;
      }
      Object.values(skills).forEach((skill) => {
        skill.level = 0;
      });
      player.activeSkillSlots = Array.from({ length: ACTIVE_SKILL_SLOT_LIMIT }, () => ({ skillKey: null, cooldownRemaining: 0 }));
      resetSkillBonuses();
      player.skillPoints += spent;
      updateUI();
      renderActiveSkillLoadout();
      renderSkillSummary();
      log("„Çπ„Ç≠„É´„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü", "info");
      maybeAutoSave("„Çπ„Ç≠„É´„É™„Çª„ÉÉ„Éà");
    }

    function openPlayerModal() {
      updateUI();
      playerModal.classList.remove("hidden");
    }

    function closePlayerModal() {
      playerModal.classList.add("hidden");
    }

    function openSkillsModal() {
      updateUI();
      skillsModal.classList.remove("hidden");
    }

    function closeSkillsModal() {
      skillsModal.classList.add("hidden");
      skillSummaryVisible = false;
      updateSkillSummaryVisibility();
    }

    function openInventoryModal() {
      renderInventoryFilters();
      renderInventory();
      inventoryModal.classList.remove("hidden");
    }

    function closeInventoryModal() {
      closeInventoryItemModal();
      inventoryModal.classList.add("hidden");
    }

    function clearComparisonResult() {
      if (!inventoryCompareResult) return;
      inventoryCompareResult.innerHTML = "";
      inventoryCompareResult.style.display = "none";
    }

    function renderComparisonResult(slotKey, item) {
      if (!inventoryCompareResult || !item?.equipment) return;
      const slotName = PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotKey;
      const equipped = player.equipment?.[slotKey];
      const diffs = diffEquipmentBonuses(item, equipped).sort((a, b) => b.delta - a.delta);

      inventoryCompareResult.innerHTML = "";
      inventoryCompareResult.style.display = "block";

      const heading = document.createElement("div");
      heading.className = "option-label";
      heading.textContent = `${slotName}„Å®„ÅÆÊØîËºÉ`;
      inventoryCompareResult.appendChild(heading);

      const currentRow = document.createElement("div");
      currentRow.className = "subtle";
      const currentLabel = document.createElement("span");
      currentLabel.textContent = "ÁèæÂú®";
      const currentName = document.createElement("span");
      currentName.textContent = equipped?.name || "„Å™„Åó";
      applyItemRarityColor(currentName, equipped);
      currentRow.appendChild(currentLabel);
      currentRow.appendChild(currentName);
      inventoryCompareResult.appendChild(currentRow);

      const nextRow = document.createElement("div");
      nextRow.className = "subtle";
      const nextLabel = document.createElement("span");
      nextLabel.textContent = "ÂÄôË£ú";
      const nextName = document.createElement("span");
      nextName.textContent = item.name;
      applyItemRarityColor(nextName, item);
      nextRow.appendChild(nextLabel);
      nextRow.appendChild(nextName);
      inventoryCompareResult.appendChild(nextRow);

      if (!diffs.length) {
        const row = document.createElement("div");
        row.className = "option-value";
        row.textContent = "„Çπ„ÉÜ„Éº„Çø„ÇπÂ§âÂåñ„Å™„Åó";
        inventoryCompareResult.appendChild(row);
        return;
      }

      const list = document.createElement("div");
      list.className = "stat-diff-list";
      diffs.forEach((diff) => {
        const row = document.createElement("div");
        row.className = `stat-diff ${diff.delta > 0 ? "positive" : "negative"}`;
        const label = document.createElement("span");
        label.textContent = diff.label;
        const value = document.createElement("span");
        value.textContent = diff.text.replace(`${diff.label} `, "");
        row.appendChild(label);
        row.appendChild(value);
        list.appendChild(row);
      });
      inventoryCompareResult.appendChild(list);
    }

    function openInventoryItemModal(item, index) {
      if (!item) return;
      clearComparisonResult();
      inventoryItemName.textContent = item?.name || "‰∏çÊòé„Å™„Ç¢„Ç§„ÉÜ„É†";
      applyItemRarityColor(inventoryItemName, item);
      inventoryItemDesc.textContent = item?.desc || "Ë™¨Êòé„Å™„Åó";

      const updateMeta = () => {
        const metaParts = [];
        if (item.favorite) metaParts.push("‚òÖ„ÅäÊ∞ó„Å´ÂÖ•„Çä");
        if (isItemEquipped(item)) metaParts.push("Ë£ÖÂÇô‰∏≠");
        const qty = typeof item?.quantity === "number" ? item.quantity : 1;
        if (qty > 1) metaParts.push(`ÊâÄÊåÅ: √ó${qty}`);
        if (item.equipment?.rarityLabel) metaParts.push(item.equipment.rarityLabel);
        inventoryItemMeta.textContent = metaParts.join(" / ");
        inventoryItemMeta.style.display = metaParts.length ? "flex" : "none";
      };
      updateMeta();

      const sellPrice = calculateItemSellValue(item);

      inventoryItemDetail.innerHTML = "";
      if (item.type === "potion" && item.potion) {
        const useCost = item.potion.useCost ?? 25;
        const maxFullness = item.potion.maxFullness ?? 100;
        const currentFill = Math.max(0, Math.min(maxFullness, item.potion.fullness ?? maxFullness));
        const fields = [
          { label: "Á®ÆÈ°û", value: item.potion.type === "hp" ? "HPÂõûÂæ©" : "MPÂõûÂæ©" },
          { label: "ÂäπÊûú", value: item.potion.type === "hp" ? `HP„Çí${item.potion.amount}ÂõûÂæ©` : `MP„Çí${item.potion.amount}ÂõûÂæ©` },
          { label: "Ê∂àË≤ª", value: `1Âõû ${useCost}% Ê∂àË≤ª` },
          { label: "ÊÆãÈáè", value: `${Math.round(currentFill)}% / ${maxFullness}%` },
        ];
        if (sellPrice > 0) {
          fields.push({ label: "Â£≤ÂÄ§", value: `${formatGold(sellPrice)}G` });
        }
        fields.forEach((f) => {
          const row = document.createElement("div");
          row.textContent = `${f.label} ${f.value}`;
          inventoryItemDetail.appendChild(row);
        });
      } else if (item.type === "equipment" && item.equipment) {
        const rarity = item.equipment.rarityLabel || item.equipment.rarity;
        const slotLabel = EQUIPMENT_SLOTS[item.equipment.slot]?.label || item.equipment.slot;
        const fields = [
          { label: "ÈÉ®‰Ωç", value: slotLabel },
          { label: "„É¨„Ç¢Â∫¶", value: rarity },
        ];
        if (sellPrice > 0) {
          fields.push({ label: "Â£≤ÂÄ§", value: `${formatGold(sellPrice)}G` });
        }
        fields.forEach((f) => {
          const row = document.createElement("div");
          row.textContent = `${f.label} ${f.value}`;
          inventoryItemDetail.appendChild(row);
        });

        const appendOptions = (title, options) => {
          if (!options?.length) return;
          const block = document.createElement("div");
          block.className = "equipment-option-list";
          const heading = document.createElement("div");
          heading.className = "option-label";
          heading.textContent = title;
          block.appendChild(heading);
          options.forEach((option) => {
            const line = document.createElement("div");
            line.className = "option-value";
            line.textContent = formatEquipmentValue(option);
            block.appendChild(line);
          });
          inventoryItemDetail.appendChild(block);
        };

        const appendAffix = (label, affix) => {
          if (!affix?.options?.length) return;
          appendOptions(`${label} (‚òÖ${affix.rank}) ${affix.name}`, affix.options);
        };

        if (item.equipment.uniqueOptions?.length) {
          const uniqueBlock = document.createElement("div");
          uniqueBlock.className = "equipment-option-list";
          const heading = document.createElement("div");
          heading.className = "option-label";
          heading.textContent = "Âõ∫Êúâ„Ç™„Éó„Ç∑„Éß„É≥";
          uniqueBlock.appendChild(heading);
          item.equipment.uniqueOptions.forEach((opt) => {
            const line = document.createElement("div");
            line.className = "option-value";
            line.textContent = `${opt.name}: ${opt.effect}`;
            uniqueBlock.appendChild(line);
          });
          inventoryItemDetail.appendChild(uniqueBlock);
        }

        appendOptions("Âü∫Á§é„Ç™„Éó„Ç∑„Éß„É≥", item.equipment.baseOptions);
        appendOptions("„É©„É≥„ÉÄ„É†„Ç™„Éó„Ç∑„Éß„É≥", item.equipment.randomOptions);
        appendAffix("ÂâçÁß∞Âè∑", item.equipment.prefix);
        appendAffix("ÂæåÁß∞Âè∑", item.equipment.suffix);
      } else {
        const empty = document.createElement("div");
        empty.className = "help-panel";
        empty.textContent = "Ë©≥Á¥∞ÊÉÖÂ†±„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì";
        empty.style.gridColumn = "1 / -1";
        inventoryItemDetail.appendChild(empty);
      }

      const renderActions = () => {
        inventoryItemActions.innerHTML = "";
        const favoriteBtn = document.createElement("button");
        const updateFavoriteButton = () => {
          favoriteBtn.textContent = item.favorite ? "‚òÖ „ÅäÊ∞ó„Å´ÂÖ•„Çä‰∏≠" : "‚òÜ „ÅäÊ∞ó„Å´ÂÖ•„ÇäÁôªÈå≤";
          favoriteBtn.ariaPressed = item.favorite ? "true" : "false";
        };
        favoriteBtn.onclick = () => {
          item.favorite = !item.favorite;
          renderInventory();
          updateFavoriteButton();
          updateMeta();
          renderActions();
        };
        updateFavoriteButton();
        inventoryItemActions.appendChild(favoriteBtn);

        let sellBtn = null;
        const refreshSellButton = () => {
          if (!sellBtn) return;
          const equipped = isItemEquipped(item);
          const disabled = equipped || item.favorite;
          const label = disabled
            ? equipped
              ? "Ë£ÖÂÇô‰∏≠„ÅØÂ£≤Âç¥‰∏çÂèØ"
              : "„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅØÂ£≤Âç¥‰∏çÂèØ"
            : `Â£≤Âç¥ (${formatGold(sellPrice)}G)`;
          sellBtn.textContent = label;
          sellBtn.disabled = disabled;
        };

        if (item.type === "potion" && item.potion && player.potions?.length) {
          player.potions.forEach((p, slot) => {
            const btn = document.createElement("button");
            const isSame = p?.id === item.potion.id;
            btn.textContent = isSame ? `„Çπ„É≠„ÉÉ„Éà${slot + 1}ÔºàË£ÖÂÇô‰∏≠Ôºâ` : `„Çπ„É≠„ÉÉ„Éà${slot + 1}„Å´Ë£ÖÂÇô`;
            btn.disabled = isSame;
            btn.onclick = () => {
              equipPotionFromInventory(index, slot);
              closeInventoryItemModal();
            };
            inventoryItemActions.appendChild(btn);
          });
        } else if (item.type === "equipment" && item.equipment) {
          const slotLabel = EQUIPMENT_SLOTS[item.equipment.slot]?.label || item.equipment.slot;
          const addEquipButtons = (slotKey) => {
            const slotName = PLAYER_EQUIPMENT_SLOTS[slotKey]?.label || slotLabel;
            const equipped = player.equipment?.[slotKey];
            const isSame = equipped?.id === item.id;
            const equipBtn = document.createElement("button");
            equipBtn.textContent = isSame ? `${slotName}ÔºàË£ÖÂÇô‰∏≠Ôºâ` : `${slotName}„Å´Ë£ÖÂÇô`;
            equipBtn.disabled = isSame;
            equipBtn.onclick = () => {
              equipItem(slotKey, item);
              log(`üõ°Ô∏è ${item.name} „Çí${slotName}„Å´Ë£ÖÂÇô„Åó„Åü`, "good");
              renderInventory();
              clearComparisonResult();
              updateMeta();
              renderActions();
            };
            inventoryItemActions.appendChild(equipBtn);

            const compareBtn = document.createElement("button");
            compareBtn.textContent = `${slotName}„Å®ÊØîËºÉ`;
            compareBtn.onclick = () => renderComparisonResult(slotKey, item);
            inventoryItemActions.appendChild(compareBtn);

            if (equipped) {
              const unequipBtn = document.createElement("button");
              unequipBtn.textContent = `${slotName}„ÇíÂ§ñ„Åô`;
              unequipBtn.onclick = () => {
                unequipItem(slotKey);
                log(`üß§ ${slotName}„ÅÆË£ÖÂÇô„ÇíÂ§ñ„Åó„Åü`, "info");
                renderInventory();
                clearComparisonResult();
                updateMeta();
                renderActions();
              };
              inventoryItemActions.appendChild(unequipBtn);
            }
          };

          if (item.equipment.slot === "accessory") {
            ["accessory1", "accessory2"].forEach(addEquipButtons);
          } else {
            addEquipButtons(item.equipment.slot);
          }
        } else {
          const note = document.createElement("div");
          note.className = "help-panel";
          note.textContent = "Ë£ÖÂÇôÂèØËÉΩ„Å™„Çπ„É≠„ÉÉ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì";
          inventoryItemActions.appendChild(note);
        }

        if (sellPrice > 0) {
          sellBtn = document.createElement("button");
          refreshSellButton();
          sellBtn.onclick = () => sellInventoryItem(index, item, sellPrice);
          inventoryItemActions.appendChild(sellBtn);
        }
      };

      renderActions();
      inventoryItemModal?.classList.remove("hidden");
    }

    function closeInventoryItemModal() {
      clearComparisonResult();
      inventoryItemModal?.classList.add("hidden");
    }

    function promptPlayerTurn() {
      restoreAttackCounts();
      game.awaitingInput = true;
      renderActions();
    }

    function endPlayerTurn() {
      game.awaitingInput = false;
      finalizeTurn(player);
      renderActions();
      setTimeout(() => nextTurn(), 350);
    }

    function chooseTargetForPlayer() {
      const aliveEnemies = game.enemies.filter(e => e.hp > 0);
      if (aliveEnemies.length === 0) return null;
      if (hasStatus(player, "confusion")) {
        const pool = [...aliveEnemies, player];
        return pool[Math.floor(Math.random() * pool.length)];
      }
      return aliveEnemies[0];
    }

    function chooseTargetForEnemy(enemy) {
      const allies = game.enemies.filter(e => e.hp > 0 && e.id !== enemy.id);
      if (hasStatus(enemy, "confusion") && (allies.length > 0 || player.hp > 0)) {
        const pool = [player, ...allies, enemy];
        return pool[Math.floor(Math.random() * pool.length)];
      }
      return player;
    }

    function getAccuracyWithStatus(entity) {
      const debuff = getStatus(entity, "accuracyDown");
      let acc = entity.accuracy || 90;
      if (debuff) {
        acc *= 1 - (debuff.potency ?? STATUS_DEFINITIONS.accuracyDown.potency ?? 0.15);
      }
      return Math.max(30, acc);
    }

    function getEvasionWithStatus(entity) {
      const debuff = getStatus(entity, "evasionDown");
      let eva = entity.evade || 0;
      if (debuff) {
        eva *= 1 - (debuff.potency ?? STATUS_DEFINITIONS.evasionDown.potency ?? 0.15);
      }
      return Math.max(0, eva);
    }

    function attemptHit(attacker, defender) {
      const acc = getAccuracyWithStatus(attacker);
      const eva = getEvasionWithStatus(defender);
      const hitChance = Math.max(20, Math.min(98, 90 + (acc - eva) * 0.4));
      return Math.random() * 100 < hitChance;
    }

    function calcDamage(attacker, defender, { type = "physical" } = {}) {
      const variance = 0.85 + Math.random() * 0.3;
      const attackDebuff = type === "physical" ? getStatus(attacker, "physAttackDown") : getStatus(attacker, "magAttackDown");
      const baseAttack = type === "physical" ? attacker.atk : attacker.magAtk || attacker.atk;
      let attackPower = baseAttack * (attackDebuff ? 1 - (attackDebuff.potency ?? 0.2) : 1);
      if (hasStatus(attacker, "curse")) {
        attackPower *= 0.9;
      }
      let defense = type === "physical" ? defender.def : defender.magDef || defender.def;
      const defenseDown = type === "physical" ? getStatus(defender, "physDefenseDown") : getStatus(defender, "magDefenseDown");
      if (defenseDown) {
        defense *= 1 - (defenseDown.potency ?? 0.2);
      }
      const raw = Math.max(1, attackPower * variance - defense);
      return Math.max(1, Math.round(raw));
    }

    function applyDamage(target, amount, { type = "physical", source = "", isDot = false } = {}) {
      let final = amount;
      if (target === player && player.buffs.guard > 0 && !hasStatus(player, "seal")) {
        final = Math.round(final * 0.7);
      }
      final = Math.max(0, Math.round(final));
      target.hp = Math.max(0, target.hp - final);
      if (!isDot && final > 0 && hasStatus(target, "sleep")) {
        removeStatus(target, "sleep");
        log(`${target.name} „ÅØÊîªÊíÉ„ÇíÂèó„Åë„Å¶ÁõÆ„ÇíË¶ö„Åæ„Åó„Åü`, "info");
      }
      if (target === player) {
        flashBar("hp-bar");
        if (final > 0) {
          const playerBar = document.getElementById("hp-bar")?.parentElement;
          showDamagePopup(playerBar, final, "player");
        }
      } else {
        if (final > 0) triggerEnemyHit(target, final);
        updateEnemyCardHp(target);
      }
      return final;
    }

    function onEnemyDefeated(enemy, { cause = "" } = {}) {
      if (!enemy || enemy.defeated) return;
      enemy.defeated = true;
      const baseGold = Math.max(1, Math.round(5 + game.floor * 2 + (enemy.isBoss ? 20 : 0)));
      grantGold(baseGold, { source: cause || "ÊíÉÁ†¥" });
      if (enemy.expReward) {
        grantExp(enemy.expReward, { source: cause || enemy.name });
      }
      attemptEnemyDrop(enemy);
      refillPotionsOnKill();
      updateUI();
    }

    function usePotion(index) {
      if (!game.awaitingInput) return;
      if (!player.potions || !player.potions[index]) return;
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      if (!enemiesAlive) {
        log("„Éù„Éº„Ç∑„Éß„É≥„ÅØÊà¶Èóò‰∏≠„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô", "warning");
        return;
      }
      const potion = player.potions[index];
      const useCost = potion.useCost ?? 25;
      const maxFullness = potion.maxFullness ?? 100;
      potion.fullness = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
      if (potion.fullness < useCost) {
        log("„Éù„Éº„Ç∑„Éß„É≥„ÅÆÊÆãÈáè„ÅåË∂≥„Çä„Å™„ÅÑ‚Ä¶", "warning");
        return;
      }

      const derived = recalcDerivedStats();
      if (potion.type === "hp") {
        if (player.hp >= derived.maxHp.total) {
          log("HP„ÅØÂçÅÂàÜ„Å´ÊÆã„Å£„Å¶„ÅÑ„Çã", "info");
          return;
        }
        const heal = Math.min(potion.amount, derived.maxHp.total - player.hp);
        player.hp = Math.min(derived.maxHp.total, player.hp + heal);
        log(`${potion.icon || "üß™"} ${potion.name}„ÇíÈ£≤„Çì„ÅßHP„Çí${heal}ÂõûÂæ©`, "good");
      } else if (potion.type === "mp") {
        if (player.mp >= derived.maxMp.total) {
          log("MP„ÅØÂçÅÂàÜ„Å´ÊÆã„Å£„Å¶„ÅÑ„Çã", "info");
          return;
        }
        const restored = Math.min(potion.amount, derived.maxMp.total - player.mp);
        player.mp = Math.min(derived.maxMp.total, player.mp + restored);
        log(`${potion.icon || "üîÆ"} ${potion.name}„ÇíÈ£≤„Çì„ÅßMP„Çí${restored}ÂõûÂæ©`, "good");
      }

      potion.fullness = Math.max(0, potion.fullness - useCost);
      updateUI();
    }

    function refillPotionsOnKill() {
      if (!player.potions?.length) return false;
      let restored = false;
      player.potions.forEach((potion) => {
        const maxFullness = potion.maxFullness ?? 100;
        const current = Math.max(0, Math.min(maxFullness, potion.fullness ?? maxFullness));
        const next = Math.min(maxFullness, current + POTION_REFILL_ON_KILL);
        if (next > current) {
          potion.fullness = next;
          restored = true;
        } else {
          potion.fullness = current;
        }
      });
      if (restored) {
        log("üíß „Éù„Éº„Ç∑„Éß„É≥„ÅÆÊÆãÈáè„ÅåÂ∞ë„ÅóÂõûÂæ©„Åó„Åü", "info");
      }
      return restored;
    }

    function playerAttack() {
      if (!game.awaitingInput) return;
      const attacks = Math.max(0, Math.floor(player.attacksRemaining ?? player.attackCount ?? 0));
      if (attacks <= 0) {
        log("ÊîªÊíÉÂõûÊï∞„ÅåÊÆã„Å£„Å¶„ÅÑ„Å™„ÅÑ‚Ä¶", "warning");
        return;
      }
      player.attacksRemaining = attacks;
      let acted = false;
      for (let i = 0; i < attacks; i += 1) {
        const target = chooseTargetForPlayer();
        if (!target) break;
        acted = true;
        const hit = attemptHit(player, target);
        if (!hit) {
          log(`‚öîÔ∏è „ÅÇ„Å™„Åü„ÅÆÊîªÊíÉ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}„ÅØÂ§ñ„Çå„Åü‚Ä¶`, "warning");
          continue;
        }
        const dmg = calcDamage(player, target);
        const dealt = applyDamage(target, dmg, { source: "player" });
        const targetName = target === player ? "Ëá™ÂàÜ" : target.name;
        log(`‚öîÔ∏è „ÅÇ„Å™„Åü„ÅÆÊîªÊíÉ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}ÔºÅ ${targetName} „Å´ ${dealt} „ÉÄ„É°„Éº„Ç∏`, target === player ? "warning" : "player");
        if (target !== player && target.hp <= 0) {
          log(`${target.name} „ÇíÂÄí„Åó„ÅüÔºÅ`, "good");
          onEnemyDefeated(target, { cause: "ÊíÉÁ†¥" });
          checkVictory();
          if (!game.enemies.some(e => e.hp > 0)) break;
        }
        player.attacksRemaining = Math.max(0, attacks - i - 1);
      }
      if (!acted) return;
      updateUI();
      maybeAutoSave("ÊîªÊíÉ");
      endPlayerTurn();
    }

    function useActiveSkill(slotIndex) {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }

      const slot = player.activeSkillSlots?.[slotIndex];
      const skill = slot?.skillKey ? skills[slot.skillKey] : null;
      if (!skill || skill.type !== "active") {
        log("„Åì„ÅÆÊû†„Å´„ÅØ„Çπ„Ç≠„É´„Åå„Çª„ÉÉ„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì", "warning");
        return;
      }
      if (skill.level <= 0) {
        log("„Çπ„Ç≠„É´„ÇíÁøíÂæó„Åó„Å¶„Åã„Çâ‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "warning");
        return;
      }
      if (slot.cooldownRemaining > 0) {
        log(`${skill.name}„ÅØ„ÇØ„Éº„É´„Çø„Ç§„É†‰∏≠ (${slot.cooldownRemaining}T)`, "warning");
        return;
      }

      const target = chooseTargetForPlayer();
      if (!target) return;

      const mpCost = skill.activation?.mpCost ?? 0;
      if (player.mp < mpCost) {
        log(`MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ (ÂøÖË¶ÅMP: ${mpCost})`, "warning");
        return;
      }
      consumeMp(mpCost);

      const hit = attemptHit(player, target);
      const effectLabel = skill.activation?.effect ? `: ${skill.activation.effect}` : "";
      if (!hit) {
        log(`üåÄ ${skill.name}${effectLabel} „ÅØÂ§ñ„Çå„Åü‚Ä¶`, "warning");
        slot.cooldownRemaining = getEffectiveSkillCooldown(skill);
        renderActiveSkillLoadout();
        updateUI();
        return;
      }

      const baseDamage = calcDamage(player, target);
      const multiplier = 1.1 + skill.level * 0.02;
      const dmg = Math.round(baseDamage * multiplier);
      const dealt = applyDamage(target, dmg, { source: skill.name });
      log(`üåÄ ${skill.name}${effectLabel}ÔºÅ ${target.name} „Å´ ${dealt} „ÉÄ„É°„Éº„Ç∏`, "player");

      if (target.hp <= 0) {
        log(`${target.name} „ÇíÂÄí„Åó„ÅüÔºÅ`, "good");
        onEnemyDefeated(target, { cause: skill.name });
        checkVictory();
      }

      slot.cooldownRemaining = getEffectiveSkillCooldown(skill);
      renderActiveSkillLoadout();
      updateUI();
    }

    function powerStrike() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      if (player.mp < 5) {
        log("MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      consumeMp(5);
      const target = chooseTargetForPlayer();
      if (!target) return;
      const hit = attemptHit(player, target);
      if (!hit) {
        log("üåå „Éë„ÉØ„Éº„Çπ„Éà„É©„Ç§„ÇØ„ÅØÁ©∫ÊåØ„ÇäÔºÅ", "warning");
        updateUI();
        endPlayerTurn();
        return;
      }
      const dmg = Math.round(calcDamage(player, target) * 1.6 + (player.buffs.focus ? 6 : 0));
      const dealt = applyDamage(target, dmg, { source: "player" });
      log(`üåå „Éë„ÉØ„Éº„Çπ„Éà„É©„Ç§„ÇØÔºÅ ${target.name} „Å´ ${dealt} „ÉÄ„É°„Éº„Ç∏`, "player");
      if (target.hp <= 0) {
        log(`${target.name} „ÇíÁ≤âÁ†ïÔºÅ`, "good");
        onEnemyDefeated(target, { cause: "ÊíÉÁ†¥" });
        checkVictory();
      } else {
        const knocked = applyStatus(target, "knockdown", { duration: 1, chance: 70 });
        if (knocked) log(`${target.name} „ÇíËª¢ÂÄí„Åï„Åõ„ÅüÔºÅ`, "good");
      }
      updateUI();
      endPlayerTurn();
    }

    function heal() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      if (player.mp < 4) {
        log("MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      consumeMp(4);
      const healAmount = Math.max(6, Math.round(player.maxHp * 0.12 + (player.buffs.focus ? 5 : 0)));
      player.hp = Math.min(player.maxHp, player.hp + healAmount);
      log(`‚ú® „Éí„Éº„É´ÔºÅ HP„Åå ${healAmount} ÂõûÂæ©`, "good");
      updateUI();
      endPlayerTurn();
    }

    function guard() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      if (player.mp < 2) {
        log("MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      consumeMp(2);
      player.buffs.guard = 2;
      log("üõ°Ô∏è ÂÆà„Çä„ÇíÂõ∫„ÇÅ„ÅüÔºÅ Ê¨°„ÅÆ2„Çø„Éº„É≥Ë¢´„ÉÄ„É°ËªΩÊ∏õ", "good");
      updateUI();
      endPlayerTurn();
    }

    function boost() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      if (player.mp < 2) {
        log("MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      consumeMp(2);
      player.buffs.haste = 2;
      log("üí® „Éñ„Éº„Çπ„ÉàÔºÅ Ê¨°„ÅÆ2„Çø„Éº„É≥Ë°åÂãïÈÄüÂ∫¶„Ç¢„ÉÉ„Éó", "good");
      updateUI();
      endPlayerTurn();
    }

    function focus() {
      if (!game.awaitingInput) return;
      if (hasStatus(player, "silence")) {
        log("Ê≤àÈªô‰∏≠„Åß„Çπ„Ç≠„É´„Åå‰Ωø„Åà„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      if (player.mp < 3) {
        log("MP„ÅåË∂≥„Çä„Å™„ÅÑÔºÅ", "warning");
        return;
      }
      consumeMp(3);
      player.buffs.focus = 2;
      log("üéØ „Éï„Ç©„Éº„Ç´„ÇπÔºÅ „ÇØ„É™„ÉÜ„Ç£„Ç´„É´Áéá„Ç¢„ÉÉ„Éó", "good");
      updateUI();
      endPlayerTurn();
    }

    function resetPlayerAfterPenalty({ restoreHp = true } = {}) {
      player.statuses = [];
      player.buffs = { guard: 0, haste: 0, focus: 0 };
      recalcDerivedStats();
      player.hp = restoreHp ? player.maxHp : Math.min(player.hp, player.maxHp);
      player.mp = player.maxMp;
      player.attacksRemaining = player.attackCount;
      player.activeSkillSlots.forEach((slot) => {
        slot.cooldownRemaining = 0;
      });
      game.enemies = [];
      game.turnQueue = [];
      game.awaitingInput = false;
    }

    function retreatLowerFloors(drop, { reason = "Êí§ÈÄÄ", tone = "warning", restoreHp = true } = {}) {
      const previousFloor = game.floor;
      game.floor = Math.max(1, game.floor - drop);
      const moved = previousFloor - game.floor;
      const movementText = moved > 0 ? `${moved}Èöé„Åï„Åå„Çã` : "„Åì„Çå‰ª•‰∏ä‰∏ã„Åå„Çå„Å™„ÅÑ";
      log(`‚ÜòÔ∏è ${reason}„Åß${movementText} (${previousFloor}F ‚Üí ${game.floor}F)`, tone);
      resetPlayerAfterPenalty({ restoreHp });
      spawnEnemies();
      updateUI();
      maybeAutoSave(`Êà¶ÈóòÁµÇ‰∫Ü: ${reason}`);
    }

function handlePlayerDefeat() {
  // ÈÄ£Á∂ö„ÅßÂëº„Å∞„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´„Ç¨„Éº„Éâ„ÇíÂÖ•„Çå„Å¶„Åä„Åè
  if (game.playerDefeatInProgress) return;
  game.playerDefeatInProgress = true;

  // „ÇÇ„ÅÜÂÖ•Âäõ„ÅØÂèó„Åë‰ªò„Åë„Å™„ÅÑ
  game.awaitingInput = false;

  // ‚òÖ „Åì„ÅÆÊôÇÁÇπ„Åß„ÅØ HP „ÅØ 0 „ÅÆ„Åæ„Åæ„Å™„ÅÆ„Åß„ÄÅ
  // updateUI „ÇíÂëº„Å∂„Å® .player-down „ÇØ„É©„Çπ„Åå‰ªò„Åç„ÄÅ
  // „ÄåÊà¶Èóò‰∏çËÉΩ„Äç„Ç™„Éº„Éê„Éº„É¨„Ç§„ÅåË°®Á§∫„Åï„Çå„Çã
  updateUI();

  // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÈöéÂ±§„Éö„Éä„É´„ÉÜ„Ç£ÔºÜHPÂÖ®ÂõûÂæ©ÔºÜÂÜçÈñã
  setTimeout(() => {
    retreatLowerFloors(20, { reason: "Êà¶Èóò‰∏çËÉΩ", tone: "danger" });
    game.playerDefeatInProgress = false;
  }, 450); // ÊºîÂá∫ÊôÇÈñì„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥Ôºà0.4„Äú0.6Áßí„Åè„Çâ„ÅÑ„ÅäÂ•Ω„Åø„ÅßÔºâ
}


    function attemptEscape() {
      if (!game.awaitingInput) return;
      const enemiesAlive = game.enemies.some(e => e.hp > 0);
      if (!enemiesAlive) {
        log("ÈÄÉ„Åí„ÇãÁõ∏Êâã„Åå„ÅÑ„Å™„ÅÑ", "info");
        return;
      }
      retreatLowerFloors(5, { reason: "„Å´„Åí„Å†„Åó„Åü", tone: "warning", restoreHp: false });
    }

    function enemyAction(enemy) {
      if (enemy.hp <= 0) return false;
      const attacks = Math.max(0, Math.floor(enemy.attacksRemaining ?? enemy.attackCount ?? 0));
      if (attacks <= 0) return false;
      enemy.attacksRemaining = attacks;
      for (let i = 0; i < attacks; i += 1) {
        const target = chooseTargetForEnemy(enemy);
        if (!target) return false;
        const hit = attemptHit(enemy, target);
        const targetLabel = target === player ? "„ÅÇ„Å™„Åü" : target.name;
        if (!hit) {
          log(`‚ò†Ô∏è ${enemy.name} „ÅÆÊîªÊíÉ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}„ÅØ ${targetLabel} „Å´ÂΩì„Åü„Çâ„Å™„Åã„Å£„Åü`, "info");
          continue;
        }
        const dmg = calcDamage(enemy, target);
        const isCrit = Math.random() < 0.12;
        const finalDmg = isCrit ? Math.round(dmg * 1.4) : dmg;
        const dealt = applyDamage(target, finalDmg, { source: enemy.name });
        const critText = isCrit ? " (‰ºöÂøÉÔºÅ)" : "";
        log(`‚ò†Ô∏è ${enemy.name} „ÅÆÊîªÊíÉ${attacks > 1 ? `(${i + 1}/${attacks})` : ""}${critText}ÔºÅ ${targetLabel}„Å´ ${dealt} „ÉÄ„É°„Éº„Ç∏`, "enemy");
          if (target !== player && target.hp <= 0) {
            log(`${target.name} „ÅØÂÄí„Çå„Åü`, "good");
            onEnemyDefeated(target, { cause: "Ê∑∑‰π±" });
            checkVictory();
            if (!game.enemies.some(e => e.hp > 0)) return false;
          }
        if (player.hp <= 0) {
          handlePlayerDefeat();
          return true;
        }
        enemy.attacksRemaining = Math.max(0, attacks - i - 1);
      }
      return false;
    }

    function nextTurn() {
      if (player.hp <= 0) {
        handlePlayerDefeat();
        return;
      }
      if (game.turnQueue.length === 0) {
        buildTurnQueue();
      }
      const actor = game.turnQueue.shift();
      if (!actor) return;
      const entity = actor.type === "player" ? player : game.enemies.find(e => e.id === actor.id);
      if (!entity) {
        nextTurn();
        return;
      }

      const turnState = processTurnStart(entity);
      updateUI();

      if (entity.hp <= 0) {
        if (actor.type === "enemy") {
          onEnemyDefeated(entity, { cause: "ÊíÉÁ†¥" });
          log(`${entity.name} „ÅØÂÄí„Çå„Åü`, "good");
          checkVictory();
        } else {
          handlePlayerDefeat();
          return;
        }
        setTimeout(() => nextTurn(), 380);
        return;
      }

      if (turnState.skipTurn) {
        finalizeTurn(entity);
        setTimeout(() => nextTurn(), 380);
        return;
      }

      if (actor.type === "player") {
        promptPlayerTurn();
        return;
      }
      const playerFell = enemyAction(entity);
      if (playerFell) return;
      finalizeTurn(entity);
      updateUI();
      if (player.hp <= 0) {
        handlePlayerDefeat();
        return;
      }
      setTimeout(() => nextTurn(), 380);
    }

    function checkVictory() {
      if (game.enemies.some(e => e.hp > 0)) return;
      const mpGain = 3 + skills.arcaneFlow.level * 2;
      player.mp = Math.min(player.maxMp, player.mp + mpGain);
      log(`‚ú® Êà¶Èóò„Å´ÂãùÂà©„Åó„ÄÅMP„Çí ${mpGain} ÂõûÂæ©„Åó„Åü`, "good");
      game.awaitingInput = false;
      game.turnQueue = [];
      updateUI();
      maybeAutoSave("„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢");
    }

    function levelUp() {
      player.level += 1;
      player.expToLevel = Math.round(player.expToLevel * 1.18);
      recalcDerivedStats();
      player.hp = player.maxHp;
      player.mp = player.maxMp;
      player.statPoints += 5;
      player.skillPoints += 1;
      log(`‚¨ÜÔ∏è „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ Lv${player.level} ËÉΩÂäõP+5 / „Çπ„Ç≠„É´P+1`, "good");
      triggerLevelUpEffect(player.level);
      maybeAutoSave("„É¨„Éô„É´„Ç¢„ÉÉ„Éó");
    }

    function resetAllocations() {
      const spent = pendingResetSpent;
      Object.entries(player.allocations).forEach(([key, amount]) => {
        if (amount > 0) {
          player.primary[key].base -= amount;
          player.allocations[key] = 0;
        }
      });
      player.statPoints += spent;
      recalcDerivedStats();
      updateUI();
      log("„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü", "info");
      pendingResetSpent = 0;
      maybeAutoSave("„Çπ„ÉÜ„Éº„Çø„ÇπÊåØ„ÇäÁõ¥„Åó");
    }

    function nextFloor() {
      if (game.enemies.some(e => e.hp > 0) && player.hp > 0) {
        log("Êïµ„ÅåÊÆã„Å£„Å¶„ÅÑ„ÇãÔºÅ", "warning");
        return;
      }
      game.floor += 1;
      player.buffs.guard = 0;
      game.turnQueue = [];
      spawnEnemies();
      updateUI();
      maybeAutoSave("Ê¨°„ÅÆÈöé„Å∏ÈÄ≤Ë°å");
    }

    document.getElementById("btn-skill-tree").addEventListener("click", openSkillsModal);
    document.getElementById("btn-player-modal").addEventListener("click", openPlayerModal);
    inventoryOpenButton?.addEventListener("click", openInventoryModal);
    debugOpenButton?.addEventListener("click", openDebugModal);
    debugCloseButton?.addEventListener("click", closeDebugModal);
    archetypeCloseButton?.addEventListener("click", closeArchetypeModal);
    closeModalButton.addEventListener("click", closeEnemyModal);
    potionModalCloseButton.addEventListener("click", closePotionModal);
    skillInfoCloseButton?.addEventListener("click", closeSkillInfoModal);
    playerModalCloseButton.addEventListener("click", closePlayerModal);
    skillsModalCloseButton.addEventListener("click", closeSkillsModal);
    inventoryModalCloseButton?.addEventListener("click", closeInventoryModal);
    inventoryItemCloseButton?.addEventListener("click", closeInventoryItemModal);
    debugTargetSelect?.addEventListener("change", updateDebugTargetState);
    debugClearButton?.addEventListener("click", () => {
      const target = getDebugTarget();
      if (!target) {
        log("ÂØæË±°„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì", "warning");
        return;
      }
      target.statuses = [];
      log(`üêû „Éá„Éê„ÉÉ„Ç∞: ${target.name} „ÅÆÁä∂ÊÖãÁï∞Â∏∏„ÇíÂÖ®Ëß£Èô§`, "info");
      updateUI();
    });
    debugTabButtons.forEach((btn) => {
      btn.addEventListener("click", () => switchDebugTab(btn.dataset.tab));
    });

    debugApplyLevelButton?.addEventListener("click", applyDebugLevelChange);
    debugApplyHpButton?.addEventListener("click", applyDebugHpChange);
    debugApplyFloorButton?.addEventListener("click", applyDebugFloorChange);
    debugNewRunButton?.addEventListener("click", () => startNewRun(activeSaveSlotId));
    saveSlotList?.addEventListener("click", handleSaveAction);
    debugGearSlotSelect?.addEventListener("change", populateLegendaryTemplateSelect);
    debugGearRaritySelect?.addEventListener("change", populateLegendaryTemplateSelect);
    debugGenerateGearButton?.addEventListener("click", () => {
      generateDebugGear();
    });
    debugGenerateGearRandomButton?.addEventListener("click", () => {
      const keys = Object.keys(EQUIPMENT_RARITIES);
      const randomKey = keys[randomInt(0, keys.length - 1)];
      debugGearRaritySelect.value = randomKey;
      populateLegendaryTemplateSelect();
      generateDebugGear({ randomRarity: true });
    });
    statHelpButton.addEventListener("click", () => {
      memoModal.classList.remove("hidden");
    });
    memoCloseButton.addEventListener("click", () => memoModal.classList.add("hidden"));
    memoModal.addEventListener("click", (e) => {
      if (e.target === memoModal) memoModal.classList.add("hidden");
    });

    statStepButton.addEventListener("click", () => {
      currentStepIndex = (currentStepIndex + 1) % stepOptions.length;
      updateStepButton();
      renderPrimaryStats();
    });

    skillStepButton?.addEventListener("click", () => {
      currentSkillStepIndex = (currentSkillStepIndex + 1) % skillStepOptions.length;
      updateSkillStepButton();
      renderSkills();
    });

    skillSummaryToggleButton?.addEventListener("click", () => {
      renderSkillSummary();
      skillSummaryVisible = !skillSummaryVisible;
      updateSkillSummaryVisibility();
    });
    skillSummaryCloseButton?.addEventListener("click", () => {
      skillSummaryVisible = false;
      updateSkillSummaryVisibility();
    });
    skillSummaryModal?.addEventListener("click", (e) => {
      if (e.target === skillSummaryModal) {
        skillSummaryVisible = false;
        updateSkillSummaryVisibility();
      }
    });

    resetButton.addEventListener("click", () => {
      pendingResetSpent = Object.values(player.allocations).reduce((a, b) => a + b, 0);
      if (pendingResetSpent === 0) {
        log("„É™„Çª„ÉÉ„Éà„Åô„Çã„Éù„Ç§„É≥„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", "info");
        return;
      }
      resetSpentLabel.textContent = pendingResetSpent;
      resetModal.classList.remove("hidden");
    });
    resetCloseButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetCancelButton.addEventListener("click", () => resetModal.classList.add("hidden"));
    resetConfirmButton.addEventListener("click", () => {
      resetModal.classList.add("hidden");
      resetAllocations();
    });
    resetModal.addEventListener("click", (e) => {
      if (e.target === resetModal) resetModal.classList.add("hidden");
    });
    potionModal.addEventListener("click", (e) => {
      if (e.target === potionModal) closePotionModal();
    });
    skillInfoModal?.addEventListener("click", (e) => {
      if (e.target === skillInfoModal) closeSkillInfoModal();
    });
    resetSkillsButton.addEventListener("click", () => {
      const spent = Object.values(skills).reduce((sum, skill) => sum + skill.level, 0);
      if (spent === 0) {
        log("„É™„Çª„ÉÉ„Éà„Åô„Çã„Çπ„Ç≠„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì", "info");
        return;
      }
      skillResetSpentLabel.textContent = spent;
      skillResetModal.classList.remove("hidden");
    });
    skillResetCloseButton.addEventListener("click", () => skillResetModal.classList.add("hidden"));
    skillResetCancelButton.addEventListener("click", () => skillResetModal.classList.add("hidden"));
    skillResetConfirmButton.addEventListener("click", () => {
      skillResetModal.classList.add("hidden");
      resetSkills();
    });
    skillResetModal.addEventListener("click", (e) => {
      if (e.target === skillResetModal) skillResetModal.classList.add("hidden");
    });
    enemyModal.addEventListener("click", (e) => {
      if (e.target === enemyModal) closeEnemyModal();
    });
    playerModal.addEventListener("click", (e) => {
      if (e.target === playerModal) closePlayerModal();
    });
    skillsModal.addEventListener("click", (e) => {
      if (e.target === skillsModal) closeSkillsModal();
    });
    inventoryModal?.addEventListener("click", (e) => {
      if (e.target === inventoryModal) closeInventoryModal();
    });
    inventoryItemModal?.addEventListener("click", (e) => {
      if (e.target === inventoryItemModal) closeInventoryItemModal();
    });
    debugModal?.addEventListener("click", (e) => {
      if (e.target === debugModal) closeDebugModal();
    });
    archetypeModal?.addEventListener("click", (e) => {
      if (e.target === archetypeModal) closeArchetypeModal();
    });

    loadActiveSlotPreference();
    renderSaveSlots();

    const loadedFromSave = autoLoadLastActiveSlot();

    if (!loadedFromSave) {
      const initialDerived = recalcDerivedStats();
      renderSecondaryStats(initialDerived);
      log("=== ÊåëÊà¶ÈñãÂßã ===", "info");
      spawnEnemies();
      updateUI(initialDerived);
    } else {
      renderSaveSlots();
    }
    })();
  </script>
</body>
</html>
